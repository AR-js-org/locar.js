/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const sf="173",gw={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},vw={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},ob=0,dA=1,ab=2,Ew=3,xw=0,qg=1,lb=2,Qi=3,Or=0,kn=1,qi=2,Lr=0,bo=1,fA=2,pA=3,mA=4,cb=5,ds=100,hb=101,ub=102,db=103,fb=104,pb=200,mb=201,Ab=202,gb=203,ed=204,td=205,vb=206,Eb=207,xb=208,yb=209,_b=210,bb=211,Cb=212,Mb=213,Sb=214,nd=0,id=1,rd=2,To=3,sd=4,od=5,ad=6,ld=7,Bc=0,wb=1,Tb=2,Dr=0,Ib=1,Rb=2,Bb=3,Lb=4,Db=5,Pb=6,Ub=7,AA="attached",Fb="detached",of=300,kr=301,bs=302,ic=303,rc=304,nl=306,sc=1e3,mi=1001,oc=1002,xn=1003,Yg=1004,yw=1004,La=1005,_w=1005,ln=1006,Ql=1007,bw=1007,Yi=1008,Cw=1008,er=1009,jg=1010,$g=1011,Xa=1012,af=1013,Gr=1014,Un=1015,il=1016,lf=1017,cf=1018,vs=1020,Kg=35902,Jg=1021,Zg=1022,On=1023,e0=1024,t0=1025,Es=1026,xs=1027,hf=1028,Lc=1029,n0=1030,uf=1031,Mw=1032,df=1033,Wl=33776,Xl=33777,ql=33778,Yl=33779,cd=35840,hd=35841,ud=35842,dd=35843,fd=36196,pd=37492,md=37496,Ad=37808,gd=37809,vd=37810,Ed=37811,xd=37812,yd=37813,_d=37814,bd=37815,Cd=37816,Md=37817,Sd=37818,wd=37819,Td=37820,Id=37821,jl=36492,Rd=36494,Bd=36495,i0=36283,Ld=36284,Dd=36285,Pd=36286,Nb=2200,Ob=2201,kb=2202,ac=2300,Ud=2301,Uu=2302,go=2400,vo=2401,lc=2402,ff=2500,r0=2501,Sw=0,ww=1,Tw=2,Gb=3200,zb=3201,Iw=3202,Rw=3203,Is=0,Hb=1,xr="",Xn="srgb",Io="srgb-linear",cc="linear",Ut="srgb",Bw=0,lo=7680,Lw=7681,Dw=7682,Pw=7683,Uw=34055,Fw=34056,Nw=5386,Ow=512,kw=513,Gw=514,zw=515,Hw=516,Vw=517,Qw=518,gA=519,Vb=512,Qb=513,Wb=514,s0=515,Xb=516,qb=517,Yb=518,jb=519,hc=35044,Ww=35048,Xw=35040,qw=35045,Yw=35049,jw=35041,$w=35046,Kw=35050,Jw=35042,Zw="100",vA="300 es",Li=2e3,uc=2001,e1={COMPUTE:"compute",RENDER:"render"};let tr=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){const i=this._listeners;return i===void 0?!1:i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){const i=this._listeners;if(i===void 0)return;const r=i[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const i=t[e.type];if(i!==void 0){e.target=this;const r=i.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}};const yn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Mv=1234567;const Co=Math.PI/180,qa=180/Math.PI;function ii(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(yn[n&255]+yn[n>>8&255]+yn[n>>16&255]+yn[n>>24&255]+"-"+yn[e&255]+yn[e>>8&255]+"-"+yn[e>>16&15|64]+yn[e>>24&255]+"-"+yn[t&63|128]+yn[t>>8&255]+"-"+yn[t>>16&255]+yn[t>>24&255]+yn[i&255]+yn[i>>8&255]+yn[i>>16&255]+yn[i>>24&255]).toLowerCase()}function pt(n,e,t){return Math.max(e,Math.min(t,n))}function o0(n,e){return(n%e+e)%e}function t1(n,e,t,i,r){return i+(n-e)*(r-i)/(t-e)}function n1(n,e,t){return n!==e?(t-n)/(e-n):0}function $l(n,e,t){return(1-t)*n+t*e}function i1(n,e,t,i){return $l(n,e,1-Math.exp(-t*i))}function r1(n,e=1){return e-Math.abs(o0(n,e*2)-e)}function s1(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function o1(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function a1(n,e){return n+Math.floor(Math.random()*(e-n+1))}function l1(n,e){return n+Math.random()*(e-n)}function c1(n){return n*(.5-Math.random())}function h1(n){n!==void 0&&(Mv=n);let e=Mv+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function u1(n){return n*Co}function d1(n){return n*qa}function f1(n){return(n&n-1)===0&&n!==0}function p1(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function m1(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function A1(n,e,t,i,r){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),c=s((e+i)/2),h=o((e+i)/2),u=s((e-i)/2),d=o((e-i)/2),f=s((i-e)/2),A=o((i-e)/2);switch(r){case"XYX":n.set(a*h,l*u,l*d,a*c);break;case"YZY":n.set(l*d,a*h,l*u,a*c);break;case"ZXZ":n.set(l*u,l*d,a*h,a*c);break;case"XZX":n.set(a*h,l*A,l*f,a*c);break;case"YXY":n.set(l*f,a*h,l*A,a*c);break;case"ZYZ":n.set(l*A,l*f,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function Fn(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function gt(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const g1={DEG2RAD:Co,RAD2DEG:qa,generateUUID:ii,clamp:pt,euclideanModulo:o0,mapLinear:t1,inverseLerp:n1,lerp:$l,damp:i1,pingpong:r1,smoothstep:s1,smootherstep:o1,randInt:a1,randFloat:l1,randFloatSpread:c1,seededRandom:h1,degToRad:u1,radToDeg:d1,isPowerOfTwo:f1,ceilPowerOfTwo:p1,floorPowerOfTwo:m1,setQuaternionFromProperEuler:A1,normalize:gt,denormalize:Fn};let Ne=class $b{constructor(e=0,t=0){$b.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=pt(this.x,e.x,t.x),this.y=pt(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=pt(this.x,e,t),this.y=pt(this.y,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(pt(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(pt(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}},At=class Kb{constructor(e,t,i,r,s,o,a,l,c){Kb.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,i,r,s,o,a,l,c)}set(e,t,i,r,s,o,a,l,c){const h=this.elements;return h[0]=e,h[1]=r,h[2]=a,h[3]=t,h[4]=s,h[5]=l,h[6]=i,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],h=i[4],u=i[7],d=i[2],f=i[5],A=i[8],g=r[0],m=r[3],p=r[6],v=r[1],E=r[4],x=r[7],M=r[2],w=r[5],S=r[8];return s[0]=o*g+a*v+l*M,s[3]=o*m+a*E+l*w,s[6]=o*p+a*x+l*S,s[1]=c*g+h*v+u*M,s[4]=c*m+h*E+u*w,s[7]=c*p+h*x+u*S,s[2]=d*g+f*v+A*M,s[5]=d*m+f*E+A*w,s[8]=d*p+f*x+A*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8];return t*o*h-t*a*c-i*s*h+i*a*l+r*s*c-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=h*o-a*c,d=a*l-h*s,f=c*s-o*l,A=t*u+i*d+r*f;if(A===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/A;return e[0]=u*g,e[1]=(r*c-h*i)*g,e[2]=(a*i-r*o)*g,e[3]=d*g,e[4]=(h*t-r*l)*g,e[5]=(r*s-a*t)*g,e[6]=f*g,e[7]=(i*l-c*t)*g,e[8]=(o*t-i*s)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(tp.makeScale(e,t)),this}rotate(e){return this.premultiply(tp.makeRotation(-e)),this}translate(e,t){return this.premultiply(tp.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,i,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}};const tp=new At;function Jb(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const v1={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Da(n,e){return new v1[n](e)}function dc(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function Zb(){const n=dc("canvas");return n.style.display="block",n}const Sv={};function Ta(n){n in Sv||(Sv[n]=!0,console.warn(n))}function E1(n,e,t){return new Promise(function(i,r){function s(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:r();break;case n.TIMEOUT_EXPIRED:setTimeout(s,t);break;default:i()}}setTimeout(s,t)})}function x1(n){const e=n.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function y1(n){const e=n.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const wv=new At().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Tv=new At().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function _1(){const n={enabled:!0,workingColorSpace:Io,spaces:{},convert:function(r,s,o){return this.enabled===!1||s===o||!s||!o||(this.spaces[s].transfer===Ut&&(r.r=Pr(r.r),r.g=Pr(r.g),r.b=Pr(r.b)),this.spaces[s].primaries!==this.spaces[o].primaries&&(r.applyMatrix3(this.spaces[s].toXYZ),r.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===Ut&&(r.r=Ha(r.r),r.g=Ha(r.g),r.b=Ha(r.b))),r},fromWorkingColorSpace:function(r,s){return this.convert(r,this.workingColorSpace,s)},toWorkingColorSpace:function(r,s){return this.convert(r,s,this.workingColorSpace)},getPrimaries:function(r){return this.spaces[r].primaries},getTransfer:function(r){return r===xr?cc:this.spaces[r].transfer},getLuminanceCoefficients:function(r,s=this.workingColorSpace){return r.fromArray(this.spaces[s].luminanceCoefficients)},define:function(r){Object.assign(this.spaces,r)},_getMatrix:function(r,s,o){return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(r){return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(r=this.workingColorSpace){return this.spaces[r].workingColorSpaceConfig.unpackColorSpace}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],i=[.3127,.329];return n.define({[Io]:{primaries:e,whitePoint:i,transfer:cc,toXYZ:wv,fromXYZ:Tv,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:Xn},outputColorSpaceConfig:{drawingBufferColorSpace:Xn}},[Xn]:{primaries:e,whitePoint:i,transfer:Ut,toXYZ:wv,fromXYZ:Tv,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:Xn}}}),n}const wt=_1();function Pr(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Ha(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let Vo,eC=class{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Vo===void 0&&(Vo=dc("canvas")),Vo.width=e.width,Vo.height=e.height;const i=Vo.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Vo}return t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=dc("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),s=r.data;for(let o=0;o<s.length;o++)s[o]=Pr(s[o]/255)*255;return i.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(Pr(t[i]/255)*255):t[i]=Pr(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}},b1=0,Eo=class{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:b1++}),this.uuid=ii(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(np(r[o].image)):s.push(np(r[o]))}else s=np(r);i.url=s}return t||(e.images[this.uuid]=i),i}};function np(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?eC.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let C1=0,mn=class Fu extends tr{constructor(e=Fu.DEFAULT_IMAGE,t=Fu.DEFAULT_MAPPING,i=mi,r=mi,s=ln,o=Yi,a=On,l=er,c=Fu.DEFAULT_ANISOTROPY,h=xr){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:C1++}),this.uuid=ii(),this.name="",this.source=new Eo(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Ne(0,0),this.repeat=new Ne(1,1),this.center=new Ne(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new At,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==of)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case sc:e.x=e.x-Math.floor(e.x);break;case mi:e.x=e.x<0?0:1;break;case oc:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case sc:e.y=e.y-Math.floor(e.y);break;case mi:e.y=e.y<0?0:1;break;case oc:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}};mn.DEFAULT_IMAGE=null;mn.DEFAULT_MAPPING=of;mn.DEFAULT_ANISOTROPY=1;let Dt=class tC{constructor(e=0,t=0,i=0,r=1){tC.prototype.isVector4=!0,this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*i+o[11]*r+o[15]*s,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,s;const l=e.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],A=l[9],g=l[2],m=l[6],p=l[10];if(Math.abs(h-d)<.01&&Math.abs(u-g)<.01&&Math.abs(A-m)<.01){if(Math.abs(h+d)<.1&&Math.abs(u+g)<.1&&Math.abs(A+m)<.1&&Math.abs(c+f+p-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const E=(c+1)/2,x=(f+1)/2,M=(p+1)/2,w=(h+d)/4,S=(u+g)/4,B=(A+m)/4;return E>x&&E>M?E<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(E),r=w/i,s=S/i):x>M?x<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(x),i=w/r,s=B/r):M<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(M),i=S/s,r=B/s),this.set(i,r,s,t),this}let v=Math.sqrt((m-A)*(m-A)+(u-g)*(u-g)+(d-h)*(d-h));return Math.abs(v)<.001&&(v=1),this.x=(m-A)/v,this.y=(u-g)/v,this.z=(d-h)/v,this.w=Math.acos((c+f+p-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=pt(this.x,e.x,t.x),this.y=pt(this.y,e.y,t.y),this.z=pt(this.z,e.z,t.z),this.w=pt(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=pt(this.x,e,t),this.y=pt(this.y,e,t),this.z=pt(this.z,e,t),this.w=pt(this.w,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(pt(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}},pf=class extends tr{constructor(e=1,t=1,i={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Dt(0,0,e,t),this.scissorTest=!1,this.viewport=new Dt(0,0,e,t);const r={width:e,height:t,depth:1};i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:ln,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},i);const s=new mn(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);s.flipY=!1,s.generateMipmaps=i.generateMipmaps,s.internalFormat=i.internalFormat,this.textures=[];const o=i.count;for(let a=0;a<o;a++)this.textures[a]=s.clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=i.depthTexture,this.samples=i.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let r=0,s=this.textures.length;r<s;r++)this.textures[r].image.width=e,this.textures[r].image.height=t,this.textures[r].image.depth=i;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let i=0,r=e.textures.length;i<r;i++)this.textures[i]=e.textures[i].clone(),this.textures[i].isRenderTargetTexture=!0,this.textures[i].renderTarget=this;const t=Object.assign({},e.texture.image);return this.texture.source=new Eo(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}},Ui=class extends pf{constructor(e=1,t=1,i={}){super(e,t,i),this.isWebGLRenderTarget=!0}},Dc=class extends mn{constructor(e=null,t=1,i=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=xn,this.minFilter=xn,this.wrapR=mi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}};class M1 extends Ui{constructor(e=1,t=1,i=1,r={}){super(e,t,r),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new Dc(null,e,t,i),this.texture.isRenderTargetTexture=!0}}let mf=class extends mn{constructor(e=null,t=1,i=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=xn,this.minFilter=xn,this.wrapR=mi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}};class S1 extends Ui{constructor(e=1,t=1,i=1,r={}){super(e,t,r),this.isWebGL3DRenderTarget=!0,this.depth=i,this.texture=new mf(null,e,t,i),this.texture.isRenderTargetTexture=!0}}let Yn=class{constructor(e=0,t=0,i=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=r}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],c=i[r+1],h=i[r+2],u=i[r+3];const d=s[o+0],f=s[o+1],A=s[o+2],g=s[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=u;return}if(a===1){e[t+0]=d,e[t+1]=f,e[t+2]=A,e[t+3]=g;return}if(u!==g||l!==d||c!==f||h!==A){let m=1-a;const p=l*d+c*f+h*A+u*g,v=p>=0?1:-1,E=1-p*p;if(E>Number.EPSILON){const M=Math.sqrt(E),w=Math.atan2(M,p*v);m=Math.sin(m*w)/M,a=Math.sin(a*w)/M}const x=a*v;if(l=l*m+d*x,c=c*m+f*x,h=h*m+A*x,u=u*m+g*x,m===1-a){const M=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=M,c*=M,h*=M,u*=M}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=u}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],h=i[r+3],u=s[o],d=s[o+1],f=s[o+2],A=s[o+3];return e[t]=a*A+h*u+l*f-c*d,e[t+1]=l*A+h*d+c*u-a*f,e[t+2]=c*A+h*f+a*d-l*u,e[t+3]=h*A-a*u-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),h=a(r/2),u=a(s/2),d=l(i/2),f=l(r/2),A=l(s/2);switch(o){case"XYZ":this._x=d*h*u+c*f*A,this._y=c*f*u-d*h*A,this._z=c*h*A+d*f*u,this._w=c*h*u-d*f*A;break;case"YXZ":this._x=d*h*u+c*f*A,this._y=c*f*u-d*h*A,this._z=c*h*A-d*f*u,this._w=c*h*u+d*f*A;break;case"ZXY":this._x=d*h*u-c*f*A,this._y=c*f*u+d*h*A,this._z=c*h*A+d*f*u,this._w=c*h*u-d*f*A;break;case"ZYX":this._x=d*h*u-c*f*A,this._y=c*f*u+d*h*A,this._z=c*h*A-d*f*u,this._w=c*h*u+d*f*A;break;case"YZX":this._x=d*h*u+c*f*A,this._y=c*f*u+d*h*A,this._z=c*h*A-d*f*u,this._w=c*h*u-d*f*A;break;case"XZY":this._x=d*h*u-c*f*A,this._y=c*f*u-d*h*A,this._z=c*h*A+d*f*u,this._w=c*h*u+d*f*A;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],h=t[6],u=t[10],d=i+a+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(o-r)*f}else if(i>a&&i>u){const f=2*Math.sqrt(1+i-a-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+o)/f,this._z=(s+c)/f}else if(a>u){const f=2*Math.sqrt(1+a-i-u);this._w=(s-c)/f,this._x=(r+o)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-i-a);this._w=(o-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(pt(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,h=t._w;return this._x=i*h+o*a+r*c-s*l,this._y=r*h+o*l+s*a-i*c,this._z=s*h+o*c+i*l-r*a,this._w=o*h-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-t;return this._w=f*o+t*this._w,this._x=f*i+t*this._x,this._y=f*r+t*this._y,this._z=f*s+t*this._z,this.normalize(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),u=Math.sin((1-t)*h)/c,d=Math.sin(t*h)/c;return this._w=o*u+this._w*d,this._x=i*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),i=Math.random(),r=Math.sqrt(1-i),s=Math.sqrt(i);return this.set(r*Math.sin(e),r*Math.cos(e),s*Math.sin(t),s*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}},Y=class nC{constructor(e=0,t=0,i=0){nC.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Iv.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Iv.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=2*(o*r-a*i),h=2*(a*t-s*r),u=2*(s*i-o*t);return this.x=t+l*c+o*u-a*h,this.y=i+l*h+a*c-s*u,this.z=r+l*u+s*h-o*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=pt(this.x,e.x,t.x),this.y=pt(this.y,e.y,t.y),this.z=pt(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=pt(this.x,e,t),this.y=pt(this.y,e,t),this.z=pt(this.z,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(pt(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return ip.copy(this).projectOnVector(e),this.sub(ip)}reflect(e){return this.sub(ip.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(pt(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,i=Math.sqrt(1-t*t);return this.x=i*Math.cos(e),this.y=t,this.z=i*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}};const ip=new Y,Iv=new Yn;let Gn=class{constructor(e=new Y(1/0,1/0,1/0),t=new Y(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t+=3)this.expandByPoint(Ei.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,i=e.count;t<i;t++)this.expandByPoint(Ei.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=Ei.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0){const s=i.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=s.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Ei):Ei.fromBufferAttribute(s,o),Ei.applyMatrix4(e.matrixWorld),this.expandByPoint(Ei);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),$c.copy(e.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),$c.copy(i.boundingBox)),$c.applyMatrix4(e.matrixWorld),this.union($c)}const r=e.children;for(let s=0,o=r.length;s<o;s++)this.expandByObject(r[s],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Ei),Ei.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ul),Kc.subVectors(this.max,ul),Qo.subVectors(e.a,ul),Wo.subVectors(e.b,ul),Xo.subVectors(e.c,ul),Wr.subVectors(Wo,Qo),Xr.subVectors(Xo,Wo),Ps.subVectors(Qo,Xo);let t=[0,-Wr.z,Wr.y,0,-Xr.z,Xr.y,0,-Ps.z,Ps.y,Wr.z,0,-Wr.x,Xr.z,0,-Xr.x,Ps.z,0,-Ps.x,-Wr.y,Wr.x,0,-Xr.y,Xr.x,0,-Ps.y,Ps.x,0];return!rp(t,Qo,Wo,Xo,Kc)||(t=[1,0,0,0,1,0,0,0,1],!rp(t,Qo,Wo,Xo,Kc))?!1:(Jc.crossVectors(Wr,Xr),t=[Jc.x,Jc.y,Jc.z],rp(t,Qo,Wo,Xo,Kc))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ei).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ei).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(rr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),rr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),rr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),rr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),rr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),rr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),rr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),rr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(rr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}};const rr=[new Y,new Y,new Y,new Y,new Y,new Y,new Y,new Y],Ei=new Y,$c=new Gn,Qo=new Y,Wo=new Y,Xo=new Y,Wr=new Y,Xr=new Y,Ps=new Y,ul=new Y,Kc=new Y,Jc=new Y,Us=new Y;function rp(n,e,t,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){Us.fromArray(n,s);const a=r.x*Math.abs(Us.x)+r.y*Math.abs(Us.y)+r.z*Math.abs(Us.z),l=e.dot(Us),c=t.dot(Us),h=i.dot(Us);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const w1=new Gn,dl=new Y,sp=new Y;let wn=class{constructor(e=new Y,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):w1.setFromPoints(e).getCenter(i);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,i.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;dl.subVectors(e,this.center);const t=dl.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),r=(i-this.radius)*.5;this.center.addScaledVector(dl,r/i),this.radius+=r}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(sp.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(dl.copy(e.center).add(sp)),this.expandByPoint(dl.copy(e.center).sub(sp))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}};const sr=new Y,op=new Y,Zc=new Y,qr=new Y,ap=new Y,eh=new Y,lp=new Y;let rl=class{constructor(e=new Y,t=new Y(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,sr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=sr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(sr.copy(this.origin).addScaledVector(this.direction,t),sr.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){op.copy(e).add(t).multiplyScalar(.5),Zc.copy(t).sub(e).normalize(),qr.copy(this.origin).sub(op);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Zc),a=qr.dot(this.direction),l=-qr.dot(Zc),c=qr.lengthSq(),h=Math.abs(1-o*o);let u,d,f,A;if(h>0)if(u=o*l-a,d=o*a-l,A=s*h,u>=0)if(d>=-A)if(d<=A){const g=1/h;u*=g,d*=g,f=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d<=-A?(u=Math.max(0,-(-o*s+a)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=A?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(o*s+a)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=o>0?-s:s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;return i&&i.copy(this.origin).addScaledVector(this.direction,u),r&&r.copy(op).addScaledVector(Zc,d),f}intersectSphere(e,t){sr.subVectors(e.center,this.origin);const i=sr.dot(this.direction),r=sr.dot(sr)-i*i,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,s,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(i=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(i=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),h>=0?(s=(e.min.y-d.y)*h,o=(e.max.y-d.y)*h):(s=(e.max.y-d.y)*h,o=(e.min.y-d.y)*h),i>o||s>r||((s>i||isNaN(i))&&(i=s),(o<r||isNaN(r))&&(r=o),u>=0?(a=(e.min.z-d.z)*u,l=(e.max.z-d.z)*u):(a=(e.max.z-d.z)*u,l=(e.min.z-d.z)*u),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,t)}intersectsBox(e){return this.intersectBox(e,sr)!==null}intersectTriangle(e,t,i,r,s){ap.subVectors(t,e),eh.subVectors(i,e),lp.crossVectors(ap,eh);let o=this.direction.dot(lp),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;qr.subVectors(this.origin,e);const l=a*this.direction.dot(eh.crossVectors(qr,eh));if(l<0)return null;const c=a*this.direction.dot(ap.cross(qr));if(c<0||l+c>o)return null;const h=-a*qr.dot(lp);return h<0?null:this.at(h/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}},ct=class EA{constructor(e,t,i,r,s,o,a,l,c,h,u,d,f,A,g,m){EA.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,i,r,s,o,a,l,c,h,u,d,f,A,g,m)}set(e,t,i,r,s,o,a,l,c,h,u,d,f,A,g,m){const p=this.elements;return p[0]=e,p[4]=t,p[8]=i,p[12]=r,p[1]=s,p[5]=o,p[9]=a,p[13]=l,p[2]=c,p[6]=h,p[10]=u,p[14]=d,p[3]=f,p[7]=A,p[11]=g,p[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new EA().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/qo.setFromMatrixColumn(e,0).length(),s=1/qo.setFromMatrixColumn(e,1).length(),o=1/qo.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),h=Math.cos(s),u=Math.sin(s);if(e.order==="XYZ"){const d=o*h,f=o*u,A=a*h,g=a*u;t[0]=l*h,t[4]=-l*u,t[8]=c,t[1]=f+A*c,t[5]=d-g*c,t[9]=-a*l,t[2]=g-d*c,t[6]=A+f*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*h,f=l*u,A=c*h,g=c*u;t[0]=d+g*a,t[4]=A*a-f,t[8]=o*c,t[1]=o*u,t[5]=o*h,t[9]=-a,t[2]=f*a-A,t[6]=g+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*h,f=l*u,A=c*h,g=c*u;t[0]=d-g*a,t[4]=-o*u,t[8]=A+f*a,t[1]=f+A*a,t[5]=o*h,t[9]=g-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*h,f=o*u,A=a*h,g=a*u;t[0]=l*h,t[4]=A*c-f,t[8]=d*c+g,t[1]=l*u,t[5]=g*c+d,t[9]=f*c-A,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,f=o*c,A=a*l,g=a*c;t[0]=l*h,t[4]=g-d*u,t[8]=A*u+f,t[1]=u,t[5]=o*h,t[9]=-a*h,t[2]=-c*h,t[6]=f*u+A,t[10]=d-g*u}else if(e.order==="XZY"){const d=o*l,f=o*c,A=a*l,g=a*c;t[0]=l*h,t[4]=-u,t[8]=c*h,t[1]=d*u+g,t[5]=o*h,t[9]=f*u-A,t[2]=A*u-f,t[6]=a*h,t[10]=g*u+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(T1,e,I1)}lookAt(e,t,i){const r=this.elements;return Kn.subVectors(e,t),Kn.lengthSq()===0&&(Kn.z=1),Kn.normalize(),Yr.crossVectors(i,Kn),Yr.lengthSq()===0&&(Math.abs(i.z)===1?Kn.x+=1e-4:Kn.z+=1e-4,Kn.normalize(),Yr.crossVectors(i,Kn)),Yr.normalize(),th.crossVectors(Kn,Yr),r[0]=Yr.x,r[4]=th.x,r[8]=Kn.x,r[1]=Yr.y,r[5]=th.y,r[9]=Kn.y,r[2]=Yr.z,r[6]=th.z,r[10]=Kn.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],h=i[1],u=i[5],d=i[9],f=i[13],A=i[2],g=i[6],m=i[10],p=i[14],v=i[3],E=i[7],x=i[11],M=i[15],w=r[0],S=r[4],B=r[8],y=r[12],_=r[1],L=r[5],Q=r[9],O=r[13],X=r[2],te=r[6],W=r[10],Z=r[14],q=r[3],re=r[7],ue=r[11],_e=r[15];return s[0]=o*w+a*_+l*X+c*q,s[4]=o*S+a*L+l*te+c*re,s[8]=o*B+a*Q+l*W+c*ue,s[12]=o*y+a*O+l*Z+c*_e,s[1]=h*w+u*_+d*X+f*q,s[5]=h*S+u*L+d*te+f*re,s[9]=h*B+u*Q+d*W+f*ue,s[13]=h*y+u*O+d*Z+f*_e,s[2]=A*w+g*_+m*X+p*q,s[6]=A*S+g*L+m*te+p*re,s[10]=A*B+g*Q+m*W+p*ue,s[14]=A*y+g*O+m*Z+p*_e,s[3]=v*w+E*_+x*X+M*q,s[7]=v*S+E*L+x*te+M*re,s[11]=v*B+E*Q+x*W+M*ue,s[15]=v*y+E*O+x*Z+M*_e,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],h=e[2],u=e[6],d=e[10],f=e[14],A=e[3],g=e[7],m=e[11],p=e[15];return A*(+s*l*u-r*c*u-s*a*d+i*c*d+r*a*f-i*l*f)+g*(+t*l*f-t*c*d+s*o*d-r*o*f+r*c*h-s*l*h)+m*(+t*c*u-t*a*f-s*o*u+i*o*f+s*a*h-i*c*h)+p*(-r*a*h-t*l*u+t*a*d+r*o*u-i*o*d+i*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=e[9],d=e[10],f=e[11],A=e[12],g=e[13],m=e[14],p=e[15],v=u*m*c-g*d*c+g*l*f-a*m*f-u*l*p+a*d*p,E=A*d*c-h*m*c-A*l*f+o*m*f+h*l*p-o*d*p,x=h*g*c-A*u*c+A*a*f-o*g*f-h*a*p+o*u*p,M=A*u*l-h*g*l-A*a*d+o*g*d+h*a*m-o*u*m,w=t*v+i*E+r*x+s*M;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/w;return e[0]=v*S,e[1]=(g*d*s-u*m*s-g*r*f+i*m*f+u*r*p-i*d*p)*S,e[2]=(a*m*s-g*l*s+g*r*c-i*m*c-a*r*p+i*l*p)*S,e[3]=(u*l*s-a*d*s-u*r*c+i*d*c+a*r*f-i*l*f)*S,e[4]=E*S,e[5]=(h*m*s-A*d*s+A*r*f-t*m*f-h*r*p+t*d*p)*S,e[6]=(A*l*s-o*m*s-A*r*c+t*m*c+o*r*p-t*l*p)*S,e[7]=(o*d*s-h*l*s+h*r*c-t*d*c-o*r*f+t*l*f)*S,e[8]=x*S,e[9]=(A*u*s-h*g*s-A*i*f+t*g*f+h*i*p-t*u*p)*S,e[10]=(o*g*s-A*a*s+A*i*c-t*g*c-o*i*p+t*a*p)*S,e[11]=(h*a*s-o*u*s-h*i*c+t*u*c+o*i*f-t*a*f)*S,e[12]=M*S,e[13]=(h*g*r-A*u*r+A*i*d-t*g*d-h*i*m+t*u*m)*S,e[14]=(A*a*r-o*g*r-A*i*l+t*g*l+o*i*m-t*a*m)*S,e[15]=(o*u*r-h*a*r+h*i*l-t*u*l-o*i*d+t*a*d)*S,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,c=s*o,h=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,h*a+i,h*l-r*o,0,c*l-r*a,h*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,s,o){return this.set(1,i,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,h=o+o,u=a+a,d=s*c,f=s*h,A=s*u,g=o*h,m=o*u,p=a*u,v=l*c,E=l*h,x=l*u,M=i.x,w=i.y,S=i.z;return r[0]=(1-(g+p))*M,r[1]=(f+x)*M,r[2]=(A-E)*M,r[3]=0,r[4]=(f-x)*w,r[5]=(1-(d+p))*w,r[6]=(m+v)*w,r[7]=0,r[8]=(A+E)*S,r[9]=(m-v)*S,r[10]=(1-(d+g))*S,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=qo.set(r[0],r[1],r[2]).length();const o=qo.set(r[4],r[5],r[6]).length(),a=qo.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],xi.copy(this);const c=1/s,h=1/o,u=1/a;return xi.elements[0]*=c,xi.elements[1]*=c,xi.elements[2]*=c,xi.elements[4]*=h,xi.elements[5]*=h,xi.elements[6]*=h,xi.elements[8]*=u,xi.elements[9]*=u,xi.elements[10]*=u,t.setFromRotationMatrix(xi),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o,a=Li){const l=this.elements,c=2*s/(t-e),h=2*s/(i-r),u=(t+e)/(t-e),d=(i+r)/(i-r);let f,A;if(a===Li)f=-(o+s)/(o-s),A=-2*o*s/(o-s);else if(a===uc)f=-o/(o-s),A=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=c,l[4]=0,l[8]=u,l[12]=0,l[1]=0,l[5]=h,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=f,l[14]=A,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,i,r,s,o,a=Li){const l=this.elements,c=1/(t-e),h=1/(i-r),u=1/(o-s),d=(t+e)*c,f=(i+r)*h;let A,g;if(a===Li)A=(o+s)*u,g=-2*u;else if(a===uc)A=s*u,g=-1*u;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-f,l[2]=0,l[6]=0,l[10]=g,l[14]=-A,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}};const qo=new Y,xi=new ct,T1=new Y(0,0,0),I1=new Y(1,1,1),Yr=new Y,th=new Y,Kn=new Y,Rv=new ct,Bv=new Yn;let Fi=class iC{constructor(e=0,t=0,i=0,r=iC.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],h=r[9],u=r[2],d=r[6],f=r[10];switch(t){case"XYZ":this._y=Math.asin(pt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-pt(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,s),this._z=0);break;case"ZXY":this._x=Math.asin(pt(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-pt(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(pt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-u,s)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-pt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return Rv.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Rv,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Bv.setFromEuler(this),this.setFromQuaternion(Bv,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}};Fi.DEFAULT_ORDER="XYZ";let Af=class{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}},R1=0;const Lv=new Y,Yo=new Yn,or=new ct,nh=new Y,fl=new Y,B1=new Y,L1=new Yn,Dv=new Y(1,0,0),Pv=new Y(0,1,0),Uv=new Y(0,0,1),Fv={type:"added"},D1={type:"removed"},jo={type:"childadded",child:null},cp={type:"childremoved",child:null};let Ft=class Nu extends tr{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:R1++}),this.uuid=ii(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Nu.DEFAULT_UP.clone();const e=new Y,t=new Fi,i=new Yn,r=new Y(1,1,1);function s(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new ct},normalMatrix:{value:new At}}),this.matrix=new ct,this.matrixWorld=new ct,this.matrixAutoUpdate=Nu.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Nu.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Af,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Yo.setFromAxisAngle(e,t),this.quaternion.multiply(Yo),this}rotateOnWorldAxis(e,t){return Yo.setFromAxisAngle(e,t),this.quaternion.premultiply(Yo),this}rotateX(e){return this.rotateOnAxis(Dv,e)}rotateY(e){return this.rotateOnAxis(Pv,e)}rotateZ(e){return this.rotateOnAxis(Uv,e)}translateOnAxis(e,t){return Lv.copy(e).applyQuaternion(this.quaternion),this.position.add(Lv.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Dv,e)}translateY(e){return this.translateOnAxis(Pv,e)}translateZ(e){return this.translateOnAxis(Uv,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(or.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?nh.copy(e):nh.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),fl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?or.lookAt(fl,nh,this.up):or.lookAt(nh,fl,this.up),this.quaternion.setFromRotationMatrix(or),r&&(or.extractRotation(r.matrixWorld),Yo.setFromRotationMatrix(or),this.quaternion.premultiply(Yo.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(Fv),jo.child=e,this.dispatchEvent(jo),jo.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(D1),cp.child=e,this.dispatchEvent(cp),cp.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),or.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),or.multiply(e.parent.matrixWorld)),e.applyMatrix4(or),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(Fv),jo.child=e,this.dispatchEvent(jo),jo.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,i=[]){this[e]===t&&i.push(this);const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].getObjectsByProperty(e,t,i);return i}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fl,e,B1),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fl,L1,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(r.type="BatchedMesh",r.perObjectFrustumCulled=this.perObjectFrustumCulled,r.sortObjects=this.sortObjects,r.drawRanges=this._drawRanges,r.reservedRanges=this._reservedRanges,r.visibility=this._visibility,r.active=this._active,r.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),r.maxInstanceCount=this._maxInstanceCount,r.maxVertexCount=this._maxVertexCount,r.maxIndexCount=this._maxIndexCount,r.geometryInitialized=this._geometryInitialized,r.geometryCount=this._geometryCount,r.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(r.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(r.boundingSphere={center:r.boundingSphere.center.toArray(),radius:r.boundingSphere.radius}),this.boundingBox!==null&&(r.boundingBox={min:r.boundingBox.min.toArray(),max:r.boundingBox.max.toArray()}));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const u=l[c];s(e.shapes,u)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),h=o(e.images),u=o(e.shapes),d=o(e.skeletons),f=o(e.animations),A=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),h.length>0&&(i.images=h),u.length>0&&(i.shapes=u),d.length>0&&(i.skeletons=d),f.length>0&&(i.animations=f),A.length>0&&(i.nodes=A)}return i.object=r,i;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const r=e.children[i];this.add(r.clone())}return this}};Ft.DEFAULT_UP=new Y(0,1,0);Ft.DEFAULT_MATRIX_AUTO_UPDATE=!0;Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const yi=new Y,ar=new Y,hp=new Y,lr=new Y,$o=new Y,Ko=new Y,Nv=new Y,up=new Y,dp=new Y,fp=new Y,pp=new Dt,mp=new Dt,Ap=new Dt;let fs=class Ia{constructor(e=new Y,t=new Y,i=new Y){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),yi.subVectors(e,t),r.cross(yi);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){yi.subVectors(r,t),ar.subVectors(i,t),hp.subVectors(e,t);const o=yi.dot(yi),a=yi.dot(ar),l=yi.dot(hp),c=ar.dot(ar),h=ar.dot(hp),u=o*c-a*a;if(u===0)return s.set(0,0,0),null;const d=1/u,f=(c*l-a*h)*d,A=(o*h-a*l)*d;return s.set(1-f-A,A,f)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,lr)===null?!1:lr.x>=0&&lr.y>=0&&lr.x+lr.y<=1}static getInterpolation(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,lr)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(s,lr.x),l.addScaledVector(o,lr.y),l.addScaledVector(a,lr.z),l)}static getInterpolatedAttribute(e,t,i,r,s,o){return pp.setScalar(0),mp.setScalar(0),Ap.setScalar(0),pp.fromBufferAttribute(e,t),mp.fromBufferAttribute(e,i),Ap.fromBufferAttribute(e,r),o.setScalar(0),o.addScaledVector(pp,s.x),o.addScaledVector(mp,s.y),o.addScaledVector(Ap,s.z),o}static isFrontFacing(e,t,i,r){return yi.subVectors(i,t),ar.subVectors(e,t),yi.cross(ar).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return yi.subVectors(this.c,this.b),ar.subVectors(this.a,this.b),yi.cross(ar).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ia.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ia.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,i,r,s){return Ia.getInterpolation(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return Ia.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ia.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,s=this.c;let o,a;$o.subVectors(r,i),Ko.subVectors(s,i),up.subVectors(e,i);const l=$o.dot(up),c=Ko.dot(up);if(l<=0&&c<=0)return t.copy(i);dp.subVectors(e,r);const h=$o.dot(dp),u=Ko.dot(dp);if(h>=0&&u<=h)return t.copy(r);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),t.copy(i).addScaledVector($o,o);fp.subVectors(e,s);const f=$o.dot(fp),A=Ko.dot(fp);if(A>=0&&f<=A)return t.copy(s);const g=f*c-l*A;if(g<=0&&c>=0&&A<=0)return a=c/(c-A),t.copy(i).addScaledVector(Ko,a);const m=h*A-f*u;if(m<=0&&u-h>=0&&f-A>=0)return Nv.subVectors(s,r),a=(u-h)/(u-h+(f-A)),t.copy(r).addScaledVector(Nv,a);const p=1/(m+g+d);return o=g*p,a=d*p,t.copy(i).addScaledVector($o,o).addScaledVector(Ko,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}};const rC={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},jr={h:0,s:0,l:0},ih={h:0,s:0,l:0};function gp(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}let Ke=class{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,i)}set(e,t,i){if(t===void 0&&i===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,i);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Xn){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,wt.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=wt.workingColorSpace){return this.r=e,this.g=t,this.b=i,wt.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=wt.workingColorSpace){if(e=o0(e,1),t=pt(t,0,1),i=pt(i,0,1),t===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+t):i+t-i*t,o=2*i-s;this.r=gp(o,s,e+1/3),this.g=gp(o,s,e),this.b=gp(o,s,e-1/3)}return wt.toWorkingColorSpace(this,r),this}setStyle(e,t=Xn){function i(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Xn){const i=rC[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Pr(e.r),this.g=Pr(e.g),this.b=Pr(e.b),this}copyLinearToSRGB(e){return this.r=Ha(e.r),this.g=Ha(e.g),this.b=Ha(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Xn){return wt.fromWorkingColorSpace(_n.copy(this),e),Math.round(pt(_n.r*255,0,255))*65536+Math.round(pt(_n.g*255,0,255))*256+Math.round(pt(_n.b*255,0,255))}getHexString(e=Xn){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=wt.workingColorSpace){wt.fromWorkingColorSpace(_n.copy(this),t);const i=_n.r,r=_n.g,s=_n.b,o=Math.max(i,r,s),a=Math.min(i,r,s);let l,c;const h=(a+o)/2;if(a===o)l=0,c=0;else{const u=o-a;switch(c=h<=.5?u/(o+a):u/(2-o-a),o){case i:l=(r-s)/u+(r<s?6:0);break;case r:l=(s-i)/u+2;break;case s:l=(i-r)/u+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=wt.workingColorSpace){return wt.fromWorkingColorSpace(_n.copy(this),t),e.r=_n.r,e.g=_n.g,e.b=_n.b,e}getStyle(e=Xn){wt.fromWorkingColorSpace(_n.copy(this),e);const t=_n.r,i=_n.g,r=_n.b;return e!==Xn?`color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(r*255)})`}offsetHSL(e,t,i){return this.getHSL(jr),this.setHSL(jr.h+e,jr.s+t,jr.l+i)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(jr),e.getHSL(ih);const i=$l(jr.h,ih.h,t),r=$l(jr.s,ih.s,t),s=$l(jr.l,ih.l,t);return this.setHSL(i,r,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,i=this.g,r=this.b,s=e.elements;return this.r=s[0]*t+s[3]*i+s[6]*r,this.g=s[1]*t+s[4]*i+s[7]*r,this.b=s[2]*t+s[5]*i+s[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};const _n=new Ke;Ke.NAMES=rC;let P1=0,Tn=class extends tr{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:P1++}),this.uuid=ii(),this.name="",this.type="Material",this.blending=bo,this.side=Or,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=ed,this.blendDst=td,this.blendEquation=ds,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Ke(0,0,0),this.blendAlpha=0,this.depthFunc=To,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=gA,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=lo,this.stencilZFail=lo,this.stencilZPass=lo,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==bo&&(i.blending=this.blending),this.side!==Or&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==ed&&(i.blendSrc=this.blendSrc),this.blendDst!==td&&(i.blendDst=this.blendDst),this.blendEquation!==ds&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==To&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==gA&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==lo&&(i.stencilFail=this.stencilFail),this.stencilZFail!==lo&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==lo&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function r(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(i.textures=s),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const r=t.length;i=new Array(r);for(let s=0;s!==r;++s)i[s]=t[s].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}},Rs=class extends Tn{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ke(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Fi,this.combine=Bc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}};const yr=U1();function U1(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),i=new Uint32Array(512),r=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(i[l]=0,i[l|256]=32768,r[l]=24,r[l|256]=24):c<-14?(i[l]=1024>>-c-14,i[l|256]=1024>>-c-14|32768,r[l]=-c-1,r[l|256]=-c-1):c<=15?(i[l]=c+15<<10,i[l|256]=c+15<<10|32768,r[l]=13,r[l|256]=13):c<128?(i[l]=31744,i[l|256]=64512,r[l]=24,r[l|256]=24):(i[l]=31744,i[l|256]=64512,r[l]=13,r[l|256]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;!(c&8388608);)c<<=1,h-=8388608;c&=-8388609,h+=947912704,s[l]=c|h}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:i,shiftTable:r,mantissaTable:s,exponentTable:o,offsetTable:a}}function Qn(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=pt(n,-65504,65504),yr.floatView[0]=n;const e=yr.uint32View[0],t=e>>23&511;return yr.baseTable[t]+((e&8388607)>>yr.shiftTable[t])}function kl(n){const e=n>>10;return yr.uint32View[0]=yr.mantissaTable[yr.offsetTable[e]+(n&1023)]+yr.exponentTable[e],yr.floatView[0]}const F1={toHalfFloat:Qn,fromHalfFloat:kl},Jt=new Y,rh=new Ne;let N1=0,Gt=class{constructor(e,t,i=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:N1++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i,this.usage=hc,this.updateRanges=[],this.gpuType=Un,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[i+r];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)rh.fromBufferAttribute(this,t),rh.applyMatrix3(e),this.setXY(t,rh.x,rh.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Jt.fromBufferAttribute(this,t),Jt.applyMatrix3(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Jt.fromBufferAttribute(this,t),Jt.applyMatrix4(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Jt.fromBufferAttribute(this,t),Jt.applyNormalMatrix(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Jt.fromBufferAttribute(this,t),Jt.transformDirection(e),this.setXYZ(t,Jt.x,Jt.y,Jt.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let i=this.array[e*this.itemSize+t];return this.normalized&&(i=Fn(i,this.array)),i}setComponent(e,t,i){return this.normalized&&(i=gt(i,this.array)),this.array[e*this.itemSize+t]=i,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Fn(t,this.array)),t}setX(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Fn(t,this.array)),t}setY(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Fn(t,this.array)),t}setZ(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Fn(t,this.array)),t}setW(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array)),this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,r){return e*=this.itemSize,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array),r=gt(r,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array),r=gt(r,this.array),s=gt(s,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==hc&&(e.usage=this.usage),e}};class O1 extends Gt{constructor(e,t,i){super(new Int8Array(e),t,i)}}class k1 extends Gt{constructor(e,t,i){super(new Uint8Array(e),t,i)}}class G1 extends Gt{constructor(e,t,i){super(new Uint8ClampedArray(e),t,i)}}class z1 extends Gt{constructor(e,t,i){super(new Int16Array(e),t,i)}}let a0=class extends Gt{constructor(e,t,i){super(new Uint16Array(e),t,i)}};class H1 extends Gt{constructor(e,t,i){super(new Int32Array(e),t,i)}}let l0=class extends Gt{constructor(e,t,i){super(new Uint32Array(e),t,i)}};class V1 extends Gt{constructor(e,t,i){super(new Uint16Array(e),t,i),this.isFloat16BufferAttribute=!0}getX(e){let t=kl(this.array[e*this.itemSize]);return this.normalized&&(t=Fn(t,this.array)),t}setX(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize]=Qn(t),this}getY(e){let t=kl(this.array[e*this.itemSize+1]);return this.normalized&&(t=Fn(t,this.array)),t}setY(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize+1]=Qn(t),this}getZ(e){let t=kl(this.array[e*this.itemSize+2]);return this.normalized&&(t=Fn(t,this.array)),t}setZ(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize+2]=Qn(t),this}getW(e){let t=kl(this.array[e*this.itemSize+3]);return this.normalized&&(t=Fn(t,this.array)),t}setW(e,t){return this.normalized&&(t=gt(t,this.array)),this.array[e*this.itemSize+3]=Qn(t),this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array)),this.array[e+0]=Qn(t),this.array[e+1]=Qn(i),this}setXYZ(e,t,i,r){return e*=this.itemSize,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array),r=gt(r,this.array)),this.array[e+0]=Qn(t),this.array[e+1]=Qn(i),this.array[e+2]=Qn(r),this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array),r=gt(r,this.array),s=gt(s,this.array)),this.array[e+0]=Qn(t),this.array[e+1]=Qn(i),this.array[e+2]=Qn(r),this.array[e+3]=Qn(s),this}}let et=class extends Gt{constructor(e,t,i){super(new Float32Array(e),t,i)}},Q1=0;const li=new ct,vp=new Ft,Jo=new Y,Jn=new Gn,pl=new Gn,fn=new Y;let yt=class sC extends tr{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Q1++}),this.uuid=ii(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Jb(e)?l0:a0)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const s=new At().getNormalMatrix(e);i.applyNormalMatrix(s),i.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return li.makeRotationFromQuaternion(e),this.applyMatrix4(li),this}rotateX(e){return li.makeRotationX(e),this.applyMatrix4(li),this}rotateY(e){return li.makeRotationY(e),this.applyMatrix4(li),this}rotateZ(e){return li.makeRotationZ(e),this.applyMatrix4(li),this}translate(e,t,i){return li.makeTranslation(e,t,i),this.applyMatrix4(li),this}scale(e,t,i){return li.makeScale(e,t,i),this.applyMatrix4(li),this}lookAt(e){return vp.lookAt(e),vp.updateMatrix(),this.applyMatrix4(vp.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Jo).negate(),this.translate(Jo.x,Jo.y,Jo.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const i=[];for(let r=0,s=e.length;r<s;r++){const o=e[r];i.push(o.x,o.y,o.z||0)}this.setAttribute("position",new et(i,3))}else{const i=Math.min(e.length,t.count);for(let r=0;r<i;r++){const s=e[r];t.setXYZ(r,s.x,s.y,s.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Gn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Y(-1/0,-1/0,-1/0),new Y(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,r=t.length;i<r;i++){const s=t[i];Jn.setFromBufferAttribute(s),this.morphTargetsRelative?(fn.addVectors(this.boundingBox.min,Jn.min),this.boundingBox.expandByPoint(fn),fn.addVectors(this.boundingBox.max,Jn.max),this.boundingBox.expandByPoint(fn)):(this.boundingBox.expandByPoint(Jn.min),this.boundingBox.expandByPoint(Jn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new wn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Y,1/0);return}if(e){const i=this.boundingSphere.center;if(Jn.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];pl.setFromBufferAttribute(a),this.morphTargetsRelative?(fn.addVectors(Jn.min,pl.min),Jn.expandByPoint(fn),fn.addVectors(Jn.max,pl.max),Jn.expandByPoint(fn)):(Jn.expandByPoint(pl.min),Jn.expandByPoint(pl.max))}Jn.getCenter(i);let r=0;for(let s=0,o=e.count;s<o;s++)fn.fromBufferAttribute(e,s),r=Math.max(r,i.distanceToSquared(fn));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)fn.fromBufferAttribute(a,c),l&&(Jo.fromBufferAttribute(e,c),fn.add(Jo)),r=Math.max(r,i.distanceToSquared(fn))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=t.position,r=t.normal,s=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Gt(new Float32Array(4*i.count),4));const o=this.getAttribute("tangent"),a=[],l=[];for(let B=0;B<i.count;B++)a[B]=new Y,l[B]=new Y;const c=new Y,h=new Y,u=new Y,d=new Ne,f=new Ne,A=new Ne,g=new Y,m=new Y;function p(B,y,_){c.fromBufferAttribute(i,B),h.fromBufferAttribute(i,y),u.fromBufferAttribute(i,_),d.fromBufferAttribute(s,B),f.fromBufferAttribute(s,y),A.fromBufferAttribute(s,_),h.sub(c),u.sub(c),f.sub(d),A.sub(d);const L=1/(f.x*A.y-A.x*f.y);isFinite(L)&&(g.copy(h).multiplyScalar(A.y).addScaledVector(u,-f.y).multiplyScalar(L),m.copy(u).multiplyScalar(f.x).addScaledVector(h,-A.x).multiplyScalar(L),a[B].add(g),a[y].add(g),a[_].add(g),l[B].add(m),l[y].add(m),l[_].add(m))}let v=this.groups;v.length===0&&(v=[{start:0,count:e.count}]);for(let B=0,y=v.length;B<y;++B){const _=v[B],L=_.start,Q=_.count;for(let O=L,X=L+Q;O<X;O+=3)p(e.getX(O+0),e.getX(O+1),e.getX(O+2))}const E=new Y,x=new Y,M=new Y,w=new Y;function S(B){M.fromBufferAttribute(r,B),w.copy(M);const y=a[B];E.copy(y),E.sub(M.multiplyScalar(M.dot(y))).normalize(),x.crossVectors(w,y);const L=x.dot(l[B])<0?-1:1;o.setXYZW(B,E.x,E.y,E.z,L)}for(let B=0,y=v.length;B<y;++B){const _=v[B],L=_.start,Q=_.count;for(let O=L,X=L+Q;O<X;O+=3)S(e.getX(O+0)),S(e.getX(O+1)),S(e.getX(O+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new Gt(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let d=0,f=i.count;d<f;d++)i.setXYZ(d,0,0,0);const r=new Y,s=new Y,o=new Y,a=new Y,l=new Y,c=new Y,h=new Y,u=new Y;if(e)for(let d=0,f=e.count;d<f;d+=3){const A=e.getX(d+0),g=e.getX(d+1),m=e.getX(d+2);r.fromBufferAttribute(t,A),s.fromBufferAttribute(t,g),o.fromBufferAttribute(t,m),h.subVectors(o,s),u.subVectors(r,s),h.cross(u),a.fromBufferAttribute(i,A),l.fromBufferAttribute(i,g),c.fromBufferAttribute(i,m),a.add(h),l.add(h),c.add(h),i.setXYZ(A,a.x,a.y,a.z),i.setXYZ(g,l.x,l.y,l.z),i.setXYZ(m,c.x,c.y,c.z)}else for(let d=0,f=t.count;d<f;d+=3)r.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),h.subVectors(o,s),u.subVectors(r,s),h.cross(u),i.setXYZ(d+0,h.x,h.y,h.z),i.setXYZ(d+1,h.x,h.y,h.z),i.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)fn.fromBufferAttribute(e,t),fn.normalize(),e.setXYZ(t,fn.x,fn.y,fn.z)}toNonIndexed(){function e(a,l){const c=a.array,h=a.itemSize,u=a.normalized,d=new c.constructor(l.length*h);let f=0,A=0;for(let g=0,m=l.length;g<m;g++){a.isInterleavedBufferAttribute?f=l[g]*a.data.stride+a.offset:f=l[g]*h;for(let p=0;p<h;p++)d[A++]=c[f++]}return new Gt(d,h,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new sC,i=this.index.array,r=this.attributes;for(const a in r){const l=r[a],c=e(l,i);t.setAttribute(a,c)}const s=this.morphAttributes;for(const a in s){const l=[],c=s[a];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=e(d,i);l.push(f)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const l in i){const c=i[l];e.data.attributes[l]=c.toJSON(e.data)}const r={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u];h.push(f.toJSON(e.data))}h.length>0&&(r[l]=h,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const r=e.attributes;for(const c in r){const h=r[c];this.setAttribute(c,h.clone(t))}const s=e.morphAttributes;for(const c in s){const h=[],u=s[c];for(let d=0,f=u.length;d<f;d++)h.push(u[d].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,h=o.length;c<h;c++){const u=o[c];this.addGroup(u.start,u.count,u.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}};const Ov=new ct,Fs=new rl,sh=new wn,kv=new Y,oh=new Y,ah=new Y,lh=new Y,Ep=new Y,ch=new Y,Gv=new Y,hh=new Y;let en=class extends Ft{constructor(e=new yt,t=new Rs){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const i=this.geometry,r=i.attributes.position,s=i.morphAttributes.position,o=i.morphTargetsRelative;t.fromBufferAttribute(r,e);const a=this.morphTargetInfluences;if(s&&a){ch.set(0,0,0);for(let l=0,c=s.length;l<c;l++){const h=a[l],u=s[l];h!==0&&(Ep.fromBufferAttribute(u,e),o?ch.addScaledVector(Ep,h):ch.addScaledVector(Ep.sub(t),h))}t.add(ch)}return t}raycast(e,t){const i=this.geometry,r=this.material,s=this.matrixWorld;r!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),sh.copy(i.boundingSphere),sh.applyMatrix4(s),Fs.copy(e.ray).recast(e.near),!(sh.containsPoint(Fs.origin)===!1&&(Fs.intersectSphere(sh,kv)===null||Fs.origin.distanceToSquared(kv)>(e.far-e.near)**2))&&(Ov.copy(s).invert(),Fs.copy(e.ray).applyMatrix4(Ov),!(i.boundingBox!==null&&Fs.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(e,t,Fs)))}_computeIntersections(e,t,i){let r;const s=this.geometry,o=this.material,a=s.index,l=s.attributes.position,c=s.attributes.uv,h=s.attributes.uv1,u=s.attributes.normal,d=s.groups,f=s.drawRange;if(a!==null)if(Array.isArray(o))for(let A=0,g=d.length;A<g;A++){const m=d[A],p=o[m.materialIndex],v=Math.max(m.start,f.start),E=Math.min(a.count,Math.min(m.start+m.count,f.start+f.count));for(let x=v,M=E;x<M;x+=3){const w=a.getX(x),S=a.getX(x+1),B=a.getX(x+2);r=uh(this,p,e,i,c,h,u,w,S,B),r&&(r.faceIndex=Math.floor(x/3),r.face.materialIndex=m.materialIndex,t.push(r))}}else{const A=Math.max(0,f.start),g=Math.min(a.count,f.start+f.count);for(let m=A,p=g;m<p;m+=3){const v=a.getX(m),E=a.getX(m+1),x=a.getX(m+2);r=uh(this,o,e,i,c,h,u,v,E,x),r&&(r.faceIndex=Math.floor(m/3),t.push(r))}}else if(l!==void 0)if(Array.isArray(o))for(let A=0,g=d.length;A<g;A++){const m=d[A],p=o[m.materialIndex],v=Math.max(m.start,f.start),E=Math.min(l.count,Math.min(m.start+m.count,f.start+f.count));for(let x=v,M=E;x<M;x+=3){const w=x,S=x+1,B=x+2;r=uh(this,p,e,i,c,h,u,w,S,B),r&&(r.faceIndex=Math.floor(x/3),r.face.materialIndex=m.materialIndex,t.push(r))}}else{const A=Math.max(0,f.start),g=Math.min(l.count,f.start+f.count);for(let m=A,p=g;m<p;m+=3){const v=m,E=m+1,x=m+2;r=uh(this,o,e,i,c,h,u,v,E,x),r&&(r.faceIndex=Math.floor(m/3),t.push(r))}}}};function W1(n,e,t,i,r,s,o,a){let l;if(e.side===kn?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,e.side===Or,a),l===null)return null;hh.copy(a),hh.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(hh);return c<t.near||c>t.far?null:{distance:c,point:hh.clone(),object:n}}function uh(n,e,t,i,r,s,o,a,l,c){n.getVertexPosition(a,oh),n.getVertexPosition(l,ah),n.getVertexPosition(c,lh);const h=W1(n,e,t,i,oh,ah,lh,Gv);if(h){const u=new Y;fs.getBarycoord(Gv,oh,ah,lh,u),r&&(h.uv=fs.getInterpolatedAttribute(r,a,l,c,u,new Ne)),s&&(h.uv1=fs.getInterpolatedAttribute(s,a,l,c,u,new Ne)),o&&(h.normal=fs.getInterpolatedAttribute(o,a,l,c,u,new Y),h.normal.dot(i.direction)>0&&h.normal.multiplyScalar(-1));const d={a,b:l,c,normal:new Y,materialIndex:0};fs.getNormal(oh,ah,lh,d.normal),h.face=d,h.barycoord=u}return h}let Pc=class oC extends yt{constructor(e=1,t=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],h=[],u=[];let d=0,f=0;A("z","y","x",-1,-1,i,t,e,o,s,0),A("z","y","x",1,-1,i,t,-e,o,s,1),A("x","z","y",1,1,e,i,t,r,o,2),A("x","z","y",1,-1,e,i,-t,r,o,3),A("x","y","z",1,-1,e,t,i,r,s,4),A("x","y","z",-1,-1,e,t,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new et(c,3)),this.setAttribute("normal",new et(h,3)),this.setAttribute("uv",new et(u,2));function A(g,m,p,v,E,x,M,w,S,B,y){const _=x/S,L=M/B,Q=x/2,O=M/2,X=w/2,te=S+1,W=B+1;let Z=0,q=0;const re=new Y;for(let ue=0;ue<W;ue++){const _e=ue*L-O;for(let Be=0;Be<te;Be++){const ze=Be*_-Q;re[g]=ze*v,re[m]=_e*E,re[p]=X,c.push(re.x,re.y,re.z),re[g]=0,re[m]=0,re[p]=w>0?1:-1,h.push(re.x,re.y,re.z),u.push(Be/S),u.push(1-ue/B),Z+=1}}for(let ue=0;ue<B;ue++)for(let _e=0;_e<S;_e++){const Be=d+_e+te*ue,ze=d+_e+te*(ue+1),le=d+(_e+1)+te*(ue+1),Ee=d+(_e+1)+te*ue;l.push(Be,ze,Ee),l.push(ze,le,Ee),q+=6}a.addGroup(f,q,y),f+=q,d+=Z}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oC(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}};function Ya(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][i]=null):e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function Ln(n){const e={};for(let t=0;t<n.length;t++){const i=Ya(n[t]);for(const r in i)e[r]=i[r]}return e}function X1(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function aC(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:wt.workingColorSpace}const lC={clone:Ya,merge:Ln};var q1=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Y1=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;let Ni=class extends Tn{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=q1,this.fragmentShader=Y1,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Ya(e.uniforms),this.uniformsGroups=X1(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const i={};for(const r in this.extensions)this.extensions[r]===!0&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}},gf=class extends Ft{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ct,this.projectionMatrix=new ct,this.projectionMatrixInverse=new ct,this.coordinateSystem=Li}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}};const $r=new Y,zv=new Ne,Hv=new Ne;let gn=class extends gf{constructor(e=50,t=1,i=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=qa*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Co*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return qa*2*Math.atan(Math.tan(Co*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,i){$r.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set($r.x,$r.y).multiplyScalar(-e/$r.z),$r.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set($r.x,$r.y).multiplyScalar(-e/$r.z)}getViewSize(e,t){return this.getViewBounds(e,zv,Hv),t.subVectors(Hv,zv)}setViewOffset(e,t,i,r,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Co*.5*this.fov)/this.zoom,i=2*t,r=this.aspect*i,s=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;s+=o.offsetX*r/l,t-=o.offsetY*i/c,r*=o.width/l,i*=o.height/c}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-i,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}};const Zo=-90,ea=1;let cC=class extends Ft{constructor(e,t,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new gn(Zo,ea,e,t);r.layers=this.layers,this.add(r);const s=new gn(Zo,ea,e,t);s.layers=this.layers,this.add(s);const o=new gn(Zo,ea,e,t);o.layers=this.layers,this.add(o);const a=new gn(Zo,ea,e,t);a.layers=this.layers,this.add(a);const l=new gn(Zo,ea,e,t);l.layers=this.layers,this.add(l);const c=new gn(Zo,ea,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[i,r,s,o,a,l]=t;for(const c of t)this.remove(c);if(e===Li)i.up.set(0,1,0),i.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===uc)i.up.set(0,-1,0),i.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:r}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,o,a,l,c,h]=this.children,u=e.getRenderTarget(),d=e.getActiveCubeFace(),f=e.getActiveMipmapLevel(),A=e.xr.enabled;e.xr.enabled=!1;const g=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0,r),e.render(t,s),e.setRenderTarget(i,1,r),e.render(t,o),e.setRenderTarget(i,2,r),e.render(t,a),e.setRenderTarget(i,3,r),e.render(t,l),e.setRenderTarget(i,4,r),e.render(t,c),i.texture.generateMipmaps=g,e.setRenderTarget(i,5,r),e.render(t,h),e.setRenderTarget(u,d,f),e.xr.enabled=A,i.texture.needsPMREMUpdate=!0}},Uc=class extends mn{constructor(e,t,i,r,s,o,a,l,c,h){e=e!==void 0?e:[],t=t!==void 0?t:kr,super(e,t,i,r,s,o,a,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}},hC=class extends Ui{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const i={width:e,height:e,depth:1},r=[i,i,i,i,i,i];this.texture=new Uc(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:ln}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Pc(5,5,5),s=new Ni({name:"CubemapFromEquirect",uniforms:Ya(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:kn,blending:Lr});s.uniforms.tEquirect.value=t;const o=new en(r,s),a=t.minFilter;return t.minFilter===Yi&&(t.minFilter=ln),new cC(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,i,r){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,r);e.setRenderTarget(s)}},Pa=class extends Ft{constructor(){super(),this.isGroup=!0,this.type="Group"}};const j1={type:"move"};let Ou=class{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Pa,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Pa,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Y,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Y),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Pa,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Y,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Y),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const i of e.hand.values())this._getHandJoint(t,i)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let r=null,s=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const g of e.hand.values()){const m=t.getJointPose(g,i),p=this._getHandJoint(c,g);m!==null&&(p.matrix.fromArray(m.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale),p.matrixWorldNeedsUpdate=!0,p.jointRadius=m.radius),p.visible=m!==null}const h=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],d=h.position.distanceTo(u.position),f=.02,A=.005;c.inputState.pinching&&d>f+A?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=f-A&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,i),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(r=t.getPose(e.targetRaySpace,i),r===null&&s!==null&&(r=s),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(j1)))}return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const i=new Pa;i.matrixAutoUpdate=!1,i.visible=!1,e.joints[t.jointName]=i,e.add(i)}return e.joints[t.jointName]}};class vf{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new Ke(e),this.density=t}clone(){return new vf(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Ef{constructor(e,t=1,i=1e3){this.isFog=!0,this.name="",this.color=new Ke(e),this.near=t,this.far=i}clone(){return new Ef(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}let uC=class extends Ft{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Fi,this.environmentIntensity=1,this.environmentRotation=new Fi,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}};class xf{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=hc,this.updateRanges=[],this.version=0,this.uuid=ii()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let r=0,s=this.stride;r<s;r++)this.array[e+r]=t.array[i+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ii()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ii()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const In=new Y;class Ro{constructor(e,t,i,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)In.fromBufferAttribute(this,t),In.applyMatrix4(e),this.setXYZ(t,In.x,In.y,In.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)In.fromBufferAttribute(this,t),In.applyNormalMatrix(e),this.setXYZ(t,In.x,In.y,In.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)In.fromBufferAttribute(this,t),In.transformDirection(e),this.setXYZ(t,In.x,In.y,In.z);return this}getComponent(e,t){let i=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(i=Fn(i,this.array)),i}setComponent(e,t,i){return this.normalized&&(i=gt(i,this.array)),this.data.array[e*this.data.stride+this.offset+t]=i,this}setX(e,t){return this.normalized&&(t=gt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=gt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=gt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=gt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Fn(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Fn(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Fn(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Fn(t,this.array)),t}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array),r=gt(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=gt(t,this.array),i=gt(i,this.array),r=gt(r,this.array),s=gt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const r=i*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return new Gt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Ro(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const r=i*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class c0 extends Tn{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Ke(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let ta;const ml=new Y,na=new Y,ia=new Y,ra=new Ne,Al=new Ne,dC=new ct,dh=new Y,gl=new Y,fh=new Y,Vv=new Ne,xp=new Ne,Qv=new Ne;class fC extends Ft{constructor(e=new c0){if(super(),this.isSprite=!0,this.type="Sprite",ta===void 0){ta=new yt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new xf(t,5);ta.setIndex([0,1,2,0,2,3]),ta.setAttribute("position",new Ro(i,3,0,!1)),ta.setAttribute("uv",new Ro(i,2,3,!1))}this.geometry=ta,this.material=e,this.center=new Ne(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),na.setFromMatrixScale(this.matrixWorld),dC.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),ia.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&na.multiplyScalar(-ia.z);const i=this.material.rotation;let r,s;i!==0&&(s=Math.cos(i),r=Math.sin(i));const o=this.center;ph(dh.set(-.5,-.5,0),ia,o,na,r,s),ph(gl.set(.5,-.5,0),ia,o,na,r,s),ph(fh.set(.5,.5,0),ia,o,na,r,s),Vv.set(0,0),xp.set(1,0),Qv.set(1,1);let a=e.ray.intersectTriangle(dh,gl,fh,!1,ml);if(a===null&&(ph(gl.set(-.5,.5,0),ia,o,na,r,s),xp.set(0,1),a=e.ray.intersectTriangle(dh,fh,gl,!1,ml),a===null))return;const l=e.ray.origin.distanceTo(ml);l<e.near||l>e.far||t.push({distance:l,point:ml.clone(),uv:fs.getInterpolation(ml,dh,gl,fh,Vv,xp,Qv,new Ne),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function ph(n,e,t,i,r,s){ra.subVectors(n,t).addScalar(.5).multiply(i),r!==void 0?(Al.x=s*ra.x-r*ra.y,Al.y=r*ra.x+s*ra.y):Al.copy(ra),n.copy(e),n.x+=Al.x,n.y+=Al.y,n.applyMatrix4(dC)}const mh=new Y,Wv=new Y;class pC extends Ft{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let i=0,r=t.length;i<r;i++){const s=t[i];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,i=0){t=Math.abs(t);const r=this.levels;let s;for(s=0;s<r.length&&!(t<r[s].distance);s++);return r.splice(s,0,{distance:t,hysteresis:i,object:e}),this.add(e),this}removeLevel(e){const t=this.levels;for(let i=0;i<t.length;i++)if(t[i].distance===e){const r=t.splice(i,1);return this.remove(r[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let i,r;for(i=1,r=t.length;i<r;i++){let s=t[i].distance;if(t[i].object.visible&&(s-=s*t[i].hysteresis),e<s)break}return t[i-1].object}return null}raycast(e,t){if(this.levels.length>0){mh.setFromMatrixPosition(this.matrixWorld);const r=e.ray.origin.distanceTo(mh);this.getObjectForDistance(r).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){mh.setFromMatrixPosition(e.matrixWorld),Wv.setFromMatrixPosition(this.matrixWorld);const i=mh.distanceTo(Wv)/e.zoom;t[0].object.visible=!0;let r,s;for(r=1,s=t.length;r<s;r++){let o=t[r].distance;if(t[r].object.visible&&(o-=o*t[r].hysteresis),i>=o)t[r-1].object.visible=!1,t[r].object.visible=!0;else break}for(this._currentLevel=r-1;r<s;r++)t[r].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const i=this.levels;for(let r=0,s=i.length;r<s;r++){const o=i[r];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const Xv=new Y,qv=new Dt,Yv=new Dt,$1=new Y,jv=new ct,Ah=new Y,yp=new wn,$v=new ct,_p=new rl;class mC extends en{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AA,this.bindMatrix=new ct,this.bindMatrixInverse=new ct,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Gn),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let i=0;i<t.count;i++)this.getVertexPosition(i,Ah),this.boundingBox.expandByPoint(Ah)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new wn),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let i=0;i<t.count;i++)this.getVertexPosition(i,Ah),this.boundingSphere.expandByPoint(Ah)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const i=this.material,r=this.matrixWorld;i!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),yp.copy(this.boundingSphere),yp.applyMatrix4(r),e.ray.intersectsSphere(yp)!==!1&&($v.copy(r).invert(),_p.copy(e.ray).applyMatrix4($v),!(this.boundingBox!==null&&_p.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,_p)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Dt,t=this.geometry.attributes.skinWeight;for(let i=0,r=t.count;i<r;i++){e.fromBufferAttribute(t,i);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===AA?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===Fb?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const i=this.skeleton,r=this.geometry;qv.fromBufferAttribute(r.attributes.skinIndex,e),Yv.fromBufferAttribute(r.attributes.skinWeight,e),Xv.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=Yv.getComponent(s);if(o!==0){const a=qv.getComponent(s);jv.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),t.addScaledVector($1.copy(Xv).applyMatrix4(jv),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}class h0 extends Ft{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Ki extends mn{constructor(e=null,t=1,i=1,r,s,o,a,l,c=xn,h=xn,u,d){super(null,o,a,l,c,h,r,s,u,d),this.isDataTexture=!0,this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Kv=new ct,K1=new ct;class yf{constructor(e=[],t=[]){this.uuid=ii(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,r=this.bones.length;i<r;i++)this.boneInverses.push(new ct)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const i=new ct;this.bones[e]&&i.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&i.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const e=this.bones,t=this.boneInverses,i=this.boneMatrices,r=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:K1;Kv.multiplyMatrices(a,t[s]),Kv.toArray(i,s*16)}r!==null&&(r.needsUpdate=!0)}clone(){return new yf(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const i=new Ki(t,e,e,On,Un);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){const r=this.bones[t];if(r.name===e)return r}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,r=e.bones.length;i<r;i++){const s=e.bones[i];let o=t[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new h0),this.bones.push(o),this.boneInverses.push(new ct().fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,i=this.boneInverses;for(let r=0,s=t.length;r<s;r++){const o=t[r];e.bones.push(o.uuid);const a=i[r];e.boneInverses.push(a.toArray())}return e}}class ja extends Gt{constructor(e,t,i,r=1){super(e,t,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const sa=new ct,Jv=new ct,gh=[],Zv=new Gn,J1=new ct,vl=new en,El=new wn;class AC extends en{constructor(e,t,i){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new ja(new Float32Array(i*16),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let r=0;r<i;r++)this.setMatrixAt(r,J1)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new Gn),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,sa),Zv.copy(e.boundingBox).applyMatrix4(sa),this.boundingBox.union(Zv)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new wn),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,sa),El.copy(e.boundingSphere).applyMatrix4(sa),this.boundingSphere.union(El)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const i=t.morphTargetInfluences,r=this.morphTexture.source.data.data,s=i.length+1,o=e*s+1;for(let a=0;a<i.length;a++)i[a]=r[o+a]}raycast(e,t){const i=this.matrixWorld,r=this.count;if(vl.geometry=this.geometry,vl.material=this.material,vl.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),El.copy(this.boundingSphere),El.applyMatrix4(i),e.ray.intersectsSphere(El)!==!1))for(let s=0;s<r;s++){this.getMatrixAt(s,sa),Jv.multiplyMatrices(i,sa),vl.matrixWorld=Jv,vl.raycast(e,gh);for(let o=0,a=gh.length;o<a;o++){const l=gh[o];l.instanceId=s,l.object=this,t.push(l)}gh.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new ja(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const i=t.morphTargetInfluences,r=i.length+1;this.morphTexture===null&&(this.morphTexture=new Ki(new Float32Array(r*this.count),r,this.count,hf,Un));const s=this.morphTexture.source.data.data;let o=0;for(let c=0;c<i.length;c++)o+=i[c];const a=this.geometry.morphTargetsRelative?1:1-o,l=r*e;s[l]=a,s.set(i,l+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}const bp=new Y,Z1=new Y,eT=new At;let cs=class{constructor(e=new Y(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=bp.subVectors(i,t).cross(Z1.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const i=e.delta(bp),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(e.start).addScaledVector(i,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||eT.getNormalMatrix(e),r=this.coplanarPoint(bp).applyMatrix4(e),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}};const Ns=new wn,vh=new Y;let Fc=class{constructor(e=new cs,t=new cs,i=new cs,r=new cs,s=new cs,o=new cs){this.planes=[e,t,i,r,s,o]}set(e,t,i,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e,t=Li){const i=this.planes,r=e.elements,s=r[0],o=r[1],a=r[2],l=r[3],c=r[4],h=r[5],u=r[6],d=r[7],f=r[8],A=r[9],g=r[10],m=r[11],p=r[12],v=r[13],E=r[14],x=r[15];if(i[0].setComponents(l-s,d-c,m-f,x-p).normalize(),i[1].setComponents(l+s,d+c,m+f,x+p).normalize(),i[2].setComponents(l+o,d+h,m+A,x+v).normalize(),i[3].setComponents(l-o,d-h,m-A,x-v).normalize(),i[4].setComponents(l-a,d-u,m-g,x-E).normalize(),t===Li)i[5].setComponents(l+a,d+u,m+g,x+E).normalize();else if(t===uc)i[5].setComponents(a,u,g,E).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Ns.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Ns.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Ns)}intersectsSprite(e){return Ns.center.set(0,0,0),Ns.radius=.7071067811865476,Ns.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ns)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(vh.x=r.normal.x>0?e.max.x:e.min.x,vh.y=r.normal.y>0?e.max.y:e.min.y,vh.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(vh)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}};function Cp(n,e){return n-e}function tT(n,e){return n.z-e.z}function nT(n,e){return e.z-n.z}class iT{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t,i,r){const s=this.pool,o=this.list;this.index>=s.length&&s.push({start:-1,count:-1,z:-1,index:-1});const a=s[this.index];o.push(a),this.index++,a.start=e,a.count=t,a.z=i,a.index=r}reset(){this.list.length=0,this.index=0}}const Vn=new ct,rT=new Ke(1,1,1),Mp=new Fc,Eh=new Gn,Os=new wn,xl=new Y,eE=new Y,sT=new Y,Sp=new iT,bn=new en,xh=[];function oT(n,e,t=0){const i=e.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==e.array.constructor){const r=n.count;for(let s=0;s<r;s++)for(let o=0;o<i;o++)e.setComponent(s+t,o,n.getComponent(s,o))}else e.array.set(n.array,t*i);e.needsUpdate=!0}function ks(n,e){if(n.constructor!==e.constructor){const t=Math.min(n.length,e.length);for(let i=0;i<t;i++)e[i]=n[i]}else{const t=Math.min(n.length,e.length);e.set(new n.constructor(n.buffer,0,t))}}class gC extends en{get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}constructor(e,t,i=t*2,r){super(new yt,r),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=t,this._maxIndexCount=i,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),i=new Ki(t,e,e,On,Un);this._matricesTexture=i}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Uint32Array(e*e),i=new Ki(t,e,e,Lc,Gr);this._indirectTexture=i}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Float32Array(e*e*4).fill(1),i=new Ki(t,e,e,On,Un);i.colorSpace=wt.workingColorSpace,this._colorsTexture=i}_initializeGeometry(e){const t=this.geometry,i=this._maxVertexCount,r=this._maxIndexCount;if(this._geometryInitialized===!1){for(const s in e.attributes){const o=e.getAttribute(s),{array:a,itemSize:l,normalized:c}=o,h=new a.constructor(i*l),u=new Gt(h,l,c);t.setAttribute(s,u)}if(e.getIndex()!==null){const s=i>65535?new Uint32Array(r):new Uint16Array(r);t.setIndex(new Gt(s,1))}this._geometryInitialized=!0}}_validateGeometry(e){const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const i in t.attributes){if(!e.hasAttribute(i))throw new Error(`THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);const r=e.getAttribute(i),s=t.getAttribute(i);if(r.itemSize!==s.itemSize||r.normalized!==s.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const t=this._instanceInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const t=this._geometryInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Gn);const e=this.boundingBox,t=this._instanceInfo;e.makeEmpty();for(let i=0,r=t.length;i<r;i++){if(t[i].active===!1)continue;const s=t[i].geometryIndex;this.getMatrixAt(i,Vn),this.getBoundingBoxAt(s,Eh).applyMatrix4(Vn),e.union(Eh)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new wn);const e=this.boundingSphere,t=this._instanceInfo;e.makeEmpty();for(let i=0,r=t.length;i<r;i++){if(t[i].active===!1)continue;const s=t[i].geometryIndex;this.getMatrixAt(i,Vn),this.getBoundingSphereAt(s,Os).applyMatrix4(Vn),e.union(Os)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const i={visible:!0,active:!0,geometryIndex:e};let r=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(Cp),r=this._availableInstanceIds.shift(),this._instanceInfo[r]=i):(r=this._instanceInfo.length,this._instanceInfo.push(i));const s=this._matricesTexture;Vn.identity().toArray(s.image.data,r*16),s.needsUpdate=!0;const o=this._colorsTexture;return o&&(rT.toArray(o.image.data,r*4),o.needsUpdate=!0),this._visibilityChanged=!0,r}addGeometry(e,t=-1,i=-1){this._initializeGeometry(e),this._validateGeometry(e);const r={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},s=this._geometryInfo;r.vertexStart=this._nextVertexStart,r.reservedVertexCount=t===-1?e.getAttribute("position").count:t;const o=e.getIndex();if(o!==null&&(r.indexStart=this._nextIndexStart,r.reservedIndexCount=i===-1?o.count:i),r.indexStart!==-1&&r.indexStart+r.reservedIndexCount>this._maxIndexCount||r.vertexStart+r.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let l;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(Cp),l=this._availableGeometryIds.shift(),s[l]=r):(l=this._geometryCount,this._geometryCount++,s.push(r)),this.setGeometryAt(l,e),this._nextIndexStart=r.indexStart+r.reservedIndexCount,this._nextVertexStart=r.vertexStart+r.reservedVertexCount,l}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const i=this.geometry,r=i.getIndex()!==null,s=i.getIndex(),o=t.getIndex(),a=this._geometryInfo[e];if(r&&o.count>a.reservedIndexCount||t.attributes.position.count>a.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const l=a.vertexStart,c=a.reservedVertexCount;a.vertexCount=t.getAttribute("position").count;for(const h in i.attributes){const u=t.getAttribute(h),d=i.getAttribute(h);oT(u,d,l);const f=u.itemSize;for(let A=u.count,g=c;A<g;A++){const m=l+A;for(let p=0;p<f;p++)d.setComponent(m,p,0)}d.needsUpdate=!0,d.addUpdateRange(l*f,c*f)}if(r){const h=a.indexStart,u=a.reservedIndexCount;a.indexCount=t.getIndex().count;for(let d=0;d<o.count;d++)s.setX(h+d,l+o.getX(d));for(let d=o.count,f=u;d<f;d++)s.setX(h+d,l);s.needsUpdate=!0,s.addUpdateRange(h,a.reservedIndexCount)}return a.start=r?a.indexStart:a.vertexStart,a.count=r?a.indexCount:a.vertexCount,a.boundingBox=null,t.boundingBox!==null&&(a.boundingBox=t.boundingBox.clone()),a.boundingSphere=null,t.boundingSphere!==null&&(a.boundingSphere=t.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._geometryInfo;if(e>=t.length||t[e].active===!1)return this;const i=this._instanceInfo;for(let r=0,s=i.length;r<s;r++)i[r].active&&i[r].geometryIndex===e&&this.deleteInstance(r);return t[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,t=0;const i=this._geometryInfo,r=i.map((o,a)=>a).sort((o,a)=>i[o].vertexStart-i[a].vertexStart),s=this.geometry;for(let o=0,a=i.length;o<a;o++){const l=r[o],c=i[l];if(c.active!==!1){if(s.index!==null){if(c.indexStart!==t){const{indexStart:h,vertexStart:u,reservedIndexCount:d}=c,f=s.index,A=f.array,g=e-u;for(let m=h;m<h+d;m++)A[m]=A[m]+g;f.array.copyWithin(t,h,h+d),f.addUpdateRange(t,d),c.indexStart=t}t+=c.reservedIndexCount}if(c.vertexStart!==e){const{vertexStart:h,reservedVertexCount:u}=c,d=s.attributes;for(const f in d){const A=d[f],{array:g,itemSize:m}=A;g.copyWithin(e*m,h*m,(h+u)*m),A.addUpdateRange(e*m,u*m)}c.vertexStart=e}e+=c.reservedVertexCount,c.start=s.index?c.indexStart:c.vertexStart,this._nextIndexStart=s.index?c.indexStart+c.reservedIndexCount:0,this._nextVertexStart=c.vertexStart+c.reservedVertexCount}}return this}getBoundingBoxAt(e,t){if(e>=this._geometryCount)return null;const i=this.geometry,r=this._geometryInfo[e];if(r.boundingBox===null){const s=new Gn,o=i.index,a=i.attributes.position;for(let l=r.start,c=r.start+r.count;l<c;l++){let h=l;o&&(h=o.getX(h)),s.expandByPoint(xl.fromBufferAttribute(a,h))}r.boundingBox=s}return t.copy(r.boundingBox),t}getBoundingSphereAt(e,t){if(e>=this._geometryCount)return null;const i=this.geometry,r=this._geometryInfo[e];if(r.boundingSphere===null){const s=new wn;this.getBoundingBoxAt(e,Eh),Eh.getCenter(s.center);const o=i.index,a=i.attributes.position;let l=0;for(let c=r.start,h=r.start+r.count;c<h;c++){let u=c;o&&(u=o.getX(u)),xl.fromBufferAttribute(a,u),l=Math.max(l,s.center.distanceToSquared(xl))}s.radius=Math.sqrt(l),r.boundingSphere=s}return t.copy(r.boundingSphere),t}setMatrixAt(e,t){this.validateInstanceId(e);const i=this._matricesTexture,r=this._matricesTexture.image.data;return t.toArray(r,e*16),i.needsUpdate=!0,this}getMatrixAt(e,t){return this.validateInstanceId(e),t.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,t){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),t.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,t){return this.validateInstanceId(e),t.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,t){return this.validateInstanceId(e),this._instanceInfo[e].visible===t?this:(this._instanceInfo[e].visible=t,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,t){return this.validateInstanceId(e),this.validateGeometryId(t),this._instanceInfo[e].geometryIndex=t,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,t={}){this.validateGeometryId(e);const i=this._geometryInfo[e];return t.vertexStart=i.vertexStart,t.vertexCount=i.vertexCount,t.reservedVertexCount=i.reservedVertexCount,t.indexStart=i.indexStart,t.indexCount=i.indexCount,t.reservedIndexCount=i.reservedIndexCount,t.start=i.start,t.count=i.count,t}setInstanceCount(e){const t=this._availableInstanceIds,i=this._instanceInfo;for(t.sort(Cp);t[t.length-1]===i.length;)i.pop(),t.pop();if(e<i.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const r=new Int32Array(e),s=new Int32Array(e);ks(this._multiDrawCounts,r),ks(this._multiDrawStarts,s),this._multiDrawCounts=r,this._multiDrawStarts=s,this._maxInstanceCount=e;const o=this._indirectTexture,a=this._matricesTexture,l=this._colorsTexture;o.dispose(),this._initIndirectTexture(),ks(o.image.data,this._indirectTexture.image.data),a.dispose(),this._initMatricesTexture(),ks(a.image.data,this._matricesTexture.image.data),l&&(l.dispose(),this._initColorsTexture(),ks(l.image.data,this._colorsTexture.image.data))}setGeometrySize(e,t){const i=[...this._geometryInfo].filter(a=>a.active);if(Math.max(...i.map(a=>a.vertexStart+a.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...i.map(l=>l.indexStart+l.reservedIndexCount))>t)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);const s=this.geometry;s.dispose(),this._maxVertexCount=e,this._maxIndexCount=t,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new yt,this._initializeGeometry(s));const o=this.geometry;s.index&&ks(s.index.array,o.index.array);for(const a in s.attributes)ks(s.attributes[a].array,o.attributes[a].array)}raycast(e,t){const i=this._instanceInfo,r=this._geometryInfo,s=this.matrixWorld,o=this.geometry;bn.material=this.material,bn.geometry.index=o.index,bn.geometry.attributes=o.attributes,bn.geometry.boundingBox===null&&(bn.geometry.boundingBox=new Gn),bn.geometry.boundingSphere===null&&(bn.geometry.boundingSphere=new wn);for(let a=0,l=i.length;a<l;a++){if(!i[a].visible||!i[a].active)continue;const c=i[a].geometryIndex,h=r[c];bn.geometry.setDrawRange(h.start,h.count),this.getMatrixAt(a,bn.matrixWorld).premultiply(s),this.getBoundingBoxAt(c,bn.geometry.boundingBox),this.getBoundingSphereAt(c,bn.geometry.boundingSphere),bn.raycast(e,xh);for(let u=0,d=xh.length;u<d;u++){const f=xh[u];f.object=this,f.batchId=a,t.push(f)}xh.length=0}bn.material=null,bn.geometry.index=null,bn.geometry.attributes={},bn.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox!==null?t.boundingBox.clone():null,boundingSphere:t.boundingSphere!==null?t.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(t=>({...t})),this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null),this}onBeforeRender(e,t,i,r,s){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=r.getIndex(),a=o===null?1:o.array.BYTES_PER_ELEMENT,l=this._instanceInfo,c=this._multiDrawStarts,h=this._multiDrawCounts,u=this._geometryInfo,d=this.perObjectFrustumCulled,f=this._indirectTexture,A=f.image.data;d&&(Vn.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse).multiply(this.matrixWorld),Mp.setFromProjectionMatrix(Vn,e.coordinateSystem));let g=0;if(this.sortObjects){Vn.copy(this.matrixWorld).invert(),xl.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Vn),eE.set(0,0,-1).transformDirection(i.matrixWorld).transformDirection(Vn);for(let v=0,E=l.length;v<E;v++)if(l[v].visible&&l[v].active){const x=l[v].geometryIndex;this.getMatrixAt(v,Vn),this.getBoundingSphereAt(x,Os).applyMatrix4(Vn);let M=!1;if(d&&(M=!Mp.intersectsSphere(Os)),!M){const w=u[x],S=sT.subVectors(Os.center,xl).dot(eE);Sp.push(w.start,w.count,S,v)}}const m=Sp.list,p=this.customSort;p===null?m.sort(s.transparent?nT:tT):p.call(this,m,i);for(let v=0,E=m.length;v<E;v++){const x=m[v];c[g]=x.start*a,h[g]=x.count,A[g]=x.index,g++}Sp.reset()}else for(let m=0,p=l.length;m<p;m++)if(l[m].visible&&l[m].active){const v=l[m].geometryIndex;let E=!1;if(d&&(this.getMatrixAt(m,Vn),this.getBoundingSphereAt(v,Os).applyMatrix4(Vn),E=!Mp.intersectsSphere(Os)),!E){const x=u[v];c[g]=x.start*a,h[g]=x.count,A[g]=m,g++}}f.needsUpdate=!0,this._multiDrawCount=g,this._visibilityChanged=!1}onBeforeShadow(e,t,i,r,s,o){this.onBeforeRender(e,null,r,s,o)}}class Hn extends Tn{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Ke(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const Fd=new Y,Nd=new Y,tE=new ct,yl=new rl,yh=new wn,wp=new Y,nE=new Y;class Cs extends Ft{constructor(e=new yt,t=new Hn){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[0];for(let r=1,s=t.count;r<s;r++)Fd.fromBufferAttribute(t,r-1),Nd.fromBufferAttribute(t,r),i[r]=i[r-1],i[r]+=Fd.distanceTo(Nd);e.setAttribute("lineDistance",new et(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,s=e.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),yh.copy(i.boundingSphere),yh.applyMatrix4(r),yh.radius+=s,e.ray.intersectsSphere(yh)===!1)return;tE.copy(r).invert(),yl.copy(e.ray).applyMatrix4(tE);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=this.isLineSegments?2:1,h=i.index,d=i.attributes.position;if(h!==null){const f=Math.max(0,o.start),A=Math.min(h.count,o.start+o.count);for(let g=f,m=A-1;g<m;g+=c){const p=h.getX(g),v=h.getX(g+1),E=_h(this,e,yl,l,p,v,g);E&&t.push(E)}if(this.isLineLoop){const g=h.getX(A-1),m=h.getX(f),p=_h(this,e,yl,l,g,m,A-1);p&&t.push(p)}}else{const f=Math.max(0,o.start),A=Math.min(d.count,o.start+o.count);for(let g=f,m=A-1;g<m;g+=c){const p=_h(this,e,yl,l,g,g+1,g);p&&t.push(p)}if(this.isLineLoop){const g=_h(this,e,yl,l,A-1,f,A-1);g&&t.push(g)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function _h(n,e,t,i,r,s,o){const a=n.geometry.attributes.position;if(Fd.fromBufferAttribute(a,r),Nd.fromBufferAttribute(a,s),t.distanceSqToSegment(Fd,Nd,wp,nE)>i)return;wp.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(wp);if(!(c<e.near||c>e.far))return{distance:c,point:nE.clone().applyMatrix4(n.matrixWorld),index:o,face:null,faceIndex:null,barycoord:null,object:n}}const iE=new Y,rE=new Y;class nr extends Cs{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[];for(let r=0,s=t.count;r<s;r+=2)iE.fromBufferAttribute(t,r),rE.fromBufferAttribute(t,r+1),i[r]=r===0?0:i[r-1],i[r+1]=i[r]+iE.distanceTo(rE);e.setAttribute("lineDistance",new et(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class vC extends Cs{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class u0 extends Tn{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Ke(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const sE=new ct,xA=new rl,bh=new wn,Ch=new Y;class EC extends Ft{constructor(e=new yt,t=new u0){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,s=e.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),bh.copy(i.boundingSphere),bh.applyMatrix4(r),bh.radius+=s,e.ray.intersectsSphere(bh)===!1)return;sE.copy(r).invert(),xA.copy(e.ray).applyMatrix4(sE);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=i.index,u=i.attributes.position;if(c!==null){const d=Math.max(0,o.start),f=Math.min(c.count,o.start+o.count);for(let A=d,g=f;A<g;A++){const m=c.getX(A);Ch.fromBufferAttribute(u,m),oE(Ch,m,l,r,e,t,this)}}else{const d=Math.max(0,o.start),f=Math.min(u.count,o.start+o.count);for(let A=d,g=f;A<g;A++)Ch.fromBufferAttribute(u,A),oE(Ch,A,l,r,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function oE(n,e,t,i,r,s,o){const a=xA.distanceSqToPoint(n);if(a<t){const l=new Y;xA.closestPointToPoint(n,l),l.applyMatrix4(i);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,faceIndex:null,barycoord:null,object:o})}}let xC=class extends mn{constructor(e,t,i,r,s,o,a,l,c){super(e,t,i,r,s,o,a,l,c),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:ln,this.magFilter=s!==void 0?s:ln,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,e.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}};class aT extends xC{constructor(e,t,i,r,s,o,a,l){super({},e,t,i,r,s,o,a,l),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class lT extends mn{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=xn,this.minFilter=xn,this.generateMipmaps=!1,this.needsUpdate=!0}}class _f extends mn{constructor(e,t,i,r,s,o,a,l,c,h,u,d){super(null,o,a,l,c,h,r,s,u,d),this.isCompressedTexture=!0,this.image={width:t,height:i},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class cT extends _f{constructor(e,t,i,r,s,o){super(e,t,i,s,o),this.isCompressedArrayTexture=!0,this.image.depth=r,this.wrapR=mi,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class hT extends _f{constructor(e,t,i){super(void 0,e[0].width,e[0].height,t,i,kr),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class uT extends mn{constructor(e,t,i,r,s,o,a,l,c){super(e,t,i,r,s,o,a,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}let d0=class extends mn{constructor(e,t,i,r,s,o,a,l,c,h=Es){if(h!==Es&&h!==xs)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&h===Es&&(i=Gr),i===void 0&&h===xs&&(i=vs),super(null,r,s,o,a,l,h,i,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:xn,this.minFilter=l!==void 0?l:xn,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}};class ki{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,r=this.getPoint(0),s=0;t.push(0);for(let o=1;o<=e;o++)i=this.getPoint(o/e),s+=i.distanceTo(r),t.push(s),r=i;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const i=this.getLengths();let r=0;const s=i.length;let o;t?o=t:o=e*i[s-1];let a=0,l=s-1,c;for(;a<=l;)if(r=Math.floor(a+(l-a)/2),c=i[r]-o,c<0)a=r+1;else if(c>0)l=r-1;else{l=r;break}if(r=l,i[r]===o)return r/(s-1);const h=i[r],d=i[r+1]-h,f=(o-h)/d;return(r+f)/(s-1)}getTangent(e,t){let r=e-1e-4,s=e+1e-4;r<0&&(r=0),s>1&&(s=1);const o=this.getPoint(r),a=this.getPoint(s),l=t||(o.isVector2?new Ne:new Y);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){const i=new Y,r=[],s=[],o=[],a=new Y,l=new ct;for(let f=0;f<=e;f++){const A=f/e;r[f]=this.getTangentAt(A,new Y)}s[0]=new Y,o[0]=new Y;let c=Number.MAX_VALUE;const h=Math.abs(r[0].x),u=Math.abs(r[0].y),d=Math.abs(r[0].z);h<=c&&(c=h,i.set(1,0,0)),u<=c&&(c=u,i.set(0,1,0)),d<=c&&i.set(0,0,1),a.crossVectors(r[0],i).normalize(),s[0].crossVectors(r[0],a),o[0].crossVectors(r[0],s[0]);for(let f=1;f<=e;f++){if(s[f]=s[f-1].clone(),o[f]=o[f-1].clone(),a.crossVectors(r[f-1],r[f]),a.length()>Number.EPSILON){a.normalize();const A=Math.acos(pt(r[f-1].dot(r[f]),-1,1));s[f].applyMatrix4(l.makeRotationAxis(a,A))}o[f].crossVectors(r[f],s[f])}if(t===!0){let f=Math.acos(pt(s[0].dot(s[e]),-1,1));f/=e,r[0].dot(a.crossVectors(s[0],s[e]))>0&&(f=-f);for(let A=1;A<=e;A++)s[A].applyMatrix4(l.makeRotationAxis(r[A],f*A)),o[A].crossVectors(r[A],s[A])}return{tangents:r,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class bf extends ki{constructor(e=0,t=0,i=1,r=1,s=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=i,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t=new Ne){const i=t,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(o?s=0:s=r),this.aClockwise===!0&&!o&&(s===r?s=-r:s=s-r);const a=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const h=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*h-f*u+this.aX,c=d*u+f*h+this.aY}return i.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class yC extends bf{constructor(e,t,i,r,s,o){super(e,t,i,i,r,s,o),this.isArcCurve=!0,this.type="ArcCurve"}}function f0(){let n=0,e=0,t=0,i=0;function r(s,o,a,l){n=s,e=a,t=-3*s+3*o-2*a-l,i=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){r(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,h,u){let d=(o-s)/c-(a-s)/(c+h)+(a-o)/h,f=(a-o)/h-(l-o)/(h+u)+(l-a)/u;d*=h,f*=h,r(o,a,d,f)},calc:function(s){const o=s*s,a=o*s;return n+e*s+t*o+i*a}}}const Mh=new Y,Tp=new f0,Ip=new f0,Rp=new f0;class _C extends ki{constructor(e=[],t=!1,i="centripetal",r=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=i,this.tension=r}getPoint(e,t=new Y){const i=t,r=this.points,s=r.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:l===0&&a===s-1&&(a=s-2,l=1);let c,h;this.closed||a>0?c=r[(a-1)%s]:(Mh.subVectors(r[0],r[1]).add(r[0]),c=Mh);const u=r[a%s],d=r[(a+1)%s];if(this.closed||a+2<s?h=r[(a+2)%s]:(Mh.subVectors(r[s-1],r[s-2]).add(r[s-1]),h=Mh),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let A=Math.pow(c.distanceToSquared(u),f),g=Math.pow(u.distanceToSquared(d),f),m=Math.pow(d.distanceToSquared(h),f);g<1e-4&&(g=1),A<1e-4&&(A=g),m<1e-4&&(m=g),Tp.initNonuniformCatmullRom(c.x,u.x,d.x,h.x,A,g,m),Ip.initNonuniformCatmullRom(c.y,u.y,d.y,h.y,A,g,m),Rp.initNonuniformCatmullRom(c.z,u.z,d.z,h.z,A,g,m)}else this.curveType==="catmullrom"&&(Tp.initCatmullRom(c.x,u.x,d.x,h.x,this.tension),Ip.initCatmullRom(c.y,u.y,d.y,h.y,this.tension),Rp.initCatmullRom(c.z,u.z,d.z,h.z,this.tension));return i.set(Tp.calc(l),Ip.calc(l),Rp.calc(l)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(new Y().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function aE(n,e,t,i,r){const s=(i-e)*.5,o=(r-t)*.5,a=n*n,l=n*a;return(2*t-2*i+s+o)*l+(-3*t+3*i-2*s-o)*a+s*n+t}function dT(n,e){const t=1-n;return t*t*e}function fT(n,e){return 2*(1-n)*n*e}function pT(n,e){return n*n*e}function Kl(n,e,t,i){return dT(n,e)+fT(n,t)+pT(n,i)}function mT(n,e){const t=1-n;return t*t*t*e}function AT(n,e){const t=1-n;return 3*t*t*n*e}function gT(n,e){return 3*(1-n)*n*n*e}function vT(n,e){return n*n*n*e}function Jl(n,e,t,i,r){return mT(n,e)+AT(n,t)+gT(n,i)+vT(n,r)}class p0 extends ki{constructor(e=new Ne,t=new Ne,i=new Ne,r=new Ne){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new Ne){const i=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(Jl(e,r.x,s.x,o.x,a.x),Jl(e,r.y,s.y,o.y,a.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class bC extends ki{constructor(e=new Y,t=new Y,i=new Y,r=new Y){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new Y){const i=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(Jl(e,r.x,s.x,o.x,a.x),Jl(e,r.y,s.y,o.y,a.y),Jl(e,r.z,s.z,o.z,a.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class m0 extends ki{constructor(e=new Ne,t=new Ne){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Ne){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Ne){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class CC extends ki{constructor(e=new Y,t=new Y){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new Y){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Y){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class A0 extends ki{constructor(e=new Ne,t=new Ne,i=new Ne){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Ne){const i=t,r=this.v0,s=this.v1,o=this.v2;return i.set(Kl(e,r.x,s.x,o.x),Kl(e,r.y,s.y,o.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class g0 extends ki{constructor(e=new Y,t=new Y,i=new Y){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Y){const i=t,r=this.v0,s=this.v1,o=this.v2;return i.set(Kl(e,r.x,s.x,o.x),Kl(e,r.y,s.y,o.y),Kl(e,r.z,s.z,o.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class v0 extends ki{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Ne){const i=t,r=this.points,s=(r.length-1)*e,o=Math.floor(s),a=s-o,l=r[o===0?o:o-1],c=r[o],h=r[o>r.length-2?r.length-1:o+1],u=r[o>r.length-3?r.length-1:o+2];return i.set(aE(a,l.x,c.x,h.x,u.x),aE(a,l.y,c.y,h.y,u.y)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(new Ne().fromArray(r))}return this}}var Od=Object.freeze({__proto__:null,ArcCurve:yC,CatmullRomCurve3:_C,CubicBezierCurve:p0,CubicBezierCurve3:bC,EllipseCurve:bf,LineCurve:m0,LineCurve3:CC,QuadraticBezierCurve:A0,QuadraticBezierCurve3:g0,SplineCurve:v0});class MC extends ki{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const i=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Od[i](t,e))}return this}getPoint(e,t){const i=e*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=i){const o=r[s]-i,a=this.curves[s],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let i=0,r=this.curves.length;i<r;i++)t+=this.curves[i].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let i;for(let r=0,s=this.curves;r<s.length;r++){const o=s[r],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const h=l[c];i&&i.equals(h)||(t.push(h),i=h)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,i=this.curves.length;t<i;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const r=e.curves[t];this.curves.push(new Od[r.type]().fromJSON(r))}return this}}class fc extends MC{constructor(e){super(),this.type="Path",this.currentPoint=new Ne,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,i=e.length;t<i;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const i=new m0(this.currentPoint.clone(),new Ne(e,t));return this.curves.push(i),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,i,r){const s=new A0(this.currentPoint.clone(),new Ne(e,t),new Ne(i,r));return this.curves.push(s),this.currentPoint.set(i,r),this}bezierCurveTo(e,t,i,r,s,o){const a=new p0(this.currentPoint.clone(),new Ne(e,t),new Ne(i,r),new Ne(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),i=new v0(t);return this.curves.push(i),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,i,r,s,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,i,r,s,o),this}absarc(e,t,i,r,s,o){return this.absellipse(e,t,i,i,r,s,o),this}ellipse(e,t,i,r,s,o,a,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(e+c,t+h,i,r,s,o,a,l),this}absellipse(e,t,i,r,s,o,a,l){const c=new bf(e,t,i,r,s,o,a,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Nc extends yt{constructor(e=[new Ne(0,-.5),new Ne(.5,0),new Ne(0,.5)],t=12,i=0,r=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:i,phiLength:r},t=Math.floor(t),r=pt(r,0,Math.PI*2);const s=[],o=[],a=[],l=[],c=[],h=1/t,u=new Y,d=new Ne,f=new Y,A=new Y,g=new Y;let m=0,p=0;for(let v=0;v<=e.length-1;v++)switch(v){case 0:m=e[v+1].x-e[v].x,p=e[v+1].y-e[v].y,f.x=p*1,f.y=-m,f.z=p*0,g.copy(f),f.normalize(),l.push(f.x,f.y,f.z);break;case e.length-1:l.push(g.x,g.y,g.z);break;default:m=e[v+1].x-e[v].x,p=e[v+1].y-e[v].y,f.x=p*1,f.y=-m,f.z=p*0,A.copy(f),f.x+=g.x,f.y+=g.y,f.z+=g.z,f.normalize(),l.push(f.x,f.y,f.z),g.copy(A)}for(let v=0;v<=t;v++){const E=i+v*h*r,x=Math.sin(E),M=Math.cos(E);for(let w=0;w<=e.length-1;w++){u.x=e[w].x*x,u.y=e[w].y,u.z=e[w].x*M,o.push(u.x,u.y,u.z),d.x=v/t,d.y=w/(e.length-1),a.push(d.x,d.y);const S=l[3*w+0]*x,B=l[3*w+1],y=l[3*w+0]*M;c.push(S,B,y)}}for(let v=0;v<t;v++)for(let E=0;E<e.length-1;E++){const x=E+v*e.length,M=x,w=x+e.length,S=x+e.length+1,B=x+1;s.push(M,w,B),s.push(S,B,w)}this.setIndex(s),this.setAttribute("position",new et(o,3)),this.setAttribute("uv",new et(a,2)),this.setAttribute("normal",new et(c,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Nc(e.points,e.segments,e.phiStart,e.phiLength)}}class Cf extends Nc{constructor(e=1,t=1,i=4,r=8){const s=new fc;s.absarc(0,-t/2,e,Math.PI*1.5,0),s.absarc(0,t/2,e,0,Math.PI*.5),super(s.getPoints(i),r),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:i,radialSegments:r}}static fromJSON(e){return new Cf(e.radius,e.length,e.capSegments,e.radialSegments)}}class Mf extends yt{constructor(e=1,t=32,i=0,r=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:r},t=Math.max(3,t);const s=[],o=[],a=[],l=[],c=new Y,h=new Ne;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let u=0,d=3;u<=t;u++,d+=3){const f=i+u/t*r;c.x=e*Math.cos(f),c.y=e*Math.sin(f),o.push(c.x,c.y,c.z),a.push(0,0,1),h.x=(o[d]/e+1)/2,h.y=(o[d+1]/e+1)/2,l.push(h.x,h.y)}for(let u=1;u<=t;u++)s.push(u,u+1,0);this.setIndex(s),this.setAttribute("position",new et(o,3)),this.setAttribute("normal",new et(a,3)),this.setAttribute("uv",new et(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Mf(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class sl extends yt{constructor(e=1,t=1,i=1,r=32,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:r,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;r=Math.floor(r),s=Math.floor(s);const h=[],u=[],d=[],f=[];let A=0;const g=[],m=i/2;let p=0;v(),o===!1&&(e>0&&E(!0),t>0&&E(!1)),this.setIndex(h),this.setAttribute("position",new et(u,3)),this.setAttribute("normal",new et(d,3)),this.setAttribute("uv",new et(f,2));function v(){const x=new Y,M=new Y;let w=0;const S=(t-e)/i;for(let B=0;B<=s;B++){const y=[],_=B/s,L=_*(t-e)+e;for(let Q=0;Q<=r;Q++){const O=Q/r,X=O*l+a,te=Math.sin(X),W=Math.cos(X);M.x=L*te,M.y=-_*i+m,M.z=L*W,u.push(M.x,M.y,M.z),x.set(te,S,W).normalize(),d.push(x.x,x.y,x.z),f.push(O,1-_),y.push(A++)}g.push(y)}for(let B=0;B<r;B++)for(let y=0;y<s;y++){const _=g[y][B],L=g[y+1][B],Q=g[y+1][B+1],O=g[y][B+1];(e>0||y!==0)&&(h.push(_,L,O),w+=3),(t>0||y!==s-1)&&(h.push(L,Q,O),w+=3)}c.addGroup(p,w,0),p+=w}function E(x){const M=A,w=new Ne,S=new Y;let B=0;const y=x===!0?e:t,_=x===!0?1:-1;for(let Q=1;Q<=r;Q++)u.push(0,m*_,0),d.push(0,_,0),f.push(.5,.5),A++;const L=A;for(let Q=0;Q<=r;Q++){const X=Q/r*l+a,te=Math.cos(X),W=Math.sin(X);S.x=y*W,S.y=m*_,S.z=y*te,u.push(S.x,S.y,S.z),d.push(0,_,0),w.x=te*.5+.5,w.y=W*.5*_+.5,f.push(w.x,w.y),A++}for(let Q=0;Q<r;Q++){const O=M+Q,X=L+Q;x===!0?h.push(X,X+1,O):h.push(X+1,X,O),B+=3}c.addGroup(p,B,x===!0?1:2),p+=B}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new sl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Sf extends sl{constructor(e=1,t=1,i=32,r=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,i,r,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:a}}static fromJSON(e){return new Sf(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Bs extends yt{constructor(e=[],t=[],i=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:r};const s=[],o=[];a(r),c(i),h(),this.setAttribute("position",new et(s,3)),this.setAttribute("normal",new et(s.slice(),3)),this.setAttribute("uv",new et(o,2)),r===0?this.computeVertexNormals():this.normalizeNormals();function a(v){const E=new Y,x=new Y,M=new Y;for(let w=0;w<t.length;w+=3)f(t[w+0],E),f(t[w+1],x),f(t[w+2],M),l(E,x,M,v)}function l(v,E,x,M){const w=M+1,S=[];for(let B=0;B<=w;B++){S[B]=[];const y=v.clone().lerp(x,B/w),_=E.clone().lerp(x,B/w),L=w-B;for(let Q=0;Q<=L;Q++)Q===0&&B===w?S[B][Q]=y:S[B][Q]=y.clone().lerp(_,Q/L)}for(let B=0;B<w;B++)for(let y=0;y<2*(w-B)-1;y++){const _=Math.floor(y/2);y%2===0?(d(S[B][_+1]),d(S[B+1][_]),d(S[B][_])):(d(S[B][_+1]),d(S[B+1][_+1]),d(S[B+1][_]))}}function c(v){const E=new Y;for(let x=0;x<s.length;x+=3)E.x=s[x+0],E.y=s[x+1],E.z=s[x+2],E.normalize().multiplyScalar(v),s[x+0]=E.x,s[x+1]=E.y,s[x+2]=E.z}function h(){const v=new Y;for(let E=0;E<s.length;E+=3){v.x=s[E+0],v.y=s[E+1],v.z=s[E+2];const x=m(v)/2/Math.PI+.5,M=p(v)/Math.PI+.5;o.push(x,1-M)}A(),u()}function u(){for(let v=0;v<o.length;v+=6){const E=o[v+0],x=o[v+2],M=o[v+4],w=Math.max(E,x,M),S=Math.min(E,x,M);w>.9&&S<.1&&(E<.2&&(o[v+0]+=1),x<.2&&(o[v+2]+=1),M<.2&&(o[v+4]+=1))}}function d(v){s.push(v.x,v.y,v.z)}function f(v,E){const x=v*3;E.x=e[x+0],E.y=e[x+1],E.z=e[x+2]}function A(){const v=new Y,E=new Y,x=new Y,M=new Y,w=new Ne,S=new Ne,B=new Ne;for(let y=0,_=0;y<s.length;y+=9,_+=6){v.set(s[y+0],s[y+1],s[y+2]),E.set(s[y+3],s[y+4],s[y+5]),x.set(s[y+6],s[y+7],s[y+8]),w.set(o[_+0],o[_+1]),S.set(o[_+2],o[_+3]),B.set(o[_+4],o[_+5]),M.copy(v).add(E).add(x).divideScalar(3);const L=m(M);g(w,_+0,v,L),g(S,_+2,E,L),g(B,_+4,x,L)}}function g(v,E,x,M){M<0&&v.x===1&&(o[E]=v.x-1),x.x===0&&x.z===0&&(o[E]=M/2/Math.PI+.5)}function m(v){return Math.atan2(v.z,-v.x)}function p(v){return Math.atan2(-v.y,Math.sqrt(v.x*v.x+v.z*v.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Bs(e.vertices,e.indices,e.radius,e.details)}}class wf extends Bs{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=1/i,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-i,0,-r,i,0,r,-i,0,r,i,-r,-i,0,-r,i,0,r,-i,0,r,i,0,-i,0,-r,i,0,-r,-i,0,r,i,0,r],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new wf(e.radius,e.detail)}}const Sh=new Y,wh=new Y,Bp=new Y,Th=new fs;class SC extends yt{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const r=Math.pow(10,4),s=Math.cos(Co*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],h=["a","b","c"],u=new Array(3),d={},f=[];for(let A=0;A<l;A+=3){o?(c[0]=o.getX(A),c[1]=o.getX(A+1),c[2]=o.getX(A+2)):(c[0]=A,c[1]=A+1,c[2]=A+2);const{a:g,b:m,c:p}=Th;if(g.fromBufferAttribute(a,c[0]),m.fromBufferAttribute(a,c[1]),p.fromBufferAttribute(a,c[2]),Th.getNormal(Bp),u[0]=`${Math.round(g.x*r)},${Math.round(g.y*r)},${Math.round(g.z*r)}`,u[1]=`${Math.round(m.x*r)},${Math.round(m.y*r)},${Math.round(m.z*r)}`,u[2]=`${Math.round(p.x*r)},${Math.round(p.y*r)},${Math.round(p.z*r)}`,!(u[0]===u[1]||u[1]===u[2]||u[2]===u[0]))for(let v=0;v<3;v++){const E=(v+1)%3,x=u[v],M=u[E],w=Th[h[v]],S=Th[h[E]],B=`${x}_${M}`,y=`${M}_${x}`;y in d&&d[y]?(Bp.dot(d[y].normal)<=s&&(f.push(w.x,w.y,w.z),f.push(S.x,S.y,S.z)),d[y]=null):B in d||(d[B]={index0:c[v],index1:c[E],normal:Bp.clone()})}}for(const A in d)if(d[A]){const{index0:g,index1:m}=d[A];Sh.fromBufferAttribute(a,g),wh.fromBufferAttribute(a,m),f.push(Sh.x,Sh.y,Sh.z),f.push(wh.x,wh.y,wh.z)}this.setAttribute("position",new et(f,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Mo extends fc{constructor(e){super(e),this.uuid=ii(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let i=0,r=this.holes.length;i<r;i++)t[i]=this.holes[i].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,i=this.holes.length;t<i;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const r=e.holes[t];this.holes.push(new fc().fromJSON(r))}return this}}const ET={triangulate:function(n,e,t=2){const i=e&&e.length,r=i?e[0]*t:n.length;let s=wC(n,0,r,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,h,u,d,f;if(i&&(s=CT(n,e,s,t)),n.length>80*t){a=c=n[0],l=h=n[1];for(let A=t;A<r;A+=t)u=n[A],d=n[A+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);f=Math.max(c-a,h-l),f=f!==0?32767/f:0}return pc(s,o,t,a,l,f,0),o}};function wC(n,e,t,i,r){let s,o;if(r===UT(n,e,t,i)>0)for(s=e;s<t;s+=i)o=lE(s,n[s],n[s+1],o);else for(s=t-i;s>=e;s-=i)o=lE(s,n[s],n[s+1],o);return o&&Tf(o,o.next)&&(Ac(o),o=o.next),o}function Bo(n,e){if(!n)return n;e||(e=n);let t=n,i;do if(i=!1,!t.steiner&&(Tf(t,t.next)||Qt(t.prev,t,t.next)===0)){if(Ac(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e}function pc(n,e,t,i,r,s,o){if(!n)return;!o&&s&&IT(n,i,r,s);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,s?yT(n,i,r,s):xT(n)){e.push(l.i/t|0),e.push(n.i/t|0),e.push(c.i/t|0),Ac(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=_T(Bo(n),e,t),pc(n,e,t,i,r,s,2)):o===2&&bT(n,e,t,i,r,s):pc(Bo(n),e,t,i,r,s,1);break}}}function xT(n){const e=n.prev,t=n,i=n.next;if(Qt(e,t,i)>=0)return!1;const r=e.x,s=t.x,o=i.x,a=e.y,l=t.y,c=i.y,h=r<s?r<o?r:o:s<o?s:o,u=a<l?a<c?a:c:l<c?l:c,d=r>s?r>o?r:o:s>o?s:o,f=a>l?a>c?a:c:l>c?l:c;let A=i.next;for(;A!==e;){if(A.x>=h&&A.x<=d&&A.y>=u&&A.y<=f&&Ua(r,a,s,l,o,c,A.x,A.y)&&Qt(A.prev,A,A.next)>=0)return!1;A=A.next}return!0}function yT(n,e,t,i){const r=n.prev,s=n,o=n.next;if(Qt(r,s,o)>=0)return!1;const a=r.x,l=s.x,c=o.x,h=r.y,u=s.y,d=o.y,f=a<l?a<c?a:c:l<c?l:c,A=h<u?h<d?h:d:u<d?u:d,g=a>l?a>c?a:c:l>c?l:c,m=h>u?h>d?h:d:u>d?u:d,p=yA(f,A,e,t,i),v=yA(g,m,e,t,i);let E=n.prevZ,x=n.nextZ;for(;E&&E.z>=p&&x&&x.z<=v;){if(E.x>=f&&E.x<=g&&E.y>=A&&E.y<=m&&E!==r&&E!==o&&Ua(a,h,l,u,c,d,E.x,E.y)&&Qt(E.prev,E,E.next)>=0||(E=E.prevZ,x.x>=f&&x.x<=g&&x.y>=A&&x.y<=m&&x!==r&&x!==o&&Ua(a,h,l,u,c,d,x.x,x.y)&&Qt(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;E&&E.z>=p;){if(E.x>=f&&E.x<=g&&E.y>=A&&E.y<=m&&E!==r&&E!==o&&Ua(a,h,l,u,c,d,E.x,E.y)&&Qt(E.prev,E,E.next)>=0)return!1;E=E.prevZ}for(;x&&x.z<=v;){if(x.x>=f&&x.x<=g&&x.y>=A&&x.y<=m&&x!==r&&x!==o&&Ua(a,h,l,u,c,d,x.x,x.y)&&Qt(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function _T(n,e,t){let i=n;do{const r=i.prev,s=i.next.next;!Tf(r,s)&&TC(r,i,i.next,s)&&mc(r,s)&&mc(s,r)&&(e.push(r.i/t|0),e.push(i.i/t|0),e.push(s.i/t|0),Ac(i),Ac(i.next),i=n=s),i=i.next}while(i!==n);return Bo(i)}function bT(n,e,t,i,r,s){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&LT(o,a)){let l=IC(o,a);o=Bo(o,o.next),l=Bo(l,l.next),pc(o,e,t,i,r,s,0),pc(l,e,t,i,r,s,0);return}a=a.next}o=o.next}while(o!==n)}function CT(n,e,t,i){const r=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:n.length,c=wC(n,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(BT(c));for(r.sort(MT),s=0;s<r.length;s++)t=ST(r[s],t);return t}function MT(n,e){return n.x-e.x}function ST(n,e){const t=wT(n,e);if(!t)return e;const i=IC(t,n);return Bo(i,i.next),Bo(t,t.next)}function wT(n,e){let t=e,i=-1/0,r;const s=n.x,o=n.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const d=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=s&&d>i&&(i=d,r=t.x<t.next.x?t:t.next,d===s))return r}t=t.next}while(t!==e);if(!r)return null;const a=r,l=r.x,c=r.y;let h=1/0,u;t=r;do s>=t.x&&t.x>=l&&s!==t.x&&Ua(o<c?s:i,o,l,c,o<c?i:s,o,t.x,t.y)&&(u=Math.abs(o-t.y)/(s-t.x),mc(t,n)&&(u<h||u===h&&(t.x>r.x||t.x===r.x&&TT(r,t)))&&(r=t,h=u)),t=t.next;while(t!==a);return r}function TT(n,e){return Qt(n.prev,n,e.prev)<0&&Qt(e.next,n,n.next)<0}function IT(n,e,t,i){let r=n;do r.z===0&&(r.z=yA(r.x,r.y,e,t,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,RT(r)}function RT(n){let e,t,i,r,s,o,a,l,c=1;do{for(t=n,n=null,s=null,o=0;t;){for(o++,i=t,a=0,e=0;e<c&&(a++,i=i.nextZ,!!i);e++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||t.z<=i.z)?(r=t,t=t.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:n=r,r.prevZ=s,s=r;t=i}s.nextZ=null,c*=2}while(o>1);return n}function yA(n,e,t,i,r){return n=(n-t)*r|0,e=(e-i)*r|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function BT(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Ua(n,e,t,i,r,s,o,a){return(r-o)*(e-a)>=(n-o)*(s-a)&&(n-o)*(i-a)>=(t-o)*(e-a)&&(t-o)*(s-a)>=(r-o)*(i-a)}function LT(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!DT(n,e)&&(mc(n,e)&&mc(e,n)&&PT(n,e)&&(Qt(n.prev,n,e.prev)||Qt(n,e.prev,e))||Tf(n,e)&&Qt(n.prev,n,n.next)>0&&Qt(e.prev,e,e.next)>0)}function Qt(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Tf(n,e){return n.x===e.x&&n.y===e.y}function TC(n,e,t,i){const r=Rh(Qt(n,e,t)),s=Rh(Qt(n,e,i)),o=Rh(Qt(t,i,n)),a=Rh(Qt(t,i,e));return!!(r!==s&&o!==a||r===0&&Ih(n,t,e)||s===0&&Ih(n,i,e)||o===0&&Ih(t,n,i)||a===0&&Ih(t,e,i))}function Ih(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Rh(n){return n>0?1:n<0?-1:0}function DT(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&TC(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function mc(n,e){return Qt(n.prev,n,n.next)<0?Qt(n,e,n.next)>=0&&Qt(n,n.prev,e)>=0:Qt(n,e,n.prev)<0||Qt(n,n.next,e)<0}function PT(n,e){let t=n,i=!1;const r=(n.x+e.x)/2,s=(n.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&r<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==n);return i}function IC(n,e){const t=new _A(n.i,n.x,n.y),i=new _A(e.i,e.x,e.y),r=n.next,s=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,i.next=t,t.prev=i,s.next=i,i.prev=s,i}function lE(n,e,t,i){const r=new _A(n,e,t);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Ac(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function _A(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function UT(n,e,t,i){let r=0;for(let s=e,o=t-i;s<t;s+=i)r+=(n[o]-n[s])*(n[s+1]+n[o+1]),o=s;return r}class Ji{static area(e){const t=e.length;let i=0;for(let r=t-1,s=0;s<t;r=s++)i+=e[r].x*e[s].y-e[s].x*e[r].y;return i*.5}static isClockWise(e){return Ji.area(e)<0}static triangulateShape(e,t){const i=[],r=[],s=[];cE(e),hE(i,e);let o=e.length;t.forEach(cE);for(let l=0;l<t.length;l++)r.push(o),o+=t[l].length,hE(i,t[l]);const a=ET.triangulate(i,r);for(let l=0;l<a.length;l+=3)s.push(a.slice(l,l+3));return s}}function cE(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function hE(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class If extends yt{constructor(e=new Mo([new Ne(.5,.5),new Ne(-.5,.5),new Ne(-.5,-.5),new Ne(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const i=this,r=[],s=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new et(r,3)),this.setAttribute("uv",new et(s,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,h=t.steps!==void 0?t.steps:1,u=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:.2,A=t.bevelSize!==void 0?t.bevelSize:f-.1,g=t.bevelOffset!==void 0?t.bevelOffset:0,m=t.bevelSegments!==void 0?t.bevelSegments:3;const p=t.extrudePath,v=t.UVGenerator!==void 0?t.UVGenerator:FT;let E,x=!1,M,w,S,B;p&&(E=p.getSpacedPoints(h),x=!0,d=!1,M=p.computeFrenetFrames(h,!1),w=new Y,S=new Y,B=new Y),d||(m=0,f=0,A=0,g=0);const y=a.extractPoints(c);let _=y.shape;const L=y.holes;if(!Ji.isClockWise(_)){_=_.reverse();for(let me=0,Ae=L.length;me<Ae;me++){const V=L[me];Ji.isClockWise(V)&&(L[me]=V.reverse())}}const O=Ji.triangulateShape(_,L),X=_;for(let me=0,Ae=L.length;me<Ae;me++){const V=L[me];_=_.concat(V)}function te(me,Ae,V){return Ae||console.error("THREE.ExtrudeGeometry: vec does not exist"),me.clone().addScaledVector(Ae,V)}const W=_.length,Z=O.length;function q(me,Ae,V){let j,Te,Re;const b=me.x-Ae.x,I=me.y-Ae.y,U=V.x-me.x,R=V.y-me.y,T=b*b+I*I,G=b*R-I*U;if(Math.abs(G)>Number.EPSILON){const J=Math.sqrt(T),de=Math.sqrt(U*U+R*R),N=Ae.x-I/J,P=Ae.y+b/J,$=V.x-R/de,se=V.y+U/de,ve=(($-N)*R-(se-P)*U)/(b*R-I*U);j=N+b*ve-me.x,Te=P+I*ve-me.y;const ie=j*j+Te*Te;if(ie<=2)return new Ne(j,Te);Re=Math.sqrt(ie/2)}else{let J=!1;b>Number.EPSILON?U>Number.EPSILON&&(J=!0):b<-Number.EPSILON?U<-Number.EPSILON&&(J=!0):Math.sign(I)===Math.sign(R)&&(J=!0),J?(j=-I,Te=b,Re=Math.sqrt(T)):(j=b,Te=I,Re=Math.sqrt(T/2))}return new Ne(j/Re,Te/Re)}const re=[];for(let me=0,Ae=X.length,V=Ae-1,j=me+1;me<Ae;me++,V++,j++)V===Ae&&(V=0),j===Ae&&(j=0),re[me]=q(X[me],X[V],X[j]);const ue=[];let _e,Be=re.concat();for(let me=0,Ae=L.length;me<Ae;me++){const V=L[me];_e=[];for(let j=0,Te=V.length,Re=Te-1,b=j+1;j<Te;j++,Re++,b++)Re===Te&&(Re=0),b===Te&&(b=0),_e[j]=q(V[j],V[Re],V[b]);ue.push(_e),Be=Be.concat(_e)}for(let me=0;me<m;me++){const Ae=me/m,V=f*Math.cos(Ae*Math.PI/2),j=A*Math.sin(Ae*Math.PI/2)+g;for(let Te=0,Re=X.length;Te<Re;Te++){const b=te(X[Te],re[Te],j);pe(b.x,b.y,-V)}for(let Te=0,Re=L.length;Te<Re;Te++){const b=L[Te];_e=ue[Te];for(let I=0,U=b.length;I<U;I++){const R=te(b[I],_e[I],j);pe(R.x,R.y,-V)}}}const ze=A+g;for(let me=0;me<W;me++){const Ae=d?te(_[me],Be[me],ze):_[me];x?(S.copy(M.normals[0]).multiplyScalar(Ae.x),w.copy(M.binormals[0]).multiplyScalar(Ae.y),B.copy(E[0]).add(S).add(w),pe(B.x,B.y,B.z)):pe(Ae.x,Ae.y,0)}for(let me=1;me<=h;me++)for(let Ae=0;Ae<W;Ae++){const V=d?te(_[Ae],Be[Ae],ze):_[Ae];x?(S.copy(M.normals[me]).multiplyScalar(V.x),w.copy(M.binormals[me]).multiplyScalar(V.y),B.copy(E[me]).add(S).add(w),pe(B.x,B.y,B.z)):pe(V.x,V.y,u/h*me)}for(let me=m-1;me>=0;me--){const Ae=me/m,V=f*Math.cos(Ae*Math.PI/2),j=A*Math.sin(Ae*Math.PI/2)+g;for(let Te=0,Re=X.length;Te<Re;Te++){const b=te(X[Te],re[Te],j);pe(b.x,b.y,u+V)}for(let Te=0,Re=L.length;Te<Re;Te++){const b=L[Te];_e=ue[Te];for(let I=0,U=b.length;I<U;I++){const R=te(b[I],_e[I],j);x?pe(R.x,R.y+E[h-1].y,E[h-1].x+V):pe(R.x,R.y,u+V)}}}le(),Ee();function le(){const me=r.length/3;if(d){let Ae=0,V=W*Ae;for(let j=0;j<Z;j++){const Te=O[j];oe(Te[2]+V,Te[1]+V,Te[0]+V)}Ae=h+m*2,V=W*Ae;for(let j=0;j<Z;j++){const Te=O[j];oe(Te[0]+V,Te[1]+V,Te[2]+V)}}else{for(let Ae=0;Ae<Z;Ae++){const V=O[Ae];oe(V[2],V[1],V[0])}for(let Ae=0;Ae<Z;Ae++){const V=O[Ae];oe(V[0]+W*h,V[1]+W*h,V[2]+W*h)}}i.addGroup(me,r.length/3-me,0)}function Ee(){const me=r.length/3;let Ae=0;Ue(X,Ae),Ae+=X.length;for(let V=0,j=L.length;V<j;V++){const Te=L[V];Ue(Te,Ae),Ae+=Te.length}i.addGroup(me,r.length/3-me,1)}function Ue(me,Ae){let V=me.length;for(;--V>=0;){const j=V;let Te=V-1;Te<0&&(Te=me.length-1);for(let Re=0,b=h+m*2;Re<b;Re++){const I=W*Re,U=W*(Re+1),R=Ae+j+I,T=Ae+Te+I,G=Ae+Te+U,J=Ae+j+U;we(R,T,G,J)}}}function pe(me,Ae,V){l.push(me),l.push(Ae),l.push(V)}function oe(me,Ae,V){Me(me),Me(Ae),Me(V);const j=r.length/3,Te=v.generateTopUV(i,r,j-3,j-2,j-1);Ve(Te[0]),Ve(Te[1]),Ve(Te[2])}function we(me,Ae,V,j){Me(me),Me(Ae),Me(j),Me(Ae),Me(V),Me(j);const Te=r.length/3,Re=v.generateSideWallUV(i,r,Te-6,Te-3,Te-2,Te-1);Ve(Re[0]),Ve(Re[1]),Ve(Re[3]),Ve(Re[1]),Ve(Re[2]),Ve(Re[3])}function Me(me){r.push(l[me*3+0]),r.push(l[me*3+1]),r.push(l[me*3+2])}function Ve(me){s.push(me.x),s.push(me.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,i=this.parameters.options;return NT(t,i,e)}static fromJSON(e,t){const i=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=t[e.shapes[s]];i.push(a)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new Od[r.type]().fromJSON(r)),new If(i,e.options)}}const FT={generateTopUV:function(n,e,t,i,r){const s=e[t*3],o=e[t*3+1],a=e[i*3],l=e[i*3+1],c=e[r*3],h=e[r*3+1];return[new Ne(s,o),new Ne(a,l),new Ne(c,h)]},generateSideWallUV:function(n,e,t,i,r,s){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[i*3],h=e[i*3+1],u=e[i*3+2],d=e[r*3],f=e[r*3+1],A=e[r*3+2],g=e[s*3],m=e[s*3+1],p=e[s*3+2];return Math.abs(a-h)<Math.abs(o-c)?[new Ne(o,1-l),new Ne(c,1-u),new Ne(d,1-A),new Ne(g,1-p)]:[new Ne(a,1-l),new Ne(h,1-u),new Ne(f,1-A),new Ne(m,1-p)]}};function NT(n,e,t){if(t.shapes=[],Array.isArray(n))for(let i=0,r=n.length;i<r;i++){const s=n[i];t.shapes.push(s.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Rf extends Bs{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(r,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Rf(e.radius,e.detail)}}class Oc extends Bs{constructor(e=1,t=0){const i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],r=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,r,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Oc(e.radius,e.detail)}}let Bf=class RC extends yt{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(i),l=Math.floor(r),c=a+1,h=l+1,u=e/a,d=t/l,f=[],A=[],g=[],m=[];for(let p=0;p<h;p++){const v=p*d-o;for(let E=0;E<c;E++){const x=E*u-s;A.push(x,-v,0),g.push(0,0,1),m.push(E/a),m.push(1-p/l)}}for(let p=0;p<l;p++)for(let v=0;v<a;v++){const E=v+c*p,x=v+c*(p+1),M=v+1+c*(p+1),w=v+1+c*p;f.push(E,x,w),f.push(x,M,w)}this.setIndex(f),this.setAttribute("position",new et(A,3)),this.setAttribute("normal",new et(g,3)),this.setAttribute("uv",new et(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new RC(e.width,e.height,e.widthSegments,e.heightSegments)}};class Lf extends yt{constructor(e=.5,t=1,i=32,r=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:i,phiSegments:r,thetaStart:s,thetaLength:o},i=Math.max(3,i),r=Math.max(1,r);const a=[],l=[],c=[],h=[];let u=e;const d=(t-e)/r,f=new Y,A=new Ne;for(let g=0;g<=r;g++){for(let m=0;m<=i;m++){const p=s+m/i*o;f.x=u*Math.cos(p),f.y=u*Math.sin(p),l.push(f.x,f.y,f.z),c.push(0,0,1),A.x=(f.x/t+1)/2,A.y=(f.y/t+1)/2,h.push(A.x,A.y)}u+=d}for(let g=0;g<r;g++){const m=g*(i+1);for(let p=0;p<i;p++){const v=p+m,E=v,x=v+i+1,M=v+i+2,w=v+1;a.push(E,x,w),a.push(x,M,w)}}this.setIndex(a),this.setAttribute("position",new et(l,3)),this.setAttribute("normal",new et(c,3)),this.setAttribute("uv",new et(h,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Lf(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class Df extends yt{constructor(e=new Mo([new Ne(0,.5),new Ne(-.5,-.5),new Ne(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const i=[],r=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let h=0;h<e.length;h++)c(e[h]),this.addGroup(a,l,h),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new et(r,3)),this.setAttribute("normal",new et(s,3)),this.setAttribute("uv",new et(o,2));function c(h){const u=r.length/3,d=h.extractPoints(t);let f=d.shape;const A=d.holes;Ji.isClockWise(f)===!1&&(f=f.reverse());for(let m=0,p=A.length;m<p;m++){const v=A[m];Ji.isClockWise(v)===!0&&(A[m]=v.reverse())}const g=Ji.triangulateShape(f,A);for(let m=0,p=A.length;m<p;m++){const v=A[m];f=f.concat(v)}for(let m=0,p=f.length;m<p;m++){const v=f[m];r.push(v.x,v.y,0),s.push(0,0,1),o.push(v.x,v.y)}for(let m=0,p=g.length;m<p;m++){const v=g[m],E=v[0]+u,x=v[1]+u,M=v[2]+u;i.push(E,x,M),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return OT(t,e)}static fromJSON(e,t){const i=[];for(let r=0,s=e.shapes.length;r<s;r++){const o=t[e.shapes[r]];i.push(o)}return new Df(i,e.curveSegments)}}function OT(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,i=n.length;t<i;t++){const r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}class kc extends yt{constructor(e=1,t=32,i=16,r=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:r,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const l=Math.min(o+a,Math.PI);let c=0;const h=[],u=new Y,d=new Y,f=[],A=[],g=[],m=[];for(let p=0;p<=i;p++){const v=[],E=p/i;let x=0;p===0&&o===0?x=.5/t:p===i&&l===Math.PI&&(x=-.5/t);for(let M=0;M<=t;M++){const w=M/t;u.x=-e*Math.cos(r+w*s)*Math.sin(o+E*a),u.y=e*Math.cos(o+E*a),u.z=e*Math.sin(r+w*s)*Math.sin(o+E*a),A.push(u.x,u.y,u.z),d.copy(u).normalize(),g.push(d.x,d.y,d.z),m.push(w+x,1-E),v.push(c++)}h.push(v)}for(let p=0;p<i;p++)for(let v=0;v<t;v++){const E=h[p][v+1],x=h[p][v],M=h[p+1][v],w=h[p+1][v+1];(p!==0||o>0)&&f.push(E,x,w),(p!==i-1||l<Math.PI)&&f.push(x,M,w)}this.setIndex(f),this.setAttribute("position",new et(A,3)),this.setAttribute("normal",new et(g,3)),this.setAttribute("uv",new et(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new kc(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class Pf extends Bs{constructor(e=1,t=0){const i=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],r=[2,1,0,0,3,2,1,3,0,2,3,1];super(i,r,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Pf(e.radius,e.detail)}}class Uf extends yt{constructor(e=1,t=.4,i=12,r=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:r,arc:s},i=Math.floor(i),r=Math.floor(r);const o=[],a=[],l=[],c=[],h=new Y,u=new Y,d=new Y;for(let f=0;f<=i;f++)for(let A=0;A<=r;A++){const g=A/r*s,m=f/i*Math.PI*2;u.x=(e+t*Math.cos(m))*Math.cos(g),u.y=(e+t*Math.cos(m))*Math.sin(g),u.z=t*Math.sin(m),a.push(u.x,u.y,u.z),h.x=e*Math.cos(g),h.y=e*Math.sin(g),d.subVectors(u,h).normalize(),l.push(d.x,d.y,d.z),c.push(A/r),c.push(f/i)}for(let f=1;f<=i;f++)for(let A=1;A<=r;A++){const g=(r+1)*f+A-1,m=(r+1)*(f-1)+A-1,p=(r+1)*(f-1)+A,v=(r+1)*f+A;o.push(g,m,v),o.push(m,p,v)}this.setIndex(o),this.setAttribute("position",new et(a,3)),this.setAttribute("normal",new et(l,3)),this.setAttribute("uv",new et(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Uf(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Ff extends yt{constructor(e=1,t=.4,i=64,r=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:i,radialSegments:r,p:s,q:o},i=Math.floor(i),r=Math.floor(r);const a=[],l=[],c=[],h=[],u=new Y,d=new Y,f=new Y,A=new Y,g=new Y,m=new Y,p=new Y;for(let E=0;E<=i;++E){const x=E/i*s*Math.PI*2;v(x,s,o,e,f),v(x+.01,s,o,e,A),m.subVectors(A,f),p.addVectors(A,f),g.crossVectors(m,p),p.crossVectors(g,m),g.normalize(),p.normalize();for(let M=0;M<=r;++M){const w=M/r*Math.PI*2,S=-t*Math.cos(w),B=t*Math.sin(w);u.x=f.x+(S*p.x+B*g.x),u.y=f.y+(S*p.y+B*g.y),u.z=f.z+(S*p.z+B*g.z),l.push(u.x,u.y,u.z),d.subVectors(u,f).normalize(),c.push(d.x,d.y,d.z),h.push(E/i),h.push(M/r)}}for(let E=1;E<=i;E++)for(let x=1;x<=r;x++){const M=(r+1)*(E-1)+(x-1),w=(r+1)*E+(x-1),S=(r+1)*E+x,B=(r+1)*(E-1)+x;a.push(M,w,B),a.push(w,S,B)}this.setIndex(a),this.setAttribute("position",new et(l,3)),this.setAttribute("normal",new et(c,3)),this.setAttribute("uv",new et(h,2));function v(E,x,M,w,S){const B=Math.cos(E),y=Math.sin(E),_=M/x*E,L=Math.cos(_);S.x=w*(2+L)*.5*B,S.y=w*(2+L)*y*.5,S.z=w*Math.sin(_)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ff(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Nf extends yt{constructor(e=new g0(new Y(-1,-1,0),new Y(-1,1,0),new Y(1,1,0)),t=64,i=1,r=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:i,radialSegments:r,closed:s};const o=e.computeFrenetFrames(t,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new Y,l=new Y,c=new Ne;let h=new Y;const u=[],d=[],f=[],A=[];g(),this.setIndex(A),this.setAttribute("position",new et(u,3)),this.setAttribute("normal",new et(d,3)),this.setAttribute("uv",new et(f,2));function g(){for(let E=0;E<t;E++)m(E);m(s===!1?t:0),v(),p()}function m(E){h=e.getPointAt(E/t,h);const x=o.normals[E],M=o.binormals[E];for(let w=0;w<=r;w++){const S=w/r*Math.PI*2,B=Math.sin(S),y=-Math.cos(S);l.x=y*x.x+B*M.x,l.y=y*x.y+B*M.y,l.z=y*x.z+B*M.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=h.x+i*l.x,a.y=h.y+i*l.y,a.z=h.z+i*l.z,u.push(a.x,a.y,a.z)}}function p(){for(let E=1;E<=t;E++)for(let x=1;x<=r;x++){const M=(r+1)*(E-1)+(x-1),w=(r+1)*E+(x-1),S=(r+1)*E+x,B=(r+1)*(E-1)+x;A.push(M,w,B),A.push(w,S,B)}}function v(){for(let E=0;E<=t;E++)for(let x=0;x<=r;x++)c.x=E/t,c.y=x/r,f.push(c.x,c.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Nf(new Od[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class BC extends yt{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],i=new Set,r=new Y,s=new Y;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,h=l.length;c<h;++c){const u=l[c],d=u.start,f=u.count;for(let A=d,g=d+f;A<g;A+=3)for(let m=0;m<3;m++){const p=a.getX(A+m),v=a.getX(A+(m+1)%3);r.fromBufferAttribute(o,p),s.fromBufferAttribute(o,v),uE(r,s,i)===!0&&(t.push(r.x,r.y,r.z),t.push(s.x,s.y,s.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const h=3*a+c,u=3*a+(c+1)%3;r.fromBufferAttribute(o,h),s.fromBufferAttribute(o,u),uE(r,s,i)===!0&&(t.push(r.x,r.y,r.z),t.push(s.x,s.y,s.z))}}this.setAttribute("position",new et(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function uE(n,e,t){const i=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(i)===!0||t.has(r)===!0?!1:(t.add(i),t.add(r),!0)}var dE=Object.freeze({__proto__:null,BoxGeometry:Pc,CapsuleGeometry:Cf,CircleGeometry:Mf,ConeGeometry:Sf,CylinderGeometry:sl,DodecahedronGeometry:wf,EdgesGeometry:SC,ExtrudeGeometry:If,IcosahedronGeometry:Rf,LatheGeometry:Nc,OctahedronGeometry:Oc,PlaneGeometry:Bf,PolyhedronGeometry:Bs,RingGeometry:Lf,ShapeGeometry:Df,SphereGeometry:kc,TetrahedronGeometry:Pf,TorusGeometry:Uf,TorusKnotGeometry:Ff,TubeGeometry:Nf,WireframeGeometry:BC});class LC extends Tn{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Ke(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class DC extends Ni{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class E0 extends Tn{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Ke(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Is,this.normalScale=new Ne(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Fi,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class PC extends E0{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ne(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return pt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Ke(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Ke(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ke(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class UC extends Tn{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Ke(16777215),this.specular=new Ke(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Is,this.normalScale=new Ne(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Fi,this.combine=Bc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class FC extends Tn{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ke(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Is,this.normalScale=new Ne(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class NC extends Tn{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Is,this.normalScale=new Ne(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class OC extends Tn{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Ke(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ke(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Is,this.normalScale=new Ne(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Fi,this.combine=Bc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}let x0=class extends Tn{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Gb,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}},y0=class extends Tn{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}};class kC extends Tn{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ke(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Is,this.normalScale=new Ne(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class GC extends Hn{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function xo(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function zC(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function HC(n){function e(r,s){return n[r]-n[s]}const t=n.length,i=new Array(t);for(let r=0;r!==t;++r)i[r]=r;return i.sort(e),i}function bA(n,e,t){const i=n.length,r=new n.constructor(i);for(let s=0,o=0;o!==i;++s){const a=t[s]*e;for(let l=0;l!==e;++l)r[o++]=n[a+l]}return r}function _0(n,e,t,i){let r=1,s=n[0];for(;s!==void 0&&s[i]===void 0;)s=n[r++];if(s===void 0)return;let o=s[i];if(o!==void 0)if(Array.isArray(o))do o=s[i],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=n[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[i],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=n[r++];while(s!==void 0);else do o=s[i],o!==void 0&&(e.push(s.time),t.push(o)),s=n[r++];while(s!==void 0)}function kT(n,e,t,i,r=30){const s=n.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],h=c.getValueSize(),u=[],d=[];for(let f=0;f<c.times.length;++f){const A=c.times[f]*r;if(!(A<t||A>=i)){u.push(c.times[f]);for(let g=0;g<h;++g)d.push(c.values[f*h+g])}}u.length!==0&&(c.times=xo(u,c.times.constructor),c.values=xo(d,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s}function GT(n,e=0,t=n,i=30){i<=0&&(i=30);const r=t.tracks.length,s=e/i;for(let o=0;o<r;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(p){return p.name===a.name&&p.ValueTypeName===l});if(c===void 0)continue;let h=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=u/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const A=a.times.length-1;let g;if(s<=a.times[0]){const p=h,v=u-h;g=a.values.slice(p,v)}else if(s>=a.times[A]){const p=A*u+h,v=p+u-h;g=a.values.slice(p,v)}else{const p=a.createInterpolant(),v=h,E=u-h;p.evaluate(s),g=p.resultBuffer.slice(v,E)}l==="quaternion"&&new Yn().fromArray(g).normalize().conjugate().toArray(g);const m=c.times.length;for(let p=0;p<m;++p){const v=p*f+d;if(l==="quaternion")Yn.multiplyQuaternionsFlat(c.values,v,g,0,c.values,v);else{const E=f-d*2;for(let x=0;x<E;++x)c.values[v+x]-=g[x]}}}return n.blendMode=r0,n}const zT={convertArray:xo,isTypedArray:zC,getKeyframeOrder:HC,sortedArray:bA,flattenJSON:_0,subclip:kT,makeClipAdditive:GT};class Gc{constructor(e,t,i,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,r=t[i],s=t[i-1];e:{t:{let o;n:{i:if(!(e<r)){for(let a=i+2;;){if(r===void 0){if(e<s)break i;return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(s=r,r=t[++i],e<r)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(i=2,s=a);for(let l=i-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(r=s,s=t[--i-1],e>=s)break t}o=i,i=0;break n}break e}for(;i<o;){const a=i+o>>>1;e<t[a]?o=a:i=a+1}if(r=t[i],s=t[i-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===void 0)return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,s,r)}return this.interpolate_(i,s,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r;for(let o=0;o!==r;++o)t[o]=i[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class VC extends Gc{constructor(e,t,i,r){super(e,t,i,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:go,endingEnd:go}}intervalChanged_(e,t,i){const r=this.parameterPositions;let s=e-2,o=e+1,a=r[s],l=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case vo:s=e,a=2*t-i;break;case lc:s=r.length-2,a=t+r[s]-r[s+1];break;default:s=e,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case vo:o=e,l=2*i-t;break;case lc:o=1,l=i+r[1]-r[0];break;default:o=e-1,l=t}const c=(i-t)*.5,h=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-i),this._offsetPrev=s*h,this._offsetNext=o*h}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,h=this._offsetPrev,u=this._offsetNext,d=this._weightPrev,f=this._weightNext,A=(i-t)/(r-t),g=A*A,m=g*A,p=-d*m+2*d*g-d*A,v=(1+d)*m+(-1.5-2*d)*g+(-.5+d)*A+1,E=(-1-f)*m+(1.5+f)*g+.5*A,x=f*m-f*g;for(let M=0;M!==a;++M)s[M]=p*o[h+M]+v*o[c+M]+E*o[l+M]+x*o[u+M];return s}}class b0 extends Gc{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,h=(i-t)/(r-t),u=1-h;for(let d=0;d!==a;++d)s[d]=o[c+d]*u+o[l+d]*h;return s}}class QC extends Gc{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class Gi{constructor(e,t,i,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=xo(t,this.TimeBufferType),this.values=xo(i,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let i;if(t.toJSON!==this.toJSON)i=t.toJSON(e);else{i={name:e.name,times:xo(e.times,Array),values:xo(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(i.interpolation=r)}return i.type=e.ValueTypeName,i}InterpolantFactoryMethodDiscrete(e){return new QC(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new b0(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new VC(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case ac:t=this.InterpolantFactoryMethodDiscrete;break;case Ud:t=this.InterpolantFactoryMethodLinear;break;case Uu:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ac;case this.InterpolantFactoryMethodLinear:return Ud;case this.InterpolantFactoryMethodSmooth:return Uu}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]*=e}return this}trim(e,t){const i=this.times,r=i.length;let s=0,o=r-1;for(;s!==r&&i[s]<e;)++s;for(;o!==-1&&i[o]>t;)--o;if(++o,s!==0||o!==r){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=i.slice(s,o),this.values=this.values.slice(s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const i=this.times,r=this.values,s=i.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(r!==void 0&&zC(r))for(let a=0,l=r.length;a!==l;++a){const c=r[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),i=this.getValueSize(),r=this.getInterpolation()===Uu,s=e.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const c=e[a],h=e[a+1];if(c!==h&&(a!==1||c!==e[0]))if(r)l=!0;else{const u=a*i,d=u-i,f=u+i;for(let A=0;A!==i;++A){const g=t[u+A];if(g!==t[d+A]||g!==t[f+A]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const u=a*i,d=o*i;for(let f=0;f!==i;++f)t[d+f]=t[u+f]}++o}}if(s>0){e[o]=e[s];for(let a=s*i,l=o*i,c=0;c!==i;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*i)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),i=this.constructor,r=new i(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}Gi.prototype.TimeBufferType=Float32Array;Gi.prototype.ValueBufferType=Float32Array;Gi.prototype.DefaultInterpolation=Ud;class Po extends Gi{constructor(e,t,i){super(e,t,i)}}Po.prototype.ValueTypeName="bool";Po.prototype.ValueBufferType=Array;Po.prototype.DefaultInterpolation=ac;Po.prototype.InterpolantFactoryMethodLinear=void 0;Po.prototype.InterpolantFactoryMethodSmooth=void 0;class C0 extends Gi{}C0.prototype.ValueTypeName="color";class gc extends Gi{}gc.prototype.ValueTypeName="number";class WC extends Gc{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(i-t)/(r-t);let c=e*a;for(let h=c+a;c!==h;c+=4)Yn.slerpFlat(s,0,o,c-a,o,c,l);return s}}class zc extends Gi{InterpolantFactoryMethodLinear(e){return new WC(this.times,this.values,this.getValueSize(),e)}}zc.prototype.ValueTypeName="quaternion";zc.prototype.InterpolantFactoryMethodSmooth=void 0;class Uo extends Gi{constructor(e,t,i){super(e,t,i)}}Uo.prototype.ValueTypeName="string";Uo.prototype.ValueBufferType=Array;Uo.prototype.DefaultInterpolation=ac;Uo.prototype.InterpolantFactoryMethodLinear=void 0;Uo.prototype.InterpolantFactoryMethodSmooth=void 0;class vc extends Gi{}vc.prototype.ValueTypeName="vector";class Ec{constructor(e="",t=-1,i=[],r=ff){this.name=e,this.tracks=i,this.duration=t,this.blendMode=r,this.uuid=ii(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],i=e.tracks,r=1/(e.fps||1);for(let o=0,a=i.length;o!==a;++o)t.push(VT(i[o]).scale(r));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],i=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=i.length;s!==o;++s)t.push(Gi.toJSON(i[s]));return r}static CreateFromMorphTargetSequence(e,t,i,r){const s=t.length,o=[];for(let a=0;a<s;a++){let l=[],c=[];l.push((a+s-1)%s,a,(a+1)%s),c.push(0,1,0);const h=HC(l);l=bA(l,1,h),c=bA(c,1,h),!r&&l[0]===0&&(l.push(s),c.push(c[0])),o.push(new gc(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/i))}return new this(e,-1,o)}static findByName(e,t){let i=e;if(!Array.isArray(e)){const r=e;i=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<i.length;r++)if(i[r].name===t)return i[r];return null}static CreateClipsFromMorphTargetSequences(e,t,i){const r={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],h=c.name.match(s);if(h&&h.length>1){const u=h[1];let d=r[u];d||(r[u]=d=[]),d.push(c)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],t,i));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(u,d,f,A,g){if(f.length!==0){const m=[],p=[];_0(f,m,p,A),m.length!==0&&g.push(new u(d,m,p))}},r=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let u=0;u<c.length;u++){const d=c[u].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let A;for(A=0;A<d.length;A++)if(d[A].morphTargets)for(let g=0;g<d[A].morphTargets.length;g++)f[d[A].morphTargets[g]]=-1;for(const g in f){const m=[],p=[];for(let v=0;v!==d[A].morphTargets.length;++v){const E=d[A];m.push(E.time),p.push(E.morphTarget===g?1:0)}r.push(new gc(".morphTargetInfluence["+g+"]",m,p))}l=f.length*o}else{const f=".bones["+t[u].name+"]";i(vc,f+".position",d,"pos",r),i(zc,f+".quaternion",d,"rot",r),i(vc,f+".scale",d,"scl",r)}}return r.length===0?null:new this(s,l,r,a)}resetDuration(){const e=this.tracks;let t=0;for(let i=0,r=e.length;i!==r;++i){const s=this.tracks[i];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function HT(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return gc;case"vector":case"vector2":case"vector3":case"vector4":return vc;case"color":return C0;case"quaternion":return zc;case"bool":case"boolean":return Po;case"string":return Uo}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function VT(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=HT(n.type);if(n.times===void 0){const t=[],i=[];_0(n.keys,t,i,"value"),n.times=t,n.values=i}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const Mr={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class M0{constructor(e,t,i){const r=this;let s=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.itemStart=function(h){a++,s===!1&&r.onStart!==void 0&&r.onStart(h,o,a),s=!0},this.itemEnd=function(h){o++,r.onProgress!==void 0&&r.onProgress(h,o,a),o===a&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(h){r.onError!==void 0&&r.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,u){return c.push(h,u),this},this.removeHandler=function(h){const u=c.indexOf(h);return u!==-1&&c.splice(u,2),this},this.getHandler=function(h){for(let u=0,d=c.length;u<d;u+=2){const f=c[u],A=c[u+1];if(f.global&&(f.lastIndex=0),f.test(h))return A}return null}}}const XC=new M0;class $n{constructor(e){this.manager=e!==void 0?e:XC,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const i=this;return new Promise(function(r,s){i.load(e,r,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}$n.DEFAULT_MATERIAL_NAME="__DEFAULT";const cr={};class QT extends Error{constructor(e,t){super(e),this.response=t}}class zr extends $n{constructor(e){super(e)}load(e,t,i,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Mr.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(cr[e]!==void 0){cr[e].push({onLoad:t,onProgress:i,onError:r});return}cr[e]=[],cr[e].push({onLoad:t,onProgress:i,onError:r});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const h=cr[e],u=c.body.getReader(),d=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),f=d?parseInt(d):0,A=f!==0;let g=0;const m=new ReadableStream({start(p){v();function v(){u.read().then(({done:E,value:x})=>{if(E)p.close();else{g+=x.byteLength;const M=new ProgressEvent("progress",{lengthComputable:A,loaded:g,total:f});for(let w=0,S=h.length;w<S;w++){const B=h[w];B.onProgress&&B.onProgress(M)}p.enqueue(x),v()}},E=>{p.error(E)})}}});return new Response(m)}else throw new QT(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(h=>new DOMParser().parseFromString(h,a));case"json":return c.json();default:if(a===void 0)return c.text();{const u=/charset="?([^;"\s]*)"?/i.exec(a),d=u&&u[1]?u[1].toLowerCase():void 0,f=new TextDecoder(d);return c.arrayBuffer().then(A=>f.decode(A))}}}).then(c=>{Mr.add(e,c);const h=cr[e];delete cr[e];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onLoad&&f.onLoad(c)}}).catch(c=>{const h=cr[e];if(h===void 0)throw this.manager.itemError(e),c;delete cr[e];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onError&&f.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class WT extends $n{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new zr(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}parse(e){const t=[];for(let i=0;i<e.length;i++){const r=Ec.parse(e[i]);t.push(r)}return t}}class XT extends $n{constructor(e){super(e)}load(e,t,i,r){const s=this,o=[],a=new _f,l=new zr(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(s.withCredentials);let c=0;function h(u){l.load(e[u],function(d){const f=s.parse(d,!0);o[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,c===6&&(f.mipmapCount===1&&(a.minFilter=ln),a.image=o,a.format=f.format,a.needsUpdate=!0,t&&t(a))},i,r)}if(Array.isArray(e))for(let u=0,d=e.length;u<d;++u)h(u);else l.load(e,function(u){const d=s.parse(u,!0);if(d.isCubemap){const f=d.mipmaps.length/d.mipmapCount;for(let A=0;A<f;A++){o[A]={mipmaps:[]};for(let g=0;g<d.mipmapCount;g++)o[A].mipmaps.push(d.mipmaps[A*d.mipmapCount+g]),o[A].format=d.format,o[A].width=d.width,o[A].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=ln),a.format=d.format,a.needsUpdate=!0,t&&t(a)},i,r);return a}}class xc extends $n{constructor(e){super(e)}load(e,t,i,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Mr.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=dc("img");function l(){h(),Mr.add(e,this),t&&t(this),s.manager.itemEnd(e)}function c(u){h(),r&&r(u),s.manager.itemError(e),s.manager.itemEnd(e)}function h(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class qT extends $n{constructor(e){super(e)}load(e,t,i,r){const s=new Uc;s.colorSpace=Xn;const o=new xc(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(h){s.images[c]=h,a++,a===6&&(s.needsUpdate=!0,t&&t(s))},void 0,r)}for(let c=0;c<e.length;++c)l(c);return s}}class YT extends $n{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new Ki,a=new zr(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(s.withCredentials),a.load(e,function(l){let c;try{c=s.parse(l)}catch(h){if(r!==void 0)r(h);else{console.error(h);return}}c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:mi,o.wrapT=c.wrapT!==void 0?c.wrapT:mi,o.magFilter=c.magFilter!==void 0?c.magFilter:ln,o.minFilter=c.minFilter!==void 0?c.minFilter:ln,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0&&(o.colorSpace=c.colorSpace),c.flipY!==void 0&&(o.flipY=c.flipY),c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=Yi),c.mipmapCount===1&&(o.minFilter=ln),c.generateMipmaps!==void 0&&(o.generateMipmaps=c.generateMipmaps),o.needsUpdate=!0,t&&t(o,c)},i,r),o}}class jT extends $n{constructor(e){super(e)}load(e,t,i,r){const s=new mn,o=new xc(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},i,r),s}}class Ls extends Ft{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Ke(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}class qC extends Ls{constructor(e,t,i){super(e,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Ft.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Ke(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Lp=new ct,fE=new Y,pE=new Y;class S0{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ne(512,512),this.map=null,this.mapPass=null,this.matrix=new ct,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Fc,this._frameExtents=new Ne(1,1),this._viewportCount=1,this._viewports=[new Dt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,i=this.matrix;fE.setFromMatrixPosition(e.matrixWorld),t.position.copy(fE),pE.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(pE),t.updateMatrixWorld(),Lp.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Lp),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Lp)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class $T extends S0{constructor(){super(new gn(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,i=qa*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(i!==t.fov||r!==t.aspect||s!==t.far)&&(t.fov=i,t.aspect=r,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class YC extends Ls{constructor(e,t,i=0,r=Math.PI/3,s=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Ft.DEFAULT_UP),this.updateMatrix(),this.target=new Ft,this.distance=i,this.angle=r,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new $T}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const mE=new ct,_l=new Y,Dp=new Y;class KT extends S0{constructor(){super(new gn(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ne(4,2),this._viewportCount=6,this._viewports=[new Dt(2,1,1,1),new Dt(0,1,1,1),new Dt(3,1,1,1),new Dt(1,1,1,1),new Dt(3,0,1,1),new Dt(1,0,1,1)],this._cubeDirections=[new Y(1,0,0),new Y(-1,0,0),new Y(0,0,1),new Y(0,0,-1),new Y(0,1,0),new Y(0,-1,0)],this._cubeUps=[new Y(0,1,0),new Y(0,1,0),new Y(0,1,0),new Y(0,1,0),new Y(0,0,1),new Y(0,0,-1)]}updateMatrices(e,t=0){const i=this.camera,r=this.matrix,s=e.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),_l.setFromMatrixPosition(e.matrixWorld),i.position.copy(_l),Dp.copy(i.position),Dp.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(Dp),i.updateMatrixWorld(),r.makeTranslation(-_l.x,-_l.y,-_l.z),mE.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(mE)}}class jC extends Ls{constructor(e,t,i=0,r=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=r,this.shadow=new KT}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}let Of=class extends gf{constructor(e=-1,t=1,i=1,r=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=i-e,o=i+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}};class JT extends S0{constructor(){super(new Of(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class $C extends Ls{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Ft.DEFAULT_UP),this.updateMatrix(),this.target=new Ft,this.shadow=new JT}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class KC extends Ls{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class JC extends Ls{constructor(e,t,i=10,r=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class ZC{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Y)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*i),t.addScaledVector(o[4],1.092548*(i*r)),t.addScaledVector(o[5],1.092548*(r*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(i*s)),t.addScaledVector(o[8],.546274*(i*i-r*r)),t}getIrradianceAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*i),t.addScaledVector(o[4],2*.429043*i*r),t.addScaledVector(o[5],2*.429043*r*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*i*s),t.addScaledVector(o[8],.429043*(i*i-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const i=e.x,r=e.y,s=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*s,t[3]=.488603*i,t[4]=1.092548*i*r,t[5]=1.092548*r*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*i*s,t[8]=.546274*(i*i-r*r)}}class eM extends Ls{constructor(e=new ZC,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class kf extends $n{constructor(e){super(e),this.textures={}}load(e,t,i,r){const s=this,o=new zr(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}parse(e){const t=this.textures;function i(s){return t[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),t[s]}const r=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(r.uuid=e.uuid),e.name!==void 0&&(r.name=e.name),e.color!==void 0&&r.color!==void 0&&r.color.setHex(e.color),e.roughness!==void 0&&(r.roughness=e.roughness),e.metalness!==void 0&&(r.metalness=e.metalness),e.sheen!==void 0&&(r.sheen=e.sheen),e.sheenColor!==void 0&&(r.sheenColor=new Ke().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(r.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(e.emissive),e.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(e.specular),e.specularIntensity!==void 0&&(r.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&r.specularColor!==void 0&&r.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(r.shininess=e.shininess),e.clearcoat!==void 0&&(r.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(r.dispersion=e.dispersion),e.iridescence!==void 0&&(r.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(r.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(r.transmission=e.transmission),e.thickness!==void 0&&(r.thickness=e.thickness),e.attenuationDistance!==void 0&&(r.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&r.attenuationColor!==void 0&&r.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(r.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(r.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(r.fog=e.fog),e.flatShading!==void 0&&(r.flatShading=e.flatShading),e.blending!==void 0&&(r.blending=e.blending),e.combine!==void 0&&(r.combine=e.combine),e.side!==void 0&&(r.side=e.side),e.shadowSide!==void 0&&(r.shadowSide=e.shadowSide),e.opacity!==void 0&&(r.opacity=e.opacity),e.transparent!==void 0&&(r.transparent=e.transparent),e.alphaTest!==void 0&&(r.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(r.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(r.depthFunc=e.depthFunc),e.depthTest!==void 0&&(r.depthTest=e.depthTest),e.depthWrite!==void 0&&(r.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(r.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(r.blendSrc=e.blendSrc),e.blendDst!==void 0&&(r.blendDst=e.blendDst),e.blendEquation!==void 0&&(r.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(r.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(r.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(r.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&r.blendColor!==void 0&&r.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(r.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(r.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(r.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(r.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(r.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(r.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(r.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(r.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(r.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(r.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(r.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(r.rotation=e.rotation),e.linewidth!==void 0&&(r.linewidth=e.linewidth),e.dashSize!==void 0&&(r.dashSize=e.dashSize),e.gapSize!==void 0&&(r.gapSize=e.gapSize),e.scale!==void 0&&(r.scale=e.scale),e.polygonOffset!==void 0&&(r.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(r.dithering=e.dithering),e.alphaToCoverage!==void 0&&(r.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(r.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(r.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(r.visible=e.visible),e.toneMapped!==void 0&&(r.toneMapped=e.toneMapped),e.userData!==void 0&&(r.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?r.vertexColors=e.vertexColors>0:r.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const o=e.uniforms[s];switch(r.uniforms[s]={},o.type){case"t":r.uniforms[s].value=i(o.value);break;case"c":r.uniforms[s].value=new Ke().setHex(o.value);break;case"v2":r.uniforms[s].value=new Ne().fromArray(o.value);break;case"v3":r.uniforms[s].value=new Y().fromArray(o.value);break;case"v4":r.uniforms[s].value=new Dt().fromArray(o.value);break;case"m3":r.uniforms[s].value=new At().fromArray(o.value);break;case"m4":r.uniforms[s].value=new ct().fromArray(o.value);break;default:r.uniforms[s].value=o.value}}if(e.defines!==void 0&&(r.defines=e.defines),e.vertexShader!==void 0&&(r.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(r.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(r.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)r.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(r.lights=e.lights),e.clipping!==void 0&&(r.clipping=e.clipping),e.size!==void 0&&(r.size=e.size),e.sizeAttenuation!==void 0&&(r.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(r.map=i(e.map)),e.matcap!==void 0&&(r.matcap=i(e.matcap)),e.alphaMap!==void 0&&(r.alphaMap=i(e.alphaMap)),e.bumpMap!==void 0&&(r.bumpMap=i(e.bumpMap)),e.bumpScale!==void 0&&(r.bumpScale=e.bumpScale),e.normalMap!==void 0&&(r.normalMap=i(e.normalMap)),e.normalMapType!==void 0&&(r.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),r.normalScale=new Ne().fromArray(s)}return e.displacementMap!==void 0&&(r.displacementMap=i(e.displacementMap)),e.displacementScale!==void 0&&(r.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(r.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(r.roughnessMap=i(e.roughnessMap)),e.metalnessMap!==void 0&&(r.metalnessMap=i(e.metalnessMap)),e.emissiveMap!==void 0&&(r.emissiveMap=i(e.emissiveMap)),e.emissiveIntensity!==void 0&&(r.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(r.specularMap=i(e.specularMap)),e.specularIntensityMap!==void 0&&(r.specularIntensityMap=i(e.specularIntensityMap)),e.specularColorMap!==void 0&&(r.specularColorMap=i(e.specularColorMap)),e.envMap!==void 0&&(r.envMap=i(e.envMap)),e.envMapRotation!==void 0&&r.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(r.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(r.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(r.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(r.lightMap=i(e.lightMap)),e.lightMapIntensity!==void 0&&(r.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(r.aoMap=i(e.aoMap)),e.aoMapIntensity!==void 0&&(r.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(r.gradientMap=i(e.gradientMap)),e.clearcoatMap!==void 0&&(r.clearcoatMap=i(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=i(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=i(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new Ne().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(r.iridescenceMap=i(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(r.iridescenceThicknessMap=i(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(r.transmissionMap=i(e.transmissionMap)),e.thicknessMap!==void 0&&(r.thicknessMap=i(e.thicknessMap)),e.anisotropyMap!==void 0&&(r.anisotropyMap=i(e.anisotropyMap)),e.sheenColorMap!==void 0&&(r.sheenColorMap=i(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(r.sheenRoughnessMap=i(e.sheenRoughnessMap)),r}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return kf.createMaterialFromType(e)}static createMaterialFromType(e){const t={ShadowMaterial:LC,SpriteMaterial:c0,RawShaderMaterial:DC,ShaderMaterial:Ni,PointsMaterial:u0,MeshPhysicalMaterial:PC,MeshStandardMaterial:E0,MeshPhongMaterial:UC,MeshToonMaterial:FC,MeshNormalMaterial:NC,MeshLambertMaterial:OC,MeshDepthMaterial:x0,MeshDistanceMaterial:y0,MeshBasicMaterial:Rs,MeshMatcapMaterial:kC,LineDashedMaterial:GC,LineBasicMaterial:Hn,Material:Tn};return new t[e]}}class CA{static decodeText(e){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let i=0,r=e.length;i<r;i++)t+=String.fromCharCode(e[i]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class tM extends yt{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class nM extends $n{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new zr(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}parse(e){const t={},i={};function r(f,A){if(t[A]!==void 0)return t[A];const m=f.interleavedBuffers[A],p=s(f,m.buffer),v=Da(m.type,p),E=new xf(v,m.stride);return E.uuid=m.uuid,t[A]=E,E}function s(f,A){if(i[A]!==void 0)return i[A];const m=f.arrayBuffers[A],p=new Uint32Array(m).buffer;return i[A]=p,p}const o=e.isInstancedBufferGeometry?new tM:new yt,a=e.data.index;if(a!==void 0){const f=Da(a.type,a.array);o.setIndex(new Gt(f,1))}const l=e.data.attributes;for(const f in l){const A=l[f];let g;if(A.isInterleavedBufferAttribute){const m=r(e.data,A.data);g=new Ro(m,A.itemSize,A.offset,A.normalized)}else{const m=Da(A.type,A.array),p=A.isInstancedBufferAttribute?ja:Gt;g=new p(m,A.itemSize,A.normalized)}A.name!==void 0&&(g.name=A.name),A.usage!==void 0&&g.setUsage(A.usage),o.setAttribute(f,g)}const c=e.data.morphAttributes;if(c)for(const f in c){const A=c[f],g=[];for(let m=0,p=A.length;m<p;m++){const v=A[m];let E;if(v.isInterleavedBufferAttribute){const x=r(e.data,v.data);E=new Ro(x,v.itemSize,v.offset,v.normalized)}else{const x=Da(v.type,v.array);E=new Gt(x,v.itemSize,v.normalized)}v.name!==void 0&&(E.name=v.name),g.push(E)}o.morphAttributes[f]=g}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const u=e.data.groups||e.data.drawcalls||e.data.offsets;if(u!==void 0)for(let f=0,A=u.length;f!==A;++f){const g=u[f];o.addGroup(g.start,g.count,g.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const f=new Y;d.center!==void 0&&f.fromArray(d.center),o.boundingSphere=new wn(f,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class ZT extends $n{constructor(e){super(e)}load(e,t,i,r){const s=this,o=this.path===""?CA.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new zr(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(u){r!==void 0&&r(u),console.error("THREE:ObjectLoader: Can't parse "+e+".",u.message);return}const h=c.metadata;if(h===void 0||h.type===void 0||h.type.toLowerCase()==="geometry"){r!==void 0&&r(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(c,t)},i,r)}async loadAsync(e,t){const i=this,r=this.path===""?CA.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const s=new zr(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const o=await s.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await i.parseAsync(a)}parse(e,t){const i=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,r),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,s,l,a,i),h=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,h),this.bindLightTargets(c),t!==void 0){let u=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){u=!0;break}u===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),s=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,s),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,r,a,o,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),this.bindLightTargets(l),l}parseShapes(e){const t={};if(e!==void 0)for(let i=0,r=e.length;i<r;i++){const s=new Mo().fromJSON(e[i]);t[s.uuid]=s}return t}parseSkeletons(e,t){const i={},r={};if(t.traverse(function(s){s.isBone&&(r[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new yf().fromJSON(e[s],r);i[a.uuid]=a}return i}parseGeometries(e,t){const i={};if(e!==void 0){const s=new nM;for(let o=0,a=e.length;o<a;o++){let l;const c=e[o];switch(c.type){case"BufferGeometry":case"InstancedBufferGeometry":l=s.parse(c);break;case"Geometry":if("THREE"in window&&"LegacyJSONLoader"in THREE){var r=new THREE.LegacyJSONLoader;l=r.parse(c,this.resourcePath).geometry}else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');break;default:c.type in dE?l=dE[c.type].fromJSON(c,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),c.userData!==void 0&&(l.userData=c.userData),i[c.uuid]=l}}return i}parseMaterials(e,t){const i={},r={};if(e!==void 0){const s=new kf;s.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];i[l.uuid]===void 0&&(i[l.uuid]=s.parse(l)),r[l.uuid]=i[l.uuid]}}return r}parseAnimations(e){const t={};if(e!==void 0)for(let i=0;i<e.length;i++){const r=e[i],s=Ec.parse(r);t[s.uuid]=s}return t}parseImages(e,t){const i=this,r={};let s;function o(l){return i.manager.itemStart(l),s.load(l,function(){i.manager.itemEnd(l)},void 0,function(){i.manager.itemError(l),i.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:i.resourcePath+c;return o(h)}else return l.data?{data:Da(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new M0(t);s=new xc(l),s.setCrossOrigin(this.crossOrigin);for(let c=0,h=e.length;c<h;c++){const u=e[c],d=u.url;if(Array.isArray(d)){const f=[];for(let A=0,g=d.length;A<g;A++){const m=d[A],p=a(m);p!==null&&(p instanceof HTMLImageElement?f.push(p):f.push(new Ki(p.data,p.width,p.height)))}r[u.uuid]=new Eo(f)}else{const f=a(u.url);r[u.uuid]=new Eo(f)}}}return r}async parseImagesAsync(e){const t=this,i={};let r;async function s(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await r.loadAsync(l)}else return o.data?{data:Da(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){r=new xc(this.manager),r.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],c=l.url;if(Array.isArray(c)){const h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u],A=await s(f);A!==null&&(A instanceof HTMLImageElement?h.push(A):h.push(new Ki(A.data,A.width,A.height)))}i[l.uuid]=new Eo(h)}else{const h=await s(l.url);i[l.uuid]=new Eo(h)}}}return i}parseTextures(e,t){function i(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const r={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],c=l.data;let h;Array.isArray(c)?(h=new Uc,c.length===6&&(h.needsUpdate=!0)):(c&&c.data?h=new Ki:h=new mn,c&&(h.needsUpdate=!0)),h.source=l,h.uuid=a.uuid,a.name!==void 0&&(h.name=a.name),a.mapping!==void 0&&(h.mapping=i(a.mapping,e2)),a.channel!==void 0&&(h.channel=a.channel),a.offset!==void 0&&h.offset.fromArray(a.offset),a.repeat!==void 0&&h.repeat.fromArray(a.repeat),a.center!==void 0&&h.center.fromArray(a.center),a.rotation!==void 0&&(h.rotation=a.rotation),a.wrap!==void 0&&(h.wrapS=i(a.wrap[0],AE),h.wrapT=i(a.wrap[1],AE)),a.format!==void 0&&(h.format=a.format),a.internalFormat!==void 0&&(h.internalFormat=a.internalFormat),a.type!==void 0&&(h.type=a.type),a.colorSpace!==void 0&&(h.colorSpace=a.colorSpace),a.minFilter!==void 0&&(h.minFilter=i(a.minFilter,gE)),a.magFilter!==void 0&&(h.magFilter=i(a.magFilter,gE)),a.anisotropy!==void 0&&(h.anisotropy=a.anisotropy),a.flipY!==void 0&&(h.flipY=a.flipY),a.generateMipmaps!==void 0&&(h.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(h.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(h.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(h.compareFunction=a.compareFunction),a.userData!==void 0&&(h.userData=a.userData),r[a.uuid]=h}return r}parseObject(e,t,i,r,s){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const f=[];for(let A=0,g=d.length;A<g;A++){const m=d[A];i[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",m),f.push(i[m])}return f}return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),i[d]}}function c(d){return r[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),r[d]}let h,u;switch(e.type){case"Scene":o=new uC,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new Ke(e.background):o.background=c(e.background)),e.environment!==void 0&&(o.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new Ef(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new vf(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&o.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(o.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&o.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":o=new gn(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new Of(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new KC(e.color,e.intensity);break;case"DirectionalLight":o=new $C(e.color,e.intensity),o.target=e.target||"";break;case"PointLight":o=new jC(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new JC(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new YC(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),o.target=e.target||"";break;case"HemisphereLight":o=new qC(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new eM().fromJSON(e);break;case"SkinnedMesh":h=a(e.geometry),u=l(e.material),o=new mC(h,u),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":h=a(e.geometry),u=l(e.material),o=new en(h,u);break;case"InstancedMesh":h=a(e.geometry),u=l(e.material);const d=e.count,f=e.instanceMatrix,A=e.instanceColor;o=new AC(h,u,d),o.instanceMatrix=new ja(new Float32Array(f.array),16),A!==void 0&&(o.instanceColor=new ja(new Float32Array(A.array),A.itemSize));break;case"BatchedMesh":h=a(e.geometry),u=l(e.material),o=new gC(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,u),o.geometry=h,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._visibility=e.visibility,o._active=e.active,o._bounds=e.bounds.map(g=>{const m=new Gn;m.min.fromArray(g.boxMin),m.max.fromArray(g.boxMax);const p=new wn;return p.radius=g.sphereRadius,p.center.fromArray(g.sphereCenter),{boxInitialized:g.boxInitialized,box:m,sphereInitialized:g.sphereInitialized,sphere:p}}),o._maxInstanceCount=e.maxInstanceCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._geometryCount=e.geometryCount,o._matricesTexture=c(e.matricesTexture.uuid),e.colorsTexture!==void 0&&(o._colorsTexture=c(e.colorsTexture.uuid));break;case"LOD":o=new pC;break;case"Line":o=new Cs(a(e.geometry),l(e.material));break;case"LineLoop":o=new vC(a(e.geometry),l(e.material));break;case"LineSegments":o=new nr(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new EC(a(e.geometry),l(e.material));break;case"Sprite":o=new fC(l(e.material));break;case"Group":o=new Pa;break;case"Bone":o=new h0;break;default:o=new Ft}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(o.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let f=0;f<d.length;f++)o.add(this.parseObject(d[f],t,i,r,s))}if(e.animations!==void 0){const d=e.animations;for(let f=0;f<d.length;f++){const A=d[f];o.animations.push(s[A])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let f=0;f<d.length;f++){const A=d[f],g=o.getObjectByProperty("uuid",A.object);g!==void 0&&o.addLevel(g,A.distance,A.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(i){if(i.isSkinnedMesh===!0&&i.skeleton!==void 0){const r=t[i.skeleton];r===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",i.skeleton):i.bind(r,i.bindMatrix)}})}bindLightTargets(e){e.traverse(function(t){if(t.isDirectionalLight||t.isSpotLight){const i=t.target,r=e.getObjectByProperty("uuid",i);r!==void 0?t.target=r:t.target=new Ft}})}}const e2={UVMapping:of,CubeReflectionMapping:kr,CubeRefractionMapping:bs,EquirectangularReflectionMapping:ic,EquirectangularRefractionMapping:rc,CubeUVReflectionMapping:nl},AE={RepeatWrapping:sc,ClampToEdgeWrapping:mi,MirroredRepeatWrapping:oc},gE={NearestFilter:xn,NearestMipmapNearestFilter:Yg,NearestMipmapLinearFilter:La,LinearFilter:ln,LinearMipmapNearestFilter:Ql,LinearMipmapLinearFilter:Yi};class t2 extends $n{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Mr.get(e);if(o!==void 0){if(s.manager.itemStart(e),o.then){o.then(c=>{t&&t(c),s.manager.itemEnd(e)}).catch(c=>{r&&r(c)});return}return setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader;const l=fetch(e,a).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(c){return Mr.add(e,c),t&&t(c),s.manager.itemEnd(e),c}).catch(function(c){r&&r(c),Mr.remove(e),s.manager.itemError(e),s.manager.itemEnd(e)});Mr.add(e,l),s.manager.itemStart(e)}}let Bh;class w0{static getContext(){return Bh===void 0&&(Bh=new(window.AudioContext||window.webkitAudioContext)),Bh}static setContext(e){Bh=e}}class n2 extends $n{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new zr(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const c=l.slice(0);w0.getContext().decodeAudioData(c,function(u){t(u)}).catch(a)}catch(c){a(c)}},i,r);function a(l){r?r(l):console.error(l),s.manager.itemError(e)}}}const vE=new ct,EE=new ct,Gs=new ct;class i2{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new gn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new gn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Gs.copy(e.projectionMatrix);const r=t.eyeSep/2,s=r*t.near/t.focus,o=t.near*Math.tan(Co*t.fov*.5)/t.zoom;let a,l;EE.elements[12]=-r,vE.elements[12]=r,a=-o*t.aspect+s,l=o*t.aspect+s,Gs.elements[0]=2*t.near/(l-a),Gs.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(Gs),a=-o*t.aspect-s,l=o*t.aspect-s,Gs.elements[0]=2*t.near/(l-a),Gs.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(Gs)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(EE),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(vE)}}let iM=class extends gn{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e,this.index=0}};class rM{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=xE(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=xE();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function xE(){return performance.now()}const zs=new Y,yE=new Yn,r2=new Y,Hs=new Y;class s2 extends Ft{constructor(){super(),this.type="AudioListener",this.context=w0.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new rM}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(zs,yE,r2),Hs.set(0,0,-1).applyQuaternion(yE),t.positionX){const r=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(zs.x,r),t.positionY.linearRampToValueAtTime(zs.y,r),t.positionZ.linearRampToValueAtTime(zs.z,r),t.forwardX.linearRampToValueAtTime(Hs.x,r),t.forwardY.linearRampToValueAtTime(Hs.y,r),t.forwardZ.linearRampToValueAtTime(Hs.z,r),t.upX.linearRampToValueAtTime(i.x,r),t.upY.linearRampToValueAtTime(i.y,r),t.upZ.linearRampToValueAtTime(i.z,r)}else t.setPosition(zs.x,zs.y,zs.z),t.setOrientation(Hs.x,Hs.y,Hs.z,i.x,i.y,i.z)}}class sM extends Ft{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,t){return super.copy(e,t),e.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const Vs=new Y,_E=new Yn,o2=new Y,Qs=new Y;class a2 extends sM{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,i){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=i,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Vs,_E,o2),Qs.set(0,0,1).applyQuaternion(_E);const t=this.panner;if(t.positionX){const i=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Vs.x,i),t.positionY.linearRampToValueAtTime(Vs.y,i),t.positionZ.linearRampToValueAtTime(Vs.z,i),t.orientationX.linearRampToValueAtTime(Qs.x,i),t.orientationY.linearRampToValueAtTime(Qs.y,i),t.orientationZ.linearRampToValueAtTime(Qs.z,i)}else t.setPosition(Vs.x,Vs.y,Vs.z),t.setOrientation(Qs.x,Qs.y,Qs.z)}}class l2{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let i=0;i<t.length;i++)e+=t[i];return e/t.length}}class oM{constructor(e,t,i){this.binding=e,this.valueSize=i;let r,s,o;switch(t){case"quaternion":r=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:r=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const i=this.buffer,r=this.valueSize,s=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)i[s+a]=i[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(i,s,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,i=this.valueSize,r=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,i),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,i=this.buffer,r=e*t+t,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=t*this._origIndex;this._mixBufferRegion(i,r,l,1-s,t)}o>0&&this._mixBufferRegionAdditive(i,r,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(i[l]!==i[l+t]){a.setValue(i,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,i=this.valueSize,r=i*this._origIndex;e.getValue(t,r);for(let s=i,o=r;s!==o;++s)t[s]=t[r+s%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let i=e;i<t;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[t+i]=this.buffer[e+i]}_select(e,t,i,r,s){if(r>=.5)for(let o=0;o!==s;++o)e[t+o]=e[i+o]}_slerp(e,t,i,r){Yn.slerpFlat(e,t,e,t,e,i,r)}_slerpAdditive(e,t,i,r,s){const o=this._workIndex*s;Yn.multiplyQuaternionsFlat(e,o,e,t,e,i),Yn.slerpFlat(e,t,e,t,e,o,r)}_lerp(e,t,i,r,s){const o=1-r;for(let a=0;a!==s;++a){const l=t+a;e[l]=e[l]*o+e[i+a]*r}}_lerpAdditive(e,t,i,r,s){for(let o=0;o!==s;++o){const a=t+o;e[a]=e[a]+e[i+o]*r}}}const T0="\\[\\]\\.:\\/",c2=new RegExp("["+T0+"]","g"),I0="[^"+T0+"]",h2="[^"+T0.replace("\\.","")+"]",u2=/((?:WC+[\/:])*)/.source.replace("WC",I0),d2=/(WCOD+)?/.source.replace("WCOD",h2),f2=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",I0),p2=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",I0),m2=new RegExp("^"+u2+d2+f2+p2+"$"),A2=["material","materials","bones","map"];class g2{constructor(e,t,i){const r=i||Tt.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const i=this._targetGroup.nCachedObjects_,r=this._bindings[i];r!==void 0&&r.getValue(e,t)}setValue(e,t){const i=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=i.length;r!==s;++r)i[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}}class Tt{constructor(e,t,i){this.path=t,this.parsedPath=i||Tt.parseTrackName(t),this.node=Tt.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new Tt.Composite(e,t,i):new Tt(e,t,i)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(c2,"")}static parseTrackName(e){const t=m2.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const i={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=i.nodeName&&i.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=i.nodeName.substring(r+1);A2.indexOf(s)!==-1&&(i.nodeName=i.nodeName.substring(0,r),i.objectName=s)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const i=e.skeleton.getBoneByName(t);if(i!==void 0)return i}if(e.children){const i=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const l=i(a.children);if(l)return l}return null},r=i(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)e[t++]=i[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,i=t.objectName,r=t.propertyName;let s=t.propertyIndex;if(e||(e=Tt.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let c=t.objectIndex;switch(i){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let h=0;h<e.length;h++)if(e[h].name===c){c=h;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[i]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[r];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?a=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Tt.Composite=g2;Tt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Tt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Tt.prototype.GetterByBindingType=[Tt.prototype._getValue_direct,Tt.prototype._getValue_array,Tt.prototype._getValue_arrayElement,Tt.prototype._getValue_toArray];Tt.prototype.SetterByBindingTypeAndVersioning=[[Tt.prototype._setValue_direct,Tt.prototype._setValue_direct_setNeedsUpdate,Tt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Tt.prototype._setValue_array,Tt.prototype._setValue_array_setNeedsUpdate,Tt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Tt.prototype._setValue_arrayElement,Tt.prototype._setValue_arrayElement_setNeedsUpdate,Tt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Tt.prototype._setValue_fromArray,Tt.prototype._setValue_fromArray_setNeedsUpdate,Tt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class v2{constructor(){this.isAnimationObjectGroup=!0,this.uuid=ii(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let i=0,r=arguments.length;i!==r;++i)e[arguments[i].uuid]=i;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length;let a,l=e.length,c=this.nCachedObjects_;for(let h=0,u=arguments.length;h!==u;++h){const d=arguments[h],f=d.uuid;let A=t[f];if(A===void 0){A=l++,t[f]=A,e.push(d);for(let g=0,m=o;g!==m;++g)s[g].push(new Tt(d,i[g],r[g]))}else if(A<c){a=e[A];const g=--c,m=e[g];t[m.uuid]=A,e[A]=m,t[f]=g,e[g]=d;for(let p=0,v=o;p!==v;++p){const E=s[p],x=E[g];let M=E[A];E[A]=x,M===void 0&&(M=new Tt(d,i[p],r[p])),E[g]=M}}else e[A]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,r=i.length;let s=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,h=t[c];if(h!==void 0&&h>=s){const u=s++,d=e[u];t[d.uuid]=h,e[h]=d,t[c]=u,e[u]=l;for(let f=0,A=r;f!==A;++f){const g=i[f],m=g[u],p=g[h];g[h]=m,g[u]=p}}}this.nCachedObjects_=s}uncache(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,r=i.length;let s=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],h=c.uuid,u=t[h];if(u!==void 0)if(delete t[h],u<s){const d=--s,f=e[d],A=--o,g=e[A];t[f.uuid]=u,e[u]=f,t[g.uuid]=d,e[d]=g,e.pop();for(let m=0,p=r;m!==p;++m){const v=i[m],E=v[d],x=v[A];v[u]=E,v[d]=x,v.pop()}}else{const d=--o,f=e[d];d>0&&(t[f.uuid]=u),e[u]=f,e.pop();for(let A=0,g=r;A!==g;++A){const m=i[A];m[u]=m[d],m.pop()}}}this.nCachedObjects_=s}subscribe_(e,t){const i=this._bindingsIndicesByPath;let r=i[e];const s=this._bindings;if(r!==void 0)return s[r];const o=this._paths,a=this._parsedPaths,l=this._objects,c=l.length,h=this.nCachedObjects_,u=new Array(c);r=s.length,i[e]=r,o.push(e),a.push(t),s.push(u);for(let d=h,f=l.length;d!==f;++d){const A=l[d];u[d]=new Tt(A,e,t)}return u}unsubscribe_(e){const t=this._bindingsIndicesByPath,i=t[e];if(i!==void 0){const r=this._paths,s=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],c=e[a];t[c]=i,o[i]=l,o.pop(),s[i]=s[a],s.pop(),r[i]=r[a],r.pop()}}}class aM{constructor(e,t,i=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=r;const s=t.tracks,o=s.length,a=new Array(o),l={endingStart:go,endingEnd:go};for(let c=0;c!==o;++c){const h=s[c].createInterpolant(null);a[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Ob,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i){if(e.fadeOut(t),this.fadeIn(t),i){const r=this._clip.duration,s=e._clip.duration,o=s/r,a=r/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,i){return e.crossFadeFrom(this,t,i)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+i,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,i,r){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*i;l<0||i===0?t=0:(this._startTime=null,t=i*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case r0:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulateAdditive(a);break;case ff:default:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const i=this._weightInterpolant;if(i!==null){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const i=this._timeScaleInterpolant;if(i!==null){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,i=this.loop;let r=this.time+e,s=this._loopCount;const o=i===kb;if(e===0)return s===-1?r:o&&(s&1)===1?t-r:r;if(i===Nb){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return t-r}return r}_setEndings(e,t,i){const r=this._interpolantSettings;i?(r.endingStart=vo,r.endingEnd=vo):(e?r.endingStart=this.zeroSlopeAtStart?vo:go:r.endingStart=lc,t?r.endingEnd=this.zeroSlopeAtEnd?vo:go:r.endingEnd=lc)}_scheduleFading(e,t,i){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=t,a[1]=s+e,l[1]=i,this}}const E2=new Float32Array(1);class x2 extends tr{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const i=e._localRoot||this._root,r=e._clip.tracks,s=r.length,o=e._propertyBindings,a=e._interpolants,l=i.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let u=0;u!==s;++u){const d=r[u],f=d.name;let A=h[f];if(A!==void 0)++A.referenceCount,o[u]=A;else{if(A=o[u],A!==void 0){A._cacheIndex===null&&(++A.referenceCount,this._addInactiveBinding(A,l,f));continue}const g=t&&t._propertyBindings[u].binding.parsedPath;A=new oM(Tt.create(i,f,g),d.ValueTypeName,d.getValueSize()),++A.referenceCount,this._addInactiveBinding(A,l,f),o[u]=A}a[u].resultBuffer=A.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const i=(e._localRoot||this._root).uuid,r=e._clip.uuid,s=this._actionsByClip[r];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,r,i)}const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,i){const r=this._actions,s=this._actionsByClip;let o=s[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[i]=e}_removeInactiveAction(e){const t=this._actions,i=t[t.length-1],r=e._cacheIndex;i._cacheIndex=r,t[r]=i,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],l=a.knownActions,c=l[l.length-1],h=e._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),e._byClipCacheIndex=null;const u=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete u[d],l.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,i=e._cacheIndex,r=this._nActiveActions++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_takeBackAction(e){const t=this._actions,i=e._cacheIndex,r=--this._nActiveActions,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_addInactiveBinding(e,t,i){const r=this._bindingsByRootAndName,s=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[i]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,i=e.binding,r=i.rootNode.uuid,s=i.path,o=this._bindingsByRootAndName,a=o[r],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete a[s],Object.keys(a).length===0&&delete o[r]}_lendBinding(e){const t=this._bindings,i=e._cacheIndex,r=this._nActiveBindings++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_takeBackBinding(e){const t=this._bindings,i=e._cacheIndex,r=--this._nActiveBindings,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let i=e[t];return i===void 0&&(i=new b0(new Float32Array(2),new Float32Array(2),1,E2),i.__cacheIndex=t,e[t]=i),i}_takeBackControlInterpolant(e){const t=this._controlInterpolants,i=e.__cacheIndex,r=--this._nActiveControlInterpolants,s=t[r];e.__cacheIndex=r,t[r]=e,s.__cacheIndex=i,t[i]=s}clipAction(e,t,i){const r=t||this._root,s=r.uuid;let o=typeof e=="string"?Ec.findByName(r,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(i===void 0&&(o!==null?i=o.blendMode:i=ff),l!==void 0){const u=l.actionByRoot[s];if(u!==void 0&&u.blendMode===i)return u;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const h=new aM(this,o,t,i);return this._bindAction(h,c),this._addInactiveAction(h,a,s),h}existingAction(e,t){const i=t||this._root,r=i.uuid,s=typeof e=="string"?Ec.findByName(i,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let i=t-1;i>=0;--i)e[i].stop();return this}update(e){e*=this.timeScale;const t=this._actions,i=this._nActiveActions,r=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==i;++c)t[c]._update(r,e,s,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,i=e.uuid,r=this._actionsByClip,s=r[i];if(s!==void 0){const o=s.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const h=c._cacheIndex,u=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=h,t[h]=u,t.pop(),this._removeInactiveBindingsForAction(c)}delete r[i]}}uncacheRoot(e){const t=e.uuid,i=this._actionsByClip;for(const o in i){const a=i[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,s=r[t];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const i=this.existingAction(e,t);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class y2 extends pf{constructor(e=1,t=1,i=1,r={}){super(e,t,r),this.isRenderTarget3D=!0,this.depth=i,this.texture=new mf(null,e,t,i),this.texture.isRenderTargetTexture=!0}}class _2 extends pf{constructor(e=1,t=1,i=1,r={}){super(e,t,r),this.isRenderTargetArray=!0,this.depth=i,this.texture=new Dc(null,e,t,i),this.texture.isRenderTargetTexture=!0}}class R0{constructor(e){this.value=e}clone(){return new R0(this.value.clone===void 0?this.value:this.value.clone())}}let b2=0;class C2 extends tr{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:b2++}),this.name="",this.usage=hc,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let i=0,r=t.length;i<r;i++){const s=Array.isArray(t[i])?t[i]:[t[i]];for(let o=0;o<s.length;o++)this.uniforms.push(s[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class M2 extends xf{constructor(e,t,i=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class S2{constructor(e,t,i,r,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=i,this.elementSize=r,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const bE=new ct;let w2=class{constructor(e,t,i=0,r=1/0){this.ray=new rl(e,t),this.near=i,this.far=r,this.camera=null,this.layers=new Af,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return bE.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(bE),this}intersectObject(e,t=!0,i=[]){return MA(e,this,i,t),i.sort(CE),i}intersectObjects(e,t=!0,i=[]){for(let r=0,s=e.length;r<s;r++)MA(e[r],this,i,t);return i.sort(CE),i}};function CE(n,e){return n.distance-e.distance}function MA(n,e,t,i){let r=!0;if(n.layers.test(e.layers)&&n.raycast(e,t)===!1&&(r=!1),r===!0&&i===!0){const s=n.children;for(let o=0,a=s.length;o<a;o++)MA(s[o],e,t,!0)}}class T2{constructor(e=1,t=0,i=0){return this.radius=e,this.phi=t,this.theta=i,this}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=pt(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(pt(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class I2{constructor(e=1,t=0,i=0){return this.radius=e,this.theta=t,this.y=i,this}set(e,t,i){return this.radius=e,this.theta=t,this.y=i,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+i*i),this.theta=Math.atan2(e,i),this.y=t,this}clone(){return new this.constructor().copy(this)}}class B0{constructor(e,t,i,r){B0.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,t,i,r)}identity(){return this.set(1,0,0,1),this}fromArray(e,t=0){for(let i=0;i<4;i++)this.elements[i]=e[i+t];return this}set(e,t,i,r){const s=this.elements;return s[0]=e,s[2]=t,s[1]=i,s[3]=r,this}}const ME=new Ne;class R2{constructor(e=new Ne(1/0,1/0),t=new Ne(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=ME.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,ME).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const SE=new Y,Lh=new Y;class B2{constructor(e=new Y,t=new Y){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){SE.subVectors(e,this.start),Lh.subVectors(this.end,this.start);const i=Lh.dot(Lh);let s=Lh.dot(SE)/i;return t&&(s=pt(s,0,1)),s}closestPointToPoint(e,t,i){const r=this.closestPointToPointParameter(e,t);return this.delta(i).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const wE=new Y;class L2 extends Ft{constructor(e,t){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const i=new yt,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,h=a/l*Math.PI*2;r.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}i.setAttribute("position",new et(r,3));const s=new Hn({fog:!1,toneMapped:!1});this.cone=new nr(i,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),wE.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(wE),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Kr=new Y,Dh=new ct,Pp=new ct;class D2 extends nr{constructor(e){const t=lM(e),i=new yt,r=[],s=[],o=new Ke(0,0,1),a=new Ke(0,1,0);for(let c=0;c<t.length;c++){const h=t[c];h.parent&&h.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}i.setAttribute("position",new et(r,3)),i.setAttribute("color",new et(s,3));const l=new Hn({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,i=this.geometry,r=i.getAttribute("position");Pp.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(Dh.multiplyMatrices(Pp,a.matrixWorld),Kr.setFromMatrixPosition(Dh),r.setXYZ(o,Kr.x,Kr.y,Kr.z),Dh.multiplyMatrices(Pp,a.parent.matrixWorld),Kr.setFromMatrixPosition(Dh),r.setXYZ(o+1,Kr.x,Kr.y,Kr.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function lM(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,lM(n.children[t]));return e}class P2 extends en{constructor(e,t,i){const r=new kc(t,4,2),s=new Rs({wireframe:!0,fog:!1,toneMapped:!1});super(r,s),this.light=e,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const U2=new Y,TE=new Ke,IE=new Ke;class F2 extends Ft{constructor(e,t,i){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="HemisphereLightHelper";const r=new Oc(t);r.rotateY(Math.PI*.5),this.material=new Rs({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=r.getAttribute("position"),o=new Float32Array(s.count*3);r.setAttribute("color",new Gt(o,3)),this.add(new en(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");TE.copy(this.light.color),IE.copy(this.light.groundColor);for(let i=0,r=t.count;i<r;i++){const s=i<r/2?TE:IE;t.setXYZ(i,s.r,s.g,s.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(U2.setFromMatrixPosition(this.light.matrixWorld).negate())}}class N2 extends nr{constructor(e=10,t=10,i=4473924,r=8947848){i=new Ke(i),r=new Ke(r);const s=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,f=0,A=-a;d<=t;d++,A+=o){l.push(-a,0,A,a,0,A),l.push(A,0,-a,A,0,a);const g=d===s?i:r;g.toArray(c,f),f+=3,g.toArray(c,f),f+=3,g.toArray(c,f),f+=3,g.toArray(c,f),f+=3}const h=new yt;h.setAttribute("position",new et(l,3)),h.setAttribute("color",new et(c,3));const u=new Hn({vertexColors:!0,toneMapped:!1});super(h,u),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class O2 extends nr{constructor(e=10,t=16,i=8,r=64,s=4473924,o=8947848){s=new Ke(s),o=new Ke(o);const a=[],l=[];if(t>1)for(let u=0;u<t;u++){const d=u/t*(Math.PI*2),f=Math.sin(d)*e,A=Math.cos(d)*e;a.push(0,0,0),a.push(f,0,A);const g=u&1?s:o;l.push(g.r,g.g,g.b),l.push(g.r,g.g,g.b)}for(let u=0;u<i;u++){const d=u&1?s:o,f=e-e/i*u;for(let A=0;A<r;A++){let g=A/r*(Math.PI*2),m=Math.sin(g)*f,p=Math.cos(g)*f;a.push(m,0,p),l.push(d.r,d.g,d.b),g=(A+1)/r*(Math.PI*2),m=Math.sin(g)*f,p=Math.cos(g)*f,a.push(m,0,p),l.push(d.r,d.g,d.b)}}const c=new yt;c.setAttribute("position",new et(a,3)),c.setAttribute("color",new et(l,3));const h=new Hn({vertexColors:!0,toneMapped:!1});super(c,h),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const RE=new Y,Ph=new Y,BE=new Y;class k2 extends Ft{constructor(e,t,i){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",t===void 0&&(t=1);let r=new yt;r.setAttribute("position",new et([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new Hn({fog:!1,toneMapped:!1});this.lightPlane=new Cs(r,s),this.add(this.lightPlane),r=new yt,r.setAttribute("position",new et([0,0,0,0,0,1],3)),this.targetLine=new Cs(r,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),RE.setFromMatrixPosition(this.light.matrixWorld),Ph.setFromMatrixPosition(this.light.target.matrixWorld),BE.subVectors(Ph,RE),this.lightPlane.lookAt(Ph),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Ph),this.targetLine.scale.z=BE.length()}}const Uh=new Y,Wt=new gf;class G2 extends nr{constructor(e){const t=new yt,i=new Hn({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],s=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(A,g){l(A),l(g)}function l(A){r.push(0,0,0),s.push(0,0,0),o[A]===void 0&&(o[A]=[]),o[A].push(r.length/3-1)}t.setAttribute("position",new et(r,3)),t.setAttribute("color",new et(s,3)),super(t,i),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const c=new Ke(16755200),h=new Ke(16711680),u=new Ke(43775),d=new Ke(16777215),f=new Ke(3355443);this.setColors(c,h,u,d,f)}setColors(e,t,i,r,s){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,i.r,i.g,i.b),a.setXYZ(33,i.r,i.g,i.b),a.setXYZ(34,i.r,i.g,i.b),a.setXYZ(35,i.r,i.g,i.b),a.setXYZ(36,i.r,i.g,i.b),a.setXYZ(37,i.r,i.g,i.b),a.setXYZ(38,r.r,r.g,r.b),a.setXYZ(39,r.r,r.g,r.b),a.setXYZ(40,s.r,s.g,s.b),a.setXYZ(41,s.r,s.g,s.b),a.setXYZ(42,s.r,s.g,s.b),a.setXYZ(43,s.r,s.g,s.b),a.setXYZ(44,s.r,s.g,s.b),a.setXYZ(45,s.r,s.g,s.b),a.setXYZ(46,s.r,s.g,s.b),a.setXYZ(47,s.r,s.g,s.b),a.setXYZ(48,s.r,s.g,s.b),a.setXYZ(49,s.r,s.g,s.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,i=1,r=1;Wt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const s=this.camera.coordinateSystem===Li?-1:0;Xt("c",t,e,Wt,0,0,s),Xt("t",t,e,Wt,0,0,1),Xt("n1",t,e,Wt,-1,-1,s),Xt("n2",t,e,Wt,i,-1,s),Xt("n3",t,e,Wt,-1,r,s),Xt("n4",t,e,Wt,i,r,s),Xt("f1",t,e,Wt,-1,-1,1),Xt("f2",t,e,Wt,i,-1,1),Xt("f3",t,e,Wt,-1,r,1),Xt("f4",t,e,Wt,i,r,1),Xt("u1",t,e,Wt,i*.7,r*1.1,s),Xt("u2",t,e,Wt,-1*.7,r*1.1,s),Xt("u3",t,e,Wt,0,r*2,s),Xt("cf1",t,e,Wt,-1,0,1),Xt("cf2",t,e,Wt,i,0,1),Xt("cf3",t,e,Wt,0,-1,1),Xt("cf4",t,e,Wt,0,r,1),Xt("cn1",t,e,Wt,-1,0,s),Xt("cn2",t,e,Wt,i,0,s),Xt("cn3",t,e,Wt,0,-1,s),Xt("cn4",t,e,Wt,0,r,s),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Xt(n,e,t,i,r,s,o){Uh.set(r,s,o).unproject(i);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,h=a.length;c<h;c++)l.setXYZ(a[c],Uh.x,Uh.y,Uh.z)}}const Fh=new Gn;class z2 extends nr{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(8*3),s=new yt;s.setIndex(new Gt(i,1)),s.setAttribute("position",new Gt(r,3)),super(s,new Hn({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Fh.setFromObject(this.object),Fh.isEmpty())return;const t=Fh.min,i=Fh.max,r=this.geometry.attributes.position,s=r.array;s[0]=i.x,s[1]=i.y,s[2]=i.z,s[3]=t.x,s[4]=i.y,s[5]=i.z,s[6]=t.x,s[7]=t.y,s[8]=i.z,s[9]=i.x,s[10]=t.y,s[11]=i.z,s[12]=i.x,s[13]=i.y,s[14]=t.z,s[15]=t.x,s[16]=i.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=i.x,s[22]=t.y,s[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class H2 extends nr{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new yt;s.setIndex(new Gt(i,1)),s.setAttribute("position",new et(r,3)),super(s,new Hn({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class V2 extends Cs{constructor(e,t=1,i=16776960){const r=i,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new yt;o.setAttribute("position",new et(s,3)),o.computeBoundingSphere(),super(o,new Hn({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new yt;l.setAttribute("position",new et(a,3)),l.computeBoundingSphere(),this.add(new en(l,new Rs({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const LE=new Y;let Nh,Up;class Q2 extends Ft{constructor(e=new Y(0,0,1),t=new Y(0,0,0),i=1,r=16776960,s=i*.2,o=s*.2){super(),this.type="ArrowHelper",Nh===void 0&&(Nh=new yt,Nh.setAttribute("position",new et([0,0,0,0,1,0],3)),Up=new sl(0,.5,1,5,1),Up.translate(0,-.5,0)),this.position.copy(t),this.line=new Cs(Nh,new Hn({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new en(Up,new Rs({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(i,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{LE.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(LE,t)}}setLength(e,t=e*.2,i=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(i,t,i),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class W2 extends nr{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new yt;r.setAttribute("position",new et(t,3)),r.setAttribute("color",new et(i,3));const s=new Hn({vertexColors:!0,toneMapped:!1});super(r,s),this.type="AxesHelper"}setColors(e,t,i){const r=new Ke,s=this.geometry.attributes.color.array;return r.set(e),r.toArray(s,0),r.toArray(s,3),r.set(t),r.toArray(s,6),r.toArray(s,9),r.set(i),r.toArray(s,12),r.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class X2{constructor(){this.type="ShapePath",this.color=new Ke,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new fc,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,i,r){return this.currentPath.quadraticCurveTo(e,t,i,r),this}bezierCurveTo(e,t,i,r,s,o){return this.currentPath.bezierCurveTo(e,t,i,r,s,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(p){const v=[];for(let E=0,x=p.length;E<x;E++){const M=p[E],w=new Mo;w.curves=M.curves,v.push(w)}return v}function i(p,v){const E=v.length;let x=!1;for(let M=E-1,w=0;w<E;M=w++){let S=v[M],B=v[w],y=B.x-S.x,_=B.y-S.y;if(Math.abs(_)>Number.EPSILON){if(_<0&&(S=v[w],y=-y,B=v[M],_=-_),p.y<S.y||p.y>B.y)continue;if(p.y===S.y){if(p.x===S.x)return!0}else{const L=_*(p.x-S.x)-y*(p.y-S.y);if(L===0)return!0;if(L<0)continue;x=!x}}else{if(p.y!==S.y)continue;if(B.x<=p.x&&p.x<=S.x||S.x<=p.x&&p.x<=B.x)return!0}}return x}const r=Ji.isClockWise,s=this.subPaths;if(s.length===0)return[];let o,a,l;const c=[];if(s.length===1)return a=s[0],l=new Mo,l.curves=a.curves,c.push(l),c;let h=!r(s[0].getPoints());h=e?!h:h;const u=[],d=[];let f=[],A=0,g;d[A]=void 0,f[A]=[];for(let p=0,v=s.length;p<v;p++)a=s[p],g=a.getPoints(),o=r(g),o=e?!o:o,o?(!h&&d[A]&&A++,d[A]={s:new Mo,p:g},d[A].s.curves=a.curves,h&&A++,f[A]=[]):f[A].push({h:a,p:g[0]});if(!d[0])return t(s);if(d.length>1){let p=!1,v=0;for(let E=0,x=d.length;E<x;E++)u[E]=[];for(let E=0,x=d.length;E<x;E++){const M=f[E];for(let w=0;w<M.length;w++){const S=M[w];let B=!0;for(let y=0;y<d.length;y++)i(S.p,d[y].p)&&(E!==y&&v++,B?(B=!1,u[y].push(S)):p=!0);B&&u[E].push(S)}}v>0&&p===!1&&(f=u)}let m;for(let p=0,v=d.length;p<v;p++){l=d[p].s,c.push(l),m=f[p];for(let E=0,x=m.length;E<x;E++)l.holes.push(m[E].h)}return c}}class q2 extends tr{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}function Y2(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2):(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0),n}function j2(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0):(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2),n}function $2(n){return n.repeat.x=1,n.repeat.y=1,n.offset.x=0,n.offset.y=0,n}function SA(n,e,t,i){const r=K2(i);switch(t){case Jg:return n*e;case e0:return n*e;case t0:return n*e*2;case hf:return n*e/r.components*r.byteLength;case Lc:return n*e/r.components*r.byteLength;case n0:return n*e*2/r.components*r.byteLength;case uf:return n*e*2/r.components*r.byteLength;case Zg:return n*e*3/r.components*r.byteLength;case On:return n*e*4/r.components*r.byteLength;case df:return n*e*4/r.components*r.byteLength;case Wl:case Xl:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case ql:case Yl:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case hd:case dd:return Math.max(n,16)*Math.max(e,8)/4;case cd:case ud:return Math.max(n,8)*Math.max(e,8)/2;case fd:case pd:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case md:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case Ad:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case gd:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case vd:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case Ed:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case xd:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case yd:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case _d:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case bd:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case Cd:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case Md:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case Sd:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case wd:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case Td:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case Id:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case jl:case Rd:case Bd:return Math.ceil(n/4)*Math.ceil(e/4)*16;case i0:case Ld:return Math.ceil(n/4)*Math.ceil(e/4)*8;case Dd:case Pd:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function K2(n){switch(n){case er:case jg:return{byteLength:1,components:1};case Xa:case $g:case il:return{byteLength:2,components:1};case lf:case cf:return{byteLength:2,components:4};case Gr:case af:case Un:return{byteLength:4,components:1};case Kg:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}const J2={contain:Y2,cover:j2,fill:$2,getByteLength:SA};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:sf}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=sf);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function cM(){let n=null,e=!1,t=null,i=null;function r(s,o){t(s,o),i=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function Z2(n){const e=new WeakMap;function t(a,l){const c=a.array,h=a.usage,u=c.byteLength,d=n.createBuffer();n.bindBuffer(l,d),n.bufferData(l,c,h),a.onUploadCallback();let f;if(c instanceof Float32Array)f=n.FLOAT;else if(c instanceof Uint16Array)a.isFloat16BufferAttribute?f=n.HALF_FLOAT:f=n.UNSIGNED_SHORT;else if(c instanceof Int16Array)f=n.SHORT;else if(c instanceof Uint32Array)f=n.UNSIGNED_INT;else if(c instanceof Int32Array)f=n.INT;else if(c instanceof Int8Array)f=n.BYTE;else if(c instanceof Uint8Array)f=n.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)f=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:d,type:f,bytesPerElement:c.BYTES_PER_ELEMENT,version:a.version,size:u}}function i(a,l,c){const h=l.array,u=l.updateRanges;if(n.bindBuffer(c,a),u.length===0)n.bufferSubData(c,0,h);else{u.sort((f,A)=>f.start-A.start);let d=0;for(let f=1;f<u.length;f++){const A=u[d],g=u[f];g.start<=A.start+A.count+1?A.count=Math.max(A.count,g.start+g.count-A.start):(++d,u[d]=g)}u.length=d+1;for(let f=0,A=u.length;f<A;f++){const g=u[f];n.bufferSubData(c,g.start*h.BYTES_PER_ELEMENT,h,g.start,g.count)}l.clearUpdateRanges()}l.onUploadCallback()}function r(a){return a.isInterleavedBufferAttribute&&(a=a.data),e.get(a)}function s(a){a.isInterleavedBufferAttribute&&(a=a.data);const l=e.get(a);l&&(n.deleteBuffer(l.buffer),e.delete(a))}function o(a,l){if(a.isInterleavedBufferAttribute&&(a=a.data),a.isGLBufferAttribute){const h=e.get(a);(!h||h.version<a.version)&&e.set(a,{buffer:a.buffer,type:a.type,bytesPerElement:a.elementSize,version:a.version});return}const c=e.get(a);if(c===void 0)e.set(a,t(a,l));else if(c.version<a.version){if(c.size!==a.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");i(c.buffer,a,l),c.version=a.version}}return{get:r,remove:s,update:o}}var eI=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,tI=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,nI=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,iI=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,rI=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,sI=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,oI=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aI=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,lI=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,cI=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,hI=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,uI=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,dI=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,fI=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,pI=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,mI=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,AI=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,gI=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,vI=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,EI=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,xI=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,yI=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,_I=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,bI=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,CI=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,MI=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,SI=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,wI=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,TI=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,II=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,RI="gl_FragColor = linearToOutputTexel( gl_FragColor );",BI=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,LI=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,DI=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,PI=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,UI=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,FI=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,NI=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,OI=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,kI=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,GI=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,zI=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,HI=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,VI=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,QI=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,WI=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,XI=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,qI=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,YI=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,jI=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,$I=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,KI=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,JI=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ZI=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,eR=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,tR=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,nR=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,iR=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,rR=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,sR=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,oR=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,aR=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,lR=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,cR=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,hR=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,uR=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,dR=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,fR=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,pR=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,mR=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,AR=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,gR=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,vR=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,ER=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,xR=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,yR=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,_R=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,bR=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,CR=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,MR=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,SR=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,wR=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,TR=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,IR=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,RR=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,BR=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,LR=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,DR=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,PR=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,UR=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,FR=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,NR=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,OR=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,kR=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,GR=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,zR=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,HR=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,VR=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,QR=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,WR=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,XR=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,qR=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,YR=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,jR=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,$R=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,KR=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,JR=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const ZR=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,eB=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,tB=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,nB=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,iB=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,rB=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,sB=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,oB=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,aB=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,lB=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,cB=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,hB=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,uB=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,dB=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,fB=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,pB=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,mB=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,AB=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,gB=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,vB=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,EB=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,xB=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,yB=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,_B=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bB=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,CB=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,MB=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,SB=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wB=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,TB=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,IB=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,RB=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,BB=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,LB=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vt={alphahash_fragment:eI,alphahash_pars_fragment:tI,alphamap_fragment:nI,alphamap_pars_fragment:iI,alphatest_fragment:rI,alphatest_pars_fragment:sI,aomap_fragment:oI,aomap_pars_fragment:aI,batching_pars_vertex:lI,batching_vertex:cI,begin_vertex:hI,beginnormal_vertex:uI,bsdfs:dI,iridescence_fragment:fI,bumpmap_pars_fragment:pI,clipping_planes_fragment:mI,clipping_planes_pars_fragment:AI,clipping_planes_pars_vertex:gI,clipping_planes_vertex:vI,color_fragment:EI,color_pars_fragment:xI,color_pars_vertex:yI,color_vertex:_I,common:bI,cube_uv_reflection_fragment:CI,defaultnormal_vertex:MI,displacementmap_pars_vertex:SI,displacementmap_vertex:wI,emissivemap_fragment:TI,emissivemap_pars_fragment:II,colorspace_fragment:RI,colorspace_pars_fragment:BI,envmap_fragment:LI,envmap_common_pars_fragment:DI,envmap_pars_fragment:PI,envmap_pars_vertex:UI,envmap_physical_pars_fragment:XI,envmap_vertex:FI,fog_vertex:NI,fog_pars_vertex:OI,fog_fragment:kI,fog_pars_fragment:GI,gradientmap_pars_fragment:zI,lightmap_pars_fragment:HI,lights_lambert_fragment:VI,lights_lambert_pars_fragment:QI,lights_pars_begin:WI,lights_toon_fragment:qI,lights_toon_pars_fragment:YI,lights_phong_fragment:jI,lights_phong_pars_fragment:$I,lights_physical_fragment:KI,lights_physical_pars_fragment:JI,lights_fragment_begin:ZI,lights_fragment_maps:eR,lights_fragment_end:tR,logdepthbuf_fragment:nR,logdepthbuf_pars_fragment:iR,logdepthbuf_pars_vertex:rR,logdepthbuf_vertex:sR,map_fragment:oR,map_pars_fragment:aR,map_particle_fragment:lR,map_particle_pars_fragment:cR,metalnessmap_fragment:hR,metalnessmap_pars_fragment:uR,morphinstance_vertex:dR,morphcolor_vertex:fR,morphnormal_vertex:pR,morphtarget_pars_vertex:mR,morphtarget_vertex:AR,normal_fragment_begin:gR,normal_fragment_maps:vR,normal_pars_fragment:ER,normal_pars_vertex:xR,normal_vertex:yR,normalmap_pars_fragment:_R,clearcoat_normal_fragment_begin:bR,clearcoat_normal_fragment_maps:CR,clearcoat_pars_fragment:MR,iridescence_pars_fragment:SR,opaque_fragment:wR,packing:TR,premultiplied_alpha_fragment:IR,project_vertex:RR,dithering_fragment:BR,dithering_pars_fragment:LR,roughnessmap_fragment:DR,roughnessmap_pars_fragment:PR,shadowmap_pars_fragment:UR,shadowmap_pars_vertex:FR,shadowmap_vertex:NR,shadowmask_pars_fragment:OR,skinbase_vertex:kR,skinning_pars_vertex:GR,skinning_vertex:zR,skinnormal_vertex:HR,specularmap_fragment:VR,specularmap_pars_fragment:QR,tonemapping_fragment:WR,tonemapping_pars_fragment:XR,transmission_fragment:qR,transmission_pars_fragment:YR,uv_pars_fragment:jR,uv_pars_vertex:$R,uv_vertex:KR,worldpos_vertex:JR,background_vert:ZR,background_frag:eB,backgroundCube_vert:tB,backgroundCube_frag:nB,cube_vert:iB,cube_frag:rB,depth_vert:sB,depth_frag:oB,distanceRGBA_vert:aB,distanceRGBA_frag:lB,equirect_vert:cB,equirect_frag:hB,linedashed_vert:uB,linedashed_frag:dB,meshbasic_vert:fB,meshbasic_frag:pB,meshlambert_vert:mB,meshlambert_frag:AB,meshmatcap_vert:gB,meshmatcap_frag:vB,meshnormal_vert:EB,meshnormal_frag:xB,meshphong_vert:yB,meshphong_frag:_B,meshphysical_vert:bB,meshphysical_frag:CB,meshtoon_vert:MB,meshtoon_frag:SB,points_vert:wB,points_frag:TB,shadow_vert:IB,shadow_frag:RB,sprite_vert:BB,sprite_frag:LB},Ye={common:{diffuse:{value:new Ke(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new At},alphaMap:{value:null},alphaMapTransform:{value:new At},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new At}},envmap:{envMap:{value:null},envMapRotation:{value:new At},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new At}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new At}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new At},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new At},normalScale:{value:new Ne(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new At},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new At}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new At}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new At}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ke(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ke(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new At},alphaTest:{value:0},uvTransform:{value:new At}},sprite:{diffuse:{value:new Ke(16777215)},opacity:{value:1},center:{value:new Ne(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new At},alphaMap:{value:null},alphaMapTransform:{value:new At},alphaTest:{value:0}}},Ti={basic:{uniforms:Ln([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.fog]),vertexShader:vt.meshbasic_vert,fragmentShader:vt.meshbasic_frag},lambert:{uniforms:Ln([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,Ye.lights,{emissive:{value:new Ke(0)}}]),vertexShader:vt.meshlambert_vert,fragmentShader:vt.meshlambert_frag},phong:{uniforms:Ln([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,Ye.lights,{emissive:{value:new Ke(0)},specular:{value:new Ke(1118481)},shininess:{value:30}}]),vertexShader:vt.meshphong_vert,fragmentShader:vt.meshphong_frag},standard:{uniforms:Ln([Ye.common,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.roughnessmap,Ye.metalnessmap,Ye.fog,Ye.lights,{emissive:{value:new Ke(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:vt.meshphysical_vert,fragmentShader:vt.meshphysical_frag},toon:{uniforms:Ln([Ye.common,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.gradientmap,Ye.fog,Ye.lights,{emissive:{value:new Ke(0)}}]),vertexShader:vt.meshtoon_vert,fragmentShader:vt.meshtoon_frag},matcap:{uniforms:Ln([Ye.common,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,{matcap:{value:null}}]),vertexShader:vt.meshmatcap_vert,fragmentShader:vt.meshmatcap_frag},points:{uniforms:Ln([Ye.points,Ye.fog]),vertexShader:vt.points_vert,fragmentShader:vt.points_frag},dashed:{uniforms:Ln([Ye.common,Ye.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:vt.linedashed_vert,fragmentShader:vt.linedashed_frag},depth:{uniforms:Ln([Ye.common,Ye.displacementmap]),vertexShader:vt.depth_vert,fragmentShader:vt.depth_frag},normal:{uniforms:Ln([Ye.common,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,{opacity:{value:1}}]),vertexShader:vt.meshnormal_vert,fragmentShader:vt.meshnormal_frag},sprite:{uniforms:Ln([Ye.sprite,Ye.fog]),vertexShader:vt.sprite_vert,fragmentShader:vt.sprite_frag},background:{uniforms:{uvTransform:{value:new At},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:vt.background_vert,fragmentShader:vt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new At}},vertexShader:vt.backgroundCube_vert,fragmentShader:vt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:vt.cube_vert,fragmentShader:vt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:vt.equirect_vert,fragmentShader:vt.equirect_frag},distanceRGBA:{uniforms:Ln([Ye.common,Ye.displacementmap,{referencePosition:{value:new Y},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:vt.distanceRGBA_vert,fragmentShader:vt.distanceRGBA_frag},shadow:{uniforms:Ln([Ye.lights,Ye.fog,{color:{value:new Ke(0)},opacity:{value:1}}]),vertexShader:vt.shadow_vert,fragmentShader:vt.shadow_frag}};Ti.physical={uniforms:Ln([Ti.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new At},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new At},clearcoatNormalScale:{value:new Ne(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new At},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new At},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new At},sheen:{value:0},sheenColor:{value:new Ke(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new At},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new At},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new At},transmissionSamplerSize:{value:new Ne},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new At},attenuationDistance:{value:0},attenuationColor:{value:new Ke(0)},specularColor:{value:new Ke(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new At},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new At},anisotropyVector:{value:new Ne},anisotropyMap:{value:null},anisotropyMapTransform:{value:new At}}]),vertexShader:vt.meshphysical_vert,fragmentShader:vt.meshphysical_frag};const Oh={r:0,b:0,g:0},Ws=new Fi,DB=new ct;function PB(n,e,t,i,r,s,o){const a=new Ke(0);let l=s===!0?0:1,c,h,u=null,d=0,f=null;function A(E){let x=E.isScene===!0?E.background:null;return x&&x.isTexture&&(x=(E.backgroundBlurriness>0?t:e).get(x)),x}function g(E){let x=!1;const M=A(E);M===null?p(a,l):M&&M.isColor&&(p(M,1),x=!0);const w=n.xr.getEnvironmentBlendMode();w==="additive"?i.buffers.color.setClear(0,0,0,1,o):w==="alpha-blend"&&i.buffers.color.setClear(0,0,0,0,o),(n.autoClear||x)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function m(E,x){const M=A(x);M&&(M.isCubeTexture||M.mapping===nl)?(h===void 0&&(h=new en(new Pc(1e4,1e4,1e4),new Ni({name:"BackgroundCubeMaterial",uniforms:Ya(Ti.backgroundCube.uniforms),vertexShader:Ti.backgroundCube.vertexShader,fragmentShader:Ti.backgroundCube.fragmentShader,side:kn,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(w,S,B){this.matrixWorld.copyPosition(B.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(h)),Ws.copy(x.backgroundRotation),Ws.x*=-1,Ws.y*=-1,Ws.z*=-1,M.isCubeTexture&&M.isRenderTargetTexture===!1&&(Ws.y*=-1,Ws.z*=-1),h.material.uniforms.envMap.value=M,h.material.uniforms.flipEnvMap.value=M.isCubeTexture&&M.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=x.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(DB.makeRotationFromEuler(Ws)),h.material.toneMapped=wt.getTransfer(M.colorSpace)!==Ut,(u!==M||d!==M.version||f!==n.toneMapping)&&(h.material.needsUpdate=!0,u=M,d=M.version,f=n.toneMapping),h.layers.enableAll(),E.unshift(h,h.geometry,h.material,0,0,null)):M&&M.isTexture&&(c===void 0&&(c=new en(new Bf(2,2),new Ni({name:"BackgroundMaterial",uniforms:Ya(Ti.background.uniforms),vertexShader:Ti.background.vertexShader,fragmentShader:Ti.background.fragmentShader,side:Or,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(c)),c.material.uniforms.t2D.value=M,c.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,c.material.toneMapped=wt.getTransfer(M.colorSpace)!==Ut,M.matrixAutoUpdate===!0&&M.updateMatrix(),c.material.uniforms.uvTransform.value.copy(M.matrix),(u!==M||d!==M.version||f!==n.toneMapping)&&(c.material.needsUpdate=!0,u=M,d=M.version,f=n.toneMapping),c.layers.enableAll(),E.unshift(c,c.geometry,c.material,0,0,null))}function p(E,x){E.getRGB(Oh,aC(n)),i.buffers.color.setClear(Oh.r,Oh.g,Oh.b,x,o)}function v(){h!==void 0&&(h.geometry.dispose(),h.material.dispose(),h=void 0),c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0)}return{getClearColor:function(){return a},setClearColor:function(E,x=1){a.set(E),l=x,p(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(E){l=E,p(a,l)},render:g,addToRenderList:m,dispose:v}}function UB(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),i={},r=d(null);let s=r,o=!1;function a(_,L,Q,O,X){let te=!1;const W=u(O,Q,L);s!==W&&(s=W,c(s.object)),te=f(_,O,Q,X),te&&A(_,O,Q,X),X!==null&&e.update(X,n.ELEMENT_ARRAY_BUFFER),(te||o)&&(o=!1,x(_,L,Q,O),X!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(X).buffer))}function l(){return n.createVertexArray()}function c(_){return n.bindVertexArray(_)}function h(_){return n.deleteVertexArray(_)}function u(_,L,Q){const O=Q.wireframe===!0;let X=i[_.id];X===void 0&&(X={},i[_.id]=X);let te=X[L.id];te===void 0&&(te={},X[L.id]=te);let W=te[O];return W===void 0&&(W=d(l()),te[O]=W),W}function d(_){const L=[],Q=[],O=[];for(let X=0;X<t;X++)L[X]=0,Q[X]=0,O[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:Q,attributeDivisors:O,object:_,attributes:{},index:null}}function f(_,L,Q,O){const X=s.attributes,te=L.attributes;let W=0;const Z=Q.getAttributes();for(const q in Z)if(Z[q].location>=0){const ue=X[q];let _e=te[q];if(_e===void 0&&(q==="instanceMatrix"&&_.instanceMatrix&&(_e=_.instanceMatrix),q==="instanceColor"&&_.instanceColor&&(_e=_.instanceColor)),ue===void 0||ue.attribute!==_e||_e&&ue.data!==_e.data)return!0;W++}return s.attributesNum!==W||s.index!==O}function A(_,L,Q,O){const X={},te=L.attributes;let W=0;const Z=Q.getAttributes();for(const q in Z)if(Z[q].location>=0){let ue=te[q];ue===void 0&&(q==="instanceMatrix"&&_.instanceMatrix&&(ue=_.instanceMatrix),q==="instanceColor"&&_.instanceColor&&(ue=_.instanceColor));const _e={};_e.attribute=ue,ue&&ue.data&&(_e.data=ue.data),X[q]=_e,W++}s.attributes=X,s.attributesNum=W,s.index=O}function g(){const _=s.newAttributes;for(let L=0,Q=_.length;L<Q;L++)_[L]=0}function m(_){p(_,0)}function p(_,L){const Q=s.newAttributes,O=s.enabledAttributes,X=s.attributeDivisors;Q[_]=1,O[_]===0&&(n.enableVertexAttribArray(_),O[_]=1),X[_]!==L&&(n.vertexAttribDivisor(_,L),X[_]=L)}function v(){const _=s.newAttributes,L=s.enabledAttributes;for(let Q=0,O=L.length;Q<O;Q++)L[Q]!==_[Q]&&(n.disableVertexAttribArray(Q),L[Q]=0)}function E(_,L,Q,O,X,te,W){W===!0?n.vertexAttribIPointer(_,L,Q,X,te):n.vertexAttribPointer(_,L,Q,O,X,te)}function x(_,L,Q,O){g();const X=O.attributes,te=Q.getAttributes(),W=L.defaultAttributeValues;for(const Z in te){const q=te[Z];if(q.location>=0){let re=X[Z];if(re===void 0&&(Z==="instanceMatrix"&&_.instanceMatrix&&(re=_.instanceMatrix),Z==="instanceColor"&&_.instanceColor&&(re=_.instanceColor)),re!==void 0){const ue=re.normalized,_e=re.itemSize,Be=e.get(re);if(Be===void 0)continue;const ze=Be.buffer,le=Be.type,Ee=Be.bytesPerElement,Ue=le===n.INT||le===n.UNSIGNED_INT||re.gpuType===af;if(re.isInterleavedBufferAttribute){const pe=re.data,oe=pe.stride,we=re.offset;if(pe.isInstancedInterleavedBuffer){for(let Me=0;Me<q.locationSize;Me++)p(q.location+Me,pe.meshPerAttribute);_.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=pe.meshPerAttribute*pe.count)}else for(let Me=0;Me<q.locationSize;Me++)m(q.location+Me);n.bindBuffer(n.ARRAY_BUFFER,ze);for(let Me=0;Me<q.locationSize;Me++)E(q.location+Me,_e/q.locationSize,le,ue,oe*Ee,(we+_e/q.locationSize*Me)*Ee,Ue)}else{if(re.isInstancedBufferAttribute){for(let pe=0;pe<q.locationSize;pe++)p(q.location+pe,re.meshPerAttribute);_.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=re.meshPerAttribute*re.count)}else for(let pe=0;pe<q.locationSize;pe++)m(q.location+pe);n.bindBuffer(n.ARRAY_BUFFER,ze);for(let pe=0;pe<q.locationSize;pe++)E(q.location+pe,_e/q.locationSize,le,ue,_e*Ee,_e/q.locationSize*pe*Ee,Ue)}}else if(W!==void 0){const ue=W[Z];if(ue!==void 0)switch(ue.length){case 2:n.vertexAttrib2fv(q.location,ue);break;case 3:n.vertexAttrib3fv(q.location,ue);break;case 4:n.vertexAttrib4fv(q.location,ue);break;default:n.vertexAttrib1fv(q.location,ue)}}}}v()}function M(){B();for(const _ in i){const L=i[_];for(const Q in L){const O=L[Q];for(const X in O)h(O[X].object),delete O[X];delete L[Q]}delete i[_]}}function w(_){if(i[_.id]===void 0)return;const L=i[_.id];for(const Q in L){const O=L[Q];for(const X in O)h(O[X].object),delete O[X];delete L[Q]}delete i[_.id]}function S(_){for(const L in i){const Q=i[L];if(Q[_.id]===void 0)continue;const O=Q[_.id];for(const X in O)h(O[X].object),delete O[X];delete Q[_.id]}}function B(){y(),o=!0,s!==r&&(s=r,c(s.object))}function y(){r.geometry=null,r.program=null,r.wireframe=!1}return{setup:a,reset:B,resetDefaultState:y,dispose:M,releaseStatesOfGeometry:w,releaseStatesOfProgram:S,initAttributes:g,enableAttribute:m,disableUnusedAttributes:v}}function FB(n,e,t){let i;function r(c){i=c}function s(c,h){n.drawArrays(i,c,h),t.update(h,i,1)}function o(c,h,u){u!==0&&(n.drawArraysInstanced(i,c,h,u),t.update(h,i,u))}function a(c,h,u){if(u===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i,c,0,h,0,u);let f=0;for(let A=0;A<u;A++)f+=h[A];t.update(f,i,1)}function l(c,h,u,d){if(u===0)return;const f=e.get("WEBGL_multi_draw");if(f===null)for(let A=0;A<c.length;A++)o(c[A],h[A],d[A]);else{f.multiDrawArraysInstancedWEBGL(i,c,0,h,0,d,0,u);let A=0;for(let g=0;g<u;g++)A+=h[g]*d[g];t.update(A,i,1)}}this.setMode=r,this.render=s,this.renderInstances=o,this.renderMultiDraw=a,this.renderMultiDrawInstances=l}function NB(n,e,t,i){let r;function s(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");r=n.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function o(S){return!(S!==On&&i.convert(S)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function a(S){const B=S===il&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(S!==er&&i.convert(S)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&S!==Un&&!B)}function l(S){if(S==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";S="mediump"}return S==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=t.precision!==void 0?t.precision:"highp";const h=l(c);h!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",h,"instead."),c=h);const u=t.logarithmicDepthBuffer===!0,d=t.reverseDepthBuffer===!0&&e.has("EXT_clip_control"),f=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),A=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=n.getParameter(n.MAX_TEXTURE_SIZE),m=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),p=n.getParameter(n.MAX_VERTEX_ATTRIBS),v=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),E=n.getParameter(n.MAX_VARYING_VECTORS),x=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),M=A>0,w=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:l,textureFormatReadable:o,textureTypeReadable:a,precision:c,logarithmicDepthBuffer:u,reverseDepthBuffer:d,maxTextures:f,maxVertexTextures:A,maxTextureSize:g,maxCubemapSize:m,maxAttributes:p,maxVertexUniforms:v,maxVaryings:E,maxFragmentUniforms:x,vertexTextures:M,maxSamples:w}}function OB(n){const e=this;let t=null,i=0,r=!1,s=!1;const o=new cs,a=new At,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d){const f=u.length!==0||d||i!==0||r;return r=d,i=u.length,f},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(u,d){t=h(u,d,0)},this.setState=function(u,d,f){const A=u.clippingPlanes,g=u.clipIntersection,m=u.clipShadows,p=n.get(u);if(!r||A===null||A.length===0||s&&!m)s?h(null):c();else{const v=s?0:i,E=v*4;let x=p.clippingState||null;l.value=x,x=h(A,d,E,f);for(let M=0;M!==E;++M)x[M]=t[M];p.clippingState=x,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=v}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function h(u,d,f,A){const g=u!==null?u.length:0;let m=null;if(g!==0){if(m=l.value,A!==!0||m===null){const p=f+g*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(m===null||m.length<p)&&(m=new Float32Array(p));for(let E=0,x=f;E!==g;++E,x+=4)o.copy(u[E]).applyMatrix4(v,a),o.normal.toArray(m,x),m[x+3]=o.constant}l.value=m,l.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,m}}function kB(n){let e=new WeakMap;function t(o,a){return a===ic?o.mapping=kr:a===rc&&(o.mapping=bs),o}function i(o){if(o&&o.isTexture){const a=o.mapping;if(a===ic||a===rc)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new hC(l.height);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",r),t(c.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:i,dispose:s}}const Fa=4,DE=[.125,.215,.35,.446,.526,.582],fo=20,Fp=new Of,PE=new Ke;let Np=null,Op=0,kp=0,Gp=!1;const co=(1+Math.sqrt(5))/2,oa=1/co,UE=[new Y(-co,oa,0),new Y(co,oa,0),new Y(-oa,0,co),new Y(oa,0,co),new Y(0,co,-oa),new Y(0,co,oa),new Y(-1,1,-1),new Y(1,1,-1),new Y(-1,1,1),new Y(1,1,1)];let wA=class{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100){Np=this._renderer.getRenderTarget(),Op=this._renderer.getActiveCubeFace(),kp=this._renderer.getActiveMipmapLevel(),Gp=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,i,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=OE(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=NE(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Np,Op,kp),this._renderer.xr.enabled=Gp,e.scissorTest=!1,kh(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===kr||e.mapping===bs?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Np=this._renderer.getRenderTarget(),Op=this._renderer.getActiveCubeFace(),kp=this._renderer.getActiveMipmapLevel(),Gp=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:ln,minFilter:ln,generateMipmaps:!1,type:il,format:On,colorSpace:Io,depthBuffer:!1},r=FE(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=FE(e,t,i);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=GB(s)),this._blurMaterial=zB(s,e,t)}return r}_compileMaterial(e){const t=new en(this._lodPlanes[0],e);this._renderer.compile(t,Fp)}_sceneToCubeUV(e,t,i,r){const a=new gn(90,1,t,i),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,u=h.autoClear,d=h.toneMapping;h.getClearColor(PE),h.toneMapping=Dr,h.autoClear=!1;const f=new Rs({name:"PMREM.Background",side:kn,depthWrite:!1,depthTest:!1}),A=new en(new Pc,f);let g=!1;const m=e.background;m?m.isColor&&(f.color.copy(m),e.background=null,g=!0):(f.color.copy(PE),g=!0);for(let p=0;p<6;p++){const v=p%3;v===0?(a.up.set(0,l[p],0),a.lookAt(c[p],0,0)):v===1?(a.up.set(0,0,l[p]),a.lookAt(0,c[p],0)):(a.up.set(0,l[p],0),a.lookAt(0,0,c[p]));const E=this._cubeSize;kh(r,v*E,p>2?E:0,E,E),h.setRenderTarget(r),g&&h.render(A,a),h.render(e,a)}A.geometry.dispose(),A.material.dispose(),h.toneMapping=d,h.autoClear=u,e.background=m}_textureToCubeUV(e,t){const i=this._renderer,r=e.mapping===kr||e.mapping===bs;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=OE()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=NE());const s=r?this._cubemapMaterial:this._equirectMaterial,o=new en(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;kh(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,Fp)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let s=1;s<r;s++){const o=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),a=UE[(r-s-1)%UE.length];this._blur(e,s-1,s,o,a)}t.autoClear=i}_blur(e,t,i,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,r,"latitudinal",s),this._halfBlur(o,e,i,i,r,"longitudinal",s)}_halfBlur(e,t,i,r,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,u=new en(this._lodPlanes[r],c),d=c.uniforms,f=this._sizeLods[i]-1,A=isFinite(s)?Math.PI/(2*f):2*Math.PI/(2*fo-1),g=s/A,m=isFinite(s)?1+Math.floor(h*g):fo;m>fo&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${fo}`);const p=[];let v=0;for(let S=0;S<fo;++S){const B=S/g,y=Math.exp(-B*B/2);p.push(y),S===0?v+=y:S<m&&(v+=2*y)}for(let S=0;S<p.length;S++)p[S]=p[S]/v;d.envMap.value=e.texture,d.samples.value=m,d.weights.value=p,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:E}=this;d.dTheta.value=A,d.mipInt.value=E-i;const x=this._sizeLods[r],M=3*x*(r>E-Fa?r-E+Fa:0),w=4*(this._cubeSize-x);kh(t,M,w,3*x,2*x),l.setRenderTarget(t),l.render(u,Fp)}};function GB(n){const e=[],t=[],i=[];let r=n;const s=n-Fa+1+DE.length;for(let o=0;o<s;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-Fa?l=DE[o-n+Fa-1]:o===0&&(l=0),i.push(l);const c=1/(a-2),h=-c,u=1+c,d=[h,h,u,h,u,u,h,h,u,u,h,u],f=6,A=6,g=3,m=2,p=1,v=new Float32Array(g*A*f),E=new Float32Array(m*A*f),x=new Float32Array(p*A*f);for(let w=0;w<f;w++){const S=w%3*2/3-1,B=w>2?0:-1,y=[S,B,0,S+2/3,B,0,S+2/3,B+1,0,S,B,0,S+2/3,B+1,0,S,B+1,0];v.set(y,g*A*w),E.set(d,m*A*w);const _=[w,w,w,w,w,w];x.set(_,p*A*w)}const M=new yt;M.setAttribute("position",new Gt(v,g)),M.setAttribute("uv",new Gt(E,m)),M.setAttribute("faceIndex",new Gt(x,p)),e.push(M),r>Fa&&r--}return{lodPlanes:e,sizeLods:t,sigmas:i}}function FE(n,e,t){const i=new Ui(n,e,t);return i.texture.mapping=nl,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function kh(n,e,t,i,r){n.viewport.set(e,t,i,r),n.scissor.set(e,t,i,r)}function zB(n,e,t){const i=new Float32Array(fo),r=new Y(0,1,0);return new Ni({name:"SphericalGaussianBlur",defines:{n:fo,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:L0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Lr,depthTest:!1,depthWrite:!1})}function NE(){return new Ni({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:L0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Lr,depthTest:!1,depthWrite:!1})}function OE(){return new Ni({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:L0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Lr,depthTest:!1,depthWrite:!1})}function L0(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function HB(n){let e=new WeakMap,t=null;function i(a){if(a&&a.isTexture){const l=a.mapping,c=l===ic||l===rc,h=l===kr||l===bs;if(c||h){let u=e.get(a);const d=u!==void 0?u.texture.pmremVersion:0;if(a.isRenderTargetTexture&&a.pmremVersion!==d)return t===null&&(t=new wA(n)),u=c?t.fromEquirectangular(a,u):t.fromCubemap(a,u),u.texture.pmremVersion=a.pmremVersion,e.set(a,u),u.texture;if(u!==void 0)return u.texture;{const f=a.image;return c&&f&&f.height>0||h&&f&&r(f)?(t===null&&(t=new wA(n)),u=c?t.fromEquirectangular(a):t.fromCubemap(a),u.texture.pmremVersion=a.pmremVersion,e.set(a,u),a.addEventListener("dispose",s),u.texture):null}}}return a}function r(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function s(a){const l=a.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:o}}function VB(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return e[i]=r,r}return{has:function(i){return t(i)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(i){const r=t(i);return r===null&&Ta("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function QB(n,e,t,i){const r={},s=new WeakMap;function o(u){const d=u.target;d.index!==null&&e.remove(d.index);for(const A in d.attributes)e.remove(d.attributes[A]);d.removeEventListener("dispose",o),delete r[d.id];const f=s.get(d);f&&(e.remove(f),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(u,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(u){const d=u.attributes;for(const f in d)e.update(d[f],n.ARRAY_BUFFER)}function c(u){const d=[],f=u.index,A=u.attributes.position;let g=0;if(f!==null){const v=f.array;g=f.version;for(let E=0,x=v.length;E<x;E+=3){const M=v[E+0],w=v[E+1],S=v[E+2];d.push(M,w,w,S,S,M)}}else if(A!==void 0){const v=A.array;g=A.version;for(let E=0,x=v.length/3-1;E<x;E+=3){const M=E+0,w=E+1,S=E+2;d.push(M,w,w,S,S,M)}}else return;const m=new(Jb(d)?l0:a0)(d,1);m.version=g;const p=s.get(u);p&&e.remove(p),s.set(u,m)}function h(u){const d=s.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return s.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function WB(n,e,t){let i;function r(d){i=d}let s,o;function a(d){s=d.type,o=d.bytesPerElement}function l(d,f){n.drawElements(i,f,s,d*o),t.update(f,i,1)}function c(d,f,A){A!==0&&(n.drawElementsInstanced(i,f,s,d*o,A),t.update(f,i,A))}function h(d,f,A){if(A===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i,f,0,s,d,0,A);let m=0;for(let p=0;p<A;p++)m+=f[p];t.update(m,i,1)}function u(d,f,A,g){if(A===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let p=0;p<d.length;p++)c(d[p]/o,f[p],g[p]);else{m.multiDrawElementsInstancedWEBGL(i,f,0,s,d,0,g,0,A);let p=0;for(let v=0;v<A;v++)p+=f[v]*g[v];t.update(p,i,1)}}this.setMode=r,this.setIndex=a,this.render=l,this.renderInstances=c,this.renderMultiDraw=h,this.renderMultiDrawInstances=u}function XB(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(s/3);break;case n.LINES:t.lines+=a*(s/2);break;case n.LINE_STRIP:t.lines+=a*(s-1);break;case n.LINE_LOOP:t.lines+=a*s;break;case n.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:i}}function qB(n,e,t){const i=new WeakMap,r=new Dt;function s(o,a,l){const c=o.morphTargetInfluences,h=a.morphAttributes.position||a.morphAttributes.normal||a.morphAttributes.color,u=h!==void 0?h.length:0;let d=i.get(a);if(d===void 0||d.count!==u){let y=function(){S.dispose(),i.delete(a),a.removeEventListener("dispose",y)};d!==void 0&&d.texture.dispose();const f=a.morphAttributes.position!==void 0,A=a.morphAttributes.normal!==void 0,g=a.morphAttributes.color!==void 0,m=a.morphAttributes.position||[],p=a.morphAttributes.normal||[],v=a.morphAttributes.color||[];let E=0;f===!0&&(E=1),A===!0&&(E=2),g===!0&&(E=3);let x=a.attributes.position.count*E,M=1;x>e.maxTextureSize&&(M=Math.ceil(x/e.maxTextureSize),x=e.maxTextureSize);const w=new Float32Array(x*M*4*u),S=new Dc(w,x,M,u);S.type=Un,S.needsUpdate=!0;const B=E*4;for(let _=0;_<u;_++){const L=m[_],Q=p[_],O=v[_],X=x*M*4*_;for(let te=0;te<L.count;te++){const W=te*B;f===!0&&(r.fromBufferAttribute(L,te),w[X+W+0]=r.x,w[X+W+1]=r.y,w[X+W+2]=r.z,w[X+W+3]=0),A===!0&&(r.fromBufferAttribute(Q,te),w[X+W+4]=r.x,w[X+W+5]=r.y,w[X+W+6]=r.z,w[X+W+7]=0),g===!0&&(r.fromBufferAttribute(O,te),w[X+W+8]=r.x,w[X+W+9]=r.y,w[X+W+10]=r.z,w[X+W+11]=O.itemSize===4?r.w:1)}}d={count:u,texture:S,size:new Ne(x,M)},i.set(a,d),a.addEventListener("dispose",y)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)l.getUniforms().setValue(n,"morphTexture",o.morphTexture,t);else{let f=0;for(let g=0;g<c.length;g++)f+=c[g];const A=a.morphTargetsRelative?1:1-f;l.getUniforms().setValue(n,"morphTargetBaseInfluence",A),l.getUniforms().setValue(n,"morphTargetInfluences",c)}l.getUniforms().setValue(n,"morphTargetsTexture",d.texture,t),l.getUniforms().setValue(n,"morphTargetsTextureSize",d.size)}return{update:s}}class YB{constructor(e,t,i){if(this.renderer=e,this.DEFAULT_NUMVIEWS=2,this.maxNumViews=0,this.gl=i,this.extensions=t,this.available=this.extensions.has("OCULUS_multiview"),this.available){const s=this.extensions.get("OCULUS_multiview");this.maxNumViews=this.gl.getParameter(s.MAX_VIEWS_OVR),this.mat4=[],this.mat3=[],this.cameraArray=[];for(var r=0;r<this.maxNumViews;r++)this.mat4[r]=new ct,this.mat3[r]=new At}}getCameraArray(e){return e.isArrayCamera?e.cameras:(this.cameraArray[0]=e,this.cameraArray)}updateCameraProjectionMatricesUniform(e,t){for(var i=this.getCameraArray(e),r=0;r<i.length;r++)this.mat4[r].copy(i[r].projectionMatrix);t.setValue(this.gl,"projectionMatrices",this.mat4)}updateCameraViewMatricesUniform(e,t){for(var i=this.getCameraArray(e),r=0;r<i.length;r++)this.mat4[r].copy(i[r].matrixWorldInverse);t.setValue(this.gl,"viewMatrices",this.mat4)}updateObjectMatricesUniforms(e,t,i){for(var r=this.getCameraArray(t),s=0;s<r.length;s++)this.mat4[s].multiplyMatrices(r[s].matrixWorldInverse,e.matrixWorld),this.mat3[s].getNormalMatrix(this.mat4[s]);i.setValue(this.gl,"modelViewMatrices",this.mat4),i.setValue(this.gl,"normalMatrices",this.mat3)}}function jB(n,e,t,i){let r=new WeakMap;function s(l){const c=i.render.frame,h=l.geometry,u=e.get(l,h);if(r.get(u)!==c&&(e.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),r.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),r.set(l,c))),l.isSkinnedMesh){const d=l.skeleton;r.get(d)!==c&&(d.update(),r.set(d,c))}return u}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}const hM=new mn,kE=new d0(1,1),uM=new Dc,dM=new mf,fM=new Uc,GE=[],zE=[],HE=new Float32Array(16),VE=new Float32Array(9),QE=new Float32Array(4);function ol(n,e,t){const i=n[0];if(i<=0||i>0)return n;const r=e*t;let s=GE[r];if(s===void 0&&(s=new Float32Array(r),GE[r]=s),e!==0){i.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function cn(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function hn(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function Gf(n,e){let t=zE[e];t===void 0&&(t=new Int32Array(e),zE[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function $B(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function KB(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(cn(t,e))return;n.uniform2fv(this.addr,e),hn(t,e)}}function JB(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(cn(t,e))return;n.uniform3fv(this.addr,e),hn(t,e)}}function ZB(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(cn(t,e))return;n.uniform4fv(this.addr,e),hn(t,e)}}function eL(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(cn(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),hn(t,e)}else{if(cn(t,i))return;QE.set(i),n.uniformMatrix2fv(this.addr,!1,QE),hn(t,i)}}function tL(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(cn(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),hn(t,e)}else{if(cn(t,i))return;VE.set(i),n.uniformMatrix3fv(this.addr,!1,VE),hn(t,i)}}function nL(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(cn(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),hn(t,e)}else{if(cn(t,i))return;HE.set(i),n.uniformMatrix4fv(this.addr,!1,HE),hn(t,i)}}function iL(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function rL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(cn(t,e))return;n.uniform2iv(this.addr,e),hn(t,e)}}function sL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(cn(t,e))return;n.uniform3iv(this.addr,e),hn(t,e)}}function oL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(cn(t,e))return;n.uniform4iv(this.addr,e),hn(t,e)}}function aL(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function lL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(cn(t,e))return;n.uniform2uiv(this.addr,e),hn(t,e)}}function cL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(cn(t,e))return;n.uniform3uiv(this.addr,e),hn(t,e)}}function hL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(cn(t,e))return;n.uniform4uiv(this.addr,e),hn(t,e)}}function uL(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r);let s;this.type===n.SAMPLER_2D_SHADOW?(kE.compareFunction=s0,s=kE):s=hM,t.setTexture2D(e||s,r)}function dL(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(e||dM,r)}function fL(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTextureCube(e||fM,r)}function pL(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(e||uM,r)}function mL(n){switch(n){case 5126:return $B;case 35664:return KB;case 35665:return JB;case 35666:return ZB;case 35674:return eL;case 35675:return tL;case 35676:return nL;case 5124:case 35670:return iL;case 35667:case 35671:return rL;case 35668:case 35672:return sL;case 35669:case 35673:return oL;case 5125:return aL;case 36294:return lL;case 36295:return cL;case 36296:return hL;case 35678:case 36198:case 36298:case 36306:case 35682:return uL;case 35679:case 36299:case 36307:return dL;case 35680:case 36300:case 36308:case 36293:return fL;case 36289:case 36303:case 36311:case 36292:return pL}}function AL(n,e){n.uniform1fv(this.addr,e)}function gL(n,e){const t=ol(e,this.size,2);n.uniform2fv(this.addr,t)}function vL(n,e){const t=ol(e,this.size,3);n.uniform3fv(this.addr,t)}function EL(n,e){const t=ol(e,this.size,4);n.uniform4fv(this.addr,t)}function xL(n,e){const t=ol(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function yL(n,e){const t=ol(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function _L(n,e){const t=ol(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function bL(n,e){n.uniform1iv(this.addr,e)}function CL(n,e){n.uniform2iv(this.addr,e)}function ML(n,e){n.uniform3iv(this.addr,e)}function SL(n,e){n.uniform4iv(this.addr,e)}function wL(n,e){n.uniform1uiv(this.addr,e)}function TL(n,e){n.uniform2uiv(this.addr,e)}function IL(n,e){n.uniform3uiv(this.addr,e)}function RL(n,e){n.uniform4uiv(this.addr,e)}function BL(n,e,t){const i=this.cache,r=e.length,s=Gf(t,r);cn(i,s)||(n.uniform1iv(this.addr,s),hn(i,s));for(let o=0;o!==r;++o)t.setTexture2D(e[o]||hM,s[o])}function LL(n,e,t){const i=this.cache,r=e.length,s=Gf(t,r);cn(i,s)||(n.uniform1iv(this.addr,s),hn(i,s));for(let o=0;o!==r;++o)t.setTexture3D(e[o]||dM,s[o])}function DL(n,e,t){const i=this.cache,r=e.length,s=Gf(t,r);cn(i,s)||(n.uniform1iv(this.addr,s),hn(i,s));for(let o=0;o!==r;++o)t.setTextureCube(e[o]||fM,s[o])}function PL(n,e,t){const i=this.cache,r=e.length,s=Gf(t,r);cn(i,s)||(n.uniform1iv(this.addr,s),hn(i,s));for(let o=0;o!==r;++o)t.setTexture2DArray(e[o]||uM,s[o])}function UL(n){switch(n){case 5126:return AL;case 35664:return gL;case 35665:return vL;case 35666:return EL;case 35674:return xL;case 35675:return yL;case 35676:return _L;case 5124:case 35670:return bL;case 35667:case 35671:return CL;case 35668:case 35672:return ML;case 35669:case 35673:return SL;case 5125:return wL;case 36294:return TL;case 36295:return IL;case 36296:return RL;case 35678:case 36198:case 36298:case 36306:case 35682:return BL;case 35679:case 36299:case 36307:return LL;case 35680:case 36300:case 36308:case 36293:return DL;case 36289:case 36303:case 36311:case 36292:return PL}}let FL=class{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.type=t.type,this.setValue=mL(t.type)}},NL=class{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=UL(t.type)}},OL=class{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,i){const r=this.seq;for(let s=0,o=r.length;s!==o;++s){const a=r[s];a.setValue(e,t[a.id],i)}}};const zp=/(\w+)(\])?(\[|\.)?/g;function WE(n,e){n.seq.push(e),n.map[e.id]=e}function kL(n,e,t){const i=n.name,r=i.length;for(zp.lastIndex=0;;){const s=zp.exec(i),o=zp.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){WE(t,c===void 0?new FL(a,n,e):new NL(a,n,e));break}else{let u=t.map[a];u===void 0&&(u=new OL(a),WE(t,u)),t=u}}}let ku=class{constructor(e,t){this.seq=[],this.map={};const i=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<i;++r){const s=e.getActiveUniform(t,r),o=e.getUniformLocation(t,s.name);kL(s,o,this)}}setValue(e,t,i,r){const s=this.map[t];s!==void 0&&s.setValue(e,i,r)}setOptional(e,t,i){const r=t[i];r!==void 0&&this.setValue(e,i,r)}static upload(e,t,i,r){for(let s=0,o=t.length;s!==o;++s){const a=t[s],l=i[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,r)}}static seqWithValue(e,t){const i=[];for(let r=0,s=e.length;r!==s;++r){const o=e[r];o.id in t&&i.push(o)}return i}};function XE(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}const GL=37297;let zL=0;function HL(n,e){const t=n.split(`
`),i=[],r=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=r;o<s;o++){const a=o+1;i.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return i.join(`
`)}const qE=new At;function VL(n){wt._getMatrix(qE,wt.workingColorSpace,n);const e=`mat3( ${qE.elements.map(t=>t.toFixed(4))} )`;switch(wt.getTransfer(n)){case cc:return[e,"LinearTransferOETF"];case Ut:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",n),[e,"LinearTransferOETF"]}}function YE(n,e,t){const i=n.getShaderParameter(e,n.COMPILE_STATUS),r=n.getShaderInfoLog(e).trim();if(i&&r==="")return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+r+`

`+HL(n.getShaderSource(e),o)}else return r}function QL(n,e){const t=VL(e);return[`vec4 ${n}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function WL(n,e){let t;switch(e){case Ib:t="Linear";break;case Rb:t="Reinhard";break;case Bb:t="Cineon";break;case Lb:t="ACESFilmic";break;case Pb:t="AgX";break;case Ub:t="Neutral";break;case Db:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const Gh=new Y;function XL(){wt.getLuminanceCoefficients(Gh);const n=Gh.x.toFixed(4),e=Gh.y.toFixed(4),t=Gh.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function qL(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Gl).join(`
`)}function YL(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function jL(n,e){const t={},i=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const s=n.getActiveAttrib(e,r),o=s.name;let a=1;s.type===n.FLOAT_MAT2&&(a=2),s.type===n.FLOAT_MAT3&&(a=3),s.type===n.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Gl(n){return n!==""}function jE(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function $E(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const $L=/^[ \t]*#include +<([\w\d./]+)>/gm;function TA(n){return n.replace($L,JL)}const KL=new Map;function JL(n,e){let t=vt[e];if(t===void 0){const i=KL.get(e);if(i!==void 0)t=vt[i],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,i);else throw new Error("Can not resolve #include <"+e+">")}return TA(t)}const ZL=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function KE(n){return n.replace(ZL,eD)}function eD(n,e,t,i){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function JE(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function tD(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===qg?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===lb?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Qi&&(e="SHADOWMAP_TYPE_VSM"),e}function nD(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case kr:case bs:e="ENVMAP_TYPE_CUBE";break;case nl:e="ENVMAP_TYPE_CUBE_UV";break}return e}function iD(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case bs:e="ENVMAP_MODE_REFRACTION";break}return e}function rD(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Bc:e="ENVMAP_BLENDING_MULTIPLY";break;case wb:e="ENVMAP_BLENDING_MIX";break;case Tb:e="ENVMAP_BLENDING_ADD";break}return e}function sD(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:i,maxMip:t}}function oD(n,e,t,i){const r=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=tD(t),c=nD(t),h=iD(t),u=rD(t),d=sD(t),f=qL(t),A=YL(s),g=r.createProgram();let m,p,v=t.glslVersion?"#version "+t.glslVersion+`
`:"";const E=t.numMultiviewViews;t.isRawShaderMaterial?(m=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A].filter(Gl).join(`
`),m.length>0&&(m+=`
`),p=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A].filter(Gl).join(`
`),p.length>0&&(p+=`
`)):(m=[JE(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Gl).join(`
`),p=[JE(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Dr?"#define TONE_MAPPING":"",t.toneMapping!==Dr?vt.tonemapping_pars_fragment:"",t.toneMapping!==Dr?WL("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",vt.colorspace_pars_fragment,QL("linearToOutputTexel",t.outputColorSpace),XL(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Gl).join(`
`)),o=TA(o),o=jE(o,t),o=$E(o,t),a=TA(a),a=jE(a,t),a=$E(a,t),o=KE(o),a=KE(a),t.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,m=[f,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,p=["#define varying in",t.glslVersion===vA?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===vA?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+p,E>0&&(m=["#extension GL_OVR_multiview : require","layout(num_views = "+E+") in;","#define VIEW_ID gl_ViewID_OVR"].join(`
`)+`
`+m,m=m.replace(["uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;"].join(`
`),["uniform mat4 modelViewMatrices["+E+"];","uniform mat4 projectionMatrices["+E+"];","uniform mat4 viewMatrices["+E+"];","uniform mat3 normalMatrices["+E+"];","#define modelViewMatrix modelViewMatrices[VIEW_ID]","#define projectionMatrix projectionMatrices[VIEW_ID]","#define viewMatrix viewMatrices[VIEW_ID]","#define normalMatrix normalMatrices[VIEW_ID]"].join(`
`)),p=["#extension GL_OVR_multiview : require","#define VIEW_ID gl_ViewID_OVR"].join(`
`)+`
`+p,p=p.replace("uniform mat4 viewMatrix;",["uniform mat4 viewMatrices["+E+"];","#define viewMatrix viewMatrices[VIEW_ID]"].join(`
`))));const x=v+m+o,M=v+p+a,w=XE(r,r.VERTEX_SHADER,x),S=XE(r,r.FRAGMENT_SHADER,M);r.attachShader(g,w),r.attachShader(g,S),t.index0AttributeName!==void 0?r.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(g,0,"position"),r.linkProgram(g);function B(Q){if(n.debug.checkShaderErrors){const O=r.getProgramInfoLog(g).trim(),X=r.getShaderInfoLog(w).trim(),te=r.getShaderInfoLog(S).trim();let W=!0,Z=!0;if(r.getProgramParameter(g,r.LINK_STATUS)===!1)if(W=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(r,g,w,S);else{const q=YE(r,w,"vertex"),re=YE(r,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(g,r.VALIDATE_STATUS)+`

Material Name: `+Q.name+`
Material Type: `+Q.type+`

Program Info Log: `+O+`
`+q+`
`+re)}else O!==""?console.warn("THREE.WebGLProgram: Program Info Log:",O):(X===""||te==="")&&(Z=!1);Z&&(Q.diagnostics={runnable:W,programLog:O,vertexShader:{log:X,prefix:m},fragmentShader:{log:te,prefix:p}})}r.deleteShader(w),r.deleteShader(S),y=new ku(r,g),_=jL(r,g)}let y;this.getUniforms=function(){return y===void 0&&B(this),y};let _;this.getAttributes=function(){return _===void 0&&B(this),_};let L=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return L===!1&&(L=r.getProgramParameter(g,GL)),L},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(g),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=zL++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=w,this.fragmentShader=S,this.numMultiviewViews=E,this}let aD=0,lD=class{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,r=this._getShaderStage(t),s=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let i=t.get(e);return i===void 0&&(i=new Set,t.set(e,i)),i}_getShaderStage(e){const t=this.shaderCache;let i=t.get(e);return i===void 0&&(i=new cD(e),t.set(e,i)),i}},cD=class{constructor(e){this.id=aD++,this.code=e,this.usedTimes=0}};function hD(n,e,t,i,r,s,o){const a=new Af,l=new lD,c=new Set,h=[],u=r.logarithmicDepthBuffer,d=r.vertexTextures;let f=r.precision;const A={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(y){return c.add(y),y===0?"uv":`uv${y}`}function m(y,_,L,Q,O){const X=Q.fog,te=O.geometry,W=y.isMeshStandardMaterial?Q.environment:null,Z=(y.isMeshStandardMaterial?t:e).get(y.envMap||W),q=Z&&Z.mapping===nl?Z.image.height:null,re=A[y.type];y.precision!==null&&(f=r.getMaxPrecision(y.precision),f!==y.precision&&console.warn("THREE.WebGLProgram.getParameters:",y.precision,"not supported, using",f,"instead."));const ue=te.morphAttributes.position||te.morphAttributes.normal||te.morphAttributes.color,_e=ue!==void 0?ue.length:0;let Be=0;te.morphAttributes.position!==void 0&&(Be=1),te.morphAttributes.normal!==void 0&&(Be=2),te.morphAttributes.color!==void 0&&(Be=3);let ze,le,Ee,Ue;if(re){const ht=Ti[re];ze=ht.vertexShader,le=ht.fragmentShader}else ze=y.vertexShader,le=y.fragmentShader,l.update(y),Ee=l.getVertexShaderID(y),Ue=l.getFragmentShaderID(y);const pe=n.getRenderTarget(),oe=n.state.buffers.depth.getReversed(),we=pe&&pe.isWebGLMultiviewRenderTarget?pe.numViews:0,Me=O.isInstancedMesh===!0,Ve=O.isBatchedMesh===!0,me=!!y.map,Ae=!!y.matcap,V=!!Z,j=!!y.aoMap,Te=!!y.lightMap,Re=!!y.bumpMap,b=!!y.normalMap,I=!!y.displacementMap,U=!!y.emissiveMap,R=!!y.metalnessMap,T=!!y.roughnessMap,G=y.anisotropy>0,J=y.clearcoat>0,de=y.dispersion>0,N=y.iridescence>0,P=y.sheen>0,$=y.transmission>0,se=G&&!!y.anisotropyMap,ve=J&&!!y.clearcoatMap,ie=J&&!!y.clearcoatNormalMap,Se=J&&!!y.clearcoatRoughnessMap,be=N&&!!y.iridescenceMap,Ie=N&&!!y.iridescenceThicknessMap,Fe=P&&!!y.sheenColorMap,Le=P&&!!y.sheenRoughnessMap,Ge=!!y.specularMap,Ze=!!y.specularColorMap,F=!!y.specularIntensityMap,ae=$&&!!y.transmissionMap,ne=$&&!!y.thicknessMap,ce=!!y.gradientMap,ge=!!y.alphaMap,xe=y.alphaTest>0,We=!!y.alphaHash,ke=!!y.extensions;let He=Dr;y.toneMapped&&(pe===null||pe.isXRRenderTarget===!0)&&(He=n.toneMapping);const Qe={shaderID:re,shaderType:y.type,shaderName:y.name,vertexShader:ze,fragmentShader:le,defines:y.defines,customVertexShaderID:Ee,customFragmentShaderID:Ue,isRawShaderMaterial:y.isRawShaderMaterial===!0,glslVersion:y.glslVersion,precision:f,batching:Ve,batchingColor:Ve&&O._colorsTexture!==null,instancing:Me,instancingColor:Me&&O.instanceColor!==null,instancingMorph:Me&&O.morphTexture!==null,supportsVertexTextures:d,numMultiviewViews:we,outputColorSpace:pe===null?n.outputColorSpace:pe.isXRRenderTarget===!0?pe.texture.colorSpace:Io,alphaToCoverage:!!y.alphaToCoverage,map:me,matcap:Ae,envMap:V,envMapMode:V&&Z.mapping,envMapCubeUVHeight:q,aoMap:j,lightMap:Te,bumpMap:Re,normalMap:b,displacementMap:d&&I,emissiveMap:U,normalMapObjectSpace:b&&y.normalMapType===Hb,normalMapTangentSpace:b&&y.normalMapType===Is,metalnessMap:R,roughnessMap:T,anisotropy:G,anisotropyMap:se,clearcoat:J,clearcoatMap:ve,clearcoatNormalMap:ie,clearcoatRoughnessMap:Se,dispersion:de,iridescence:N,iridescenceMap:be,iridescenceThicknessMap:Ie,sheen:P,sheenColorMap:Fe,sheenRoughnessMap:Le,specularMap:Ge,specularColorMap:Ze,specularIntensityMap:F,transmission:$,transmissionMap:ae,thicknessMap:ne,gradientMap:ce,opaque:y.transparent===!1&&y.blending===bo&&y.alphaToCoverage===!1,alphaMap:ge,alphaTest:xe,alphaHash:We,combine:y.combine,mapUv:me&&g(y.map.channel),aoMapUv:j&&g(y.aoMap.channel),lightMapUv:Te&&g(y.lightMap.channel),bumpMapUv:Re&&g(y.bumpMap.channel),normalMapUv:b&&g(y.normalMap.channel),displacementMapUv:I&&g(y.displacementMap.channel),emissiveMapUv:U&&g(y.emissiveMap.channel),metalnessMapUv:R&&g(y.metalnessMap.channel),roughnessMapUv:T&&g(y.roughnessMap.channel),anisotropyMapUv:se&&g(y.anisotropyMap.channel),clearcoatMapUv:ve&&g(y.clearcoatMap.channel),clearcoatNormalMapUv:ie&&g(y.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Se&&g(y.clearcoatRoughnessMap.channel),iridescenceMapUv:be&&g(y.iridescenceMap.channel),iridescenceThicknessMapUv:Ie&&g(y.iridescenceThicknessMap.channel),sheenColorMapUv:Fe&&g(y.sheenColorMap.channel),sheenRoughnessMapUv:Le&&g(y.sheenRoughnessMap.channel),specularMapUv:Ge&&g(y.specularMap.channel),specularColorMapUv:Ze&&g(y.specularColorMap.channel),specularIntensityMapUv:F&&g(y.specularIntensityMap.channel),transmissionMapUv:ae&&g(y.transmissionMap.channel),thicknessMapUv:ne&&g(y.thicknessMap.channel),alphaMapUv:ge&&g(y.alphaMap.channel),vertexTangents:!!te.attributes.tangent&&(b||G),vertexColors:y.vertexColors,vertexAlphas:y.vertexColors===!0&&!!te.attributes.color&&te.attributes.color.itemSize===4,pointsUvs:O.isPoints===!0&&!!te.attributes.uv&&(me||ge),fog:!!X,useFog:y.fog===!0,fogExp2:!!X&&X.isFogExp2,flatShading:y.flatShading===!0,sizeAttenuation:y.sizeAttenuation===!0,logarithmicDepthBuffer:u,reverseDepthBuffer:oe,skinning:O.isSkinnedMesh===!0,morphTargets:te.morphAttributes.position!==void 0,morphNormals:te.morphAttributes.normal!==void 0,morphColors:te.morphAttributes.color!==void 0,morphTargetsCount:_e,morphTextureStride:Be,numDirLights:_.directional.length,numPointLights:_.point.length,numSpotLights:_.spot.length,numSpotLightMaps:_.spotLightMap.length,numRectAreaLights:_.rectArea.length,numHemiLights:_.hemi.length,numDirLightShadows:_.directionalShadowMap.length,numPointLightShadows:_.pointShadowMap.length,numSpotLightShadows:_.spotShadowMap.length,numSpotLightShadowsWithMaps:_.numSpotLightShadowsWithMaps,numLightProbes:_.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:y.dithering,shadowMapEnabled:n.shadowMap.enabled&&L.length>0,shadowMapType:n.shadowMap.type,toneMapping:He,decodeVideoTexture:me&&y.map.isVideoTexture===!0&&wt.getTransfer(y.map.colorSpace)===Ut,decodeVideoTextureEmissive:U&&y.emissiveMap.isVideoTexture===!0&&wt.getTransfer(y.emissiveMap.colorSpace)===Ut,premultipliedAlpha:y.premultipliedAlpha,doubleSided:y.side===qi,flipSided:y.side===kn,useDepthPacking:y.depthPacking>=0,depthPacking:y.depthPacking||0,index0AttributeName:y.index0AttributeName,extensionClipCullDistance:ke&&y.extensions.clipCullDistance===!0&&i.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(ke&&y.extensions.multiDraw===!0||Ve)&&i.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:y.customProgramCacheKey()};return Qe.vertexUv1s=c.has(1),Qe.vertexUv2s=c.has(2),Qe.vertexUv3s=c.has(3),c.clear(),Qe}function p(y){const _=[];if(y.shaderID?_.push(y.shaderID):(_.push(y.customVertexShaderID),_.push(y.customFragmentShaderID)),y.defines!==void 0)for(const L in y.defines)_.push(L),_.push(y.defines[L]);return y.isRawShaderMaterial===!1&&(v(_,y),E(_,y),_.push(n.outputColorSpace)),_.push(y.customProgramCacheKey),_.join()}function v(y,_){y.push(_.precision),y.push(_.outputColorSpace),y.push(_.envMapMode),y.push(_.envMapCubeUVHeight),y.push(_.mapUv),y.push(_.alphaMapUv),y.push(_.lightMapUv),y.push(_.aoMapUv),y.push(_.bumpMapUv),y.push(_.normalMapUv),y.push(_.displacementMapUv),y.push(_.emissiveMapUv),y.push(_.metalnessMapUv),y.push(_.roughnessMapUv),y.push(_.anisotropyMapUv),y.push(_.clearcoatMapUv),y.push(_.clearcoatNormalMapUv),y.push(_.clearcoatRoughnessMapUv),y.push(_.iridescenceMapUv),y.push(_.iridescenceThicknessMapUv),y.push(_.sheenColorMapUv),y.push(_.sheenRoughnessMapUv),y.push(_.specularMapUv),y.push(_.specularColorMapUv),y.push(_.specularIntensityMapUv),y.push(_.transmissionMapUv),y.push(_.thicknessMapUv),y.push(_.combine),y.push(_.fogExp2),y.push(_.sizeAttenuation),y.push(_.morphTargetsCount),y.push(_.morphAttributeCount),y.push(_.numDirLights),y.push(_.numPointLights),y.push(_.numSpotLights),y.push(_.numSpotLightMaps),y.push(_.numHemiLights),y.push(_.numRectAreaLights),y.push(_.numDirLightShadows),y.push(_.numPointLightShadows),y.push(_.numSpotLightShadows),y.push(_.numSpotLightShadowsWithMaps),y.push(_.numLightProbes),y.push(_.shadowMapType),y.push(_.toneMapping),y.push(_.numClippingPlanes),y.push(_.numClipIntersection),y.push(_.depthPacking)}function E(y,_){a.disableAll(),_.supportsVertexTextures&&a.enable(0),_.instancing&&a.enable(1),_.instancingColor&&a.enable(2),_.instancingMorph&&a.enable(3),_.matcap&&a.enable(4),_.envMap&&a.enable(5),_.normalMapObjectSpace&&a.enable(6),_.normalMapTangentSpace&&a.enable(7),_.clearcoat&&a.enable(8),_.iridescence&&a.enable(9),_.alphaTest&&a.enable(10),_.vertexColors&&a.enable(11),_.vertexAlphas&&a.enable(12),_.vertexUv1s&&a.enable(13),_.vertexUv2s&&a.enable(14),_.vertexUv3s&&a.enable(15),_.vertexTangents&&a.enable(16),_.anisotropy&&a.enable(17),_.alphaHash&&a.enable(18),_.batching&&a.enable(19),_.dispersion&&a.enable(20),_.batchingColor&&a.enable(21),y.push(a.mask),a.disableAll(),_.fog&&a.enable(0),_.useFog&&a.enable(1),_.flatShading&&a.enable(2),_.logarithmicDepthBuffer&&a.enable(3),_.reverseDepthBuffer&&a.enable(4),_.skinning&&a.enable(5),_.morphTargets&&a.enable(6),_.morphNormals&&a.enable(7),_.morphColors&&a.enable(8),_.premultipliedAlpha&&a.enable(9),_.shadowMapEnabled&&a.enable(10),_.doubleSided&&a.enable(11),_.flipSided&&a.enable(12),_.useDepthPacking&&a.enable(13),_.dithering&&a.enable(14),_.transmission&&a.enable(15),_.sheen&&a.enable(16),_.opaque&&a.enable(17),_.pointsUvs&&a.enable(18),_.decodeVideoTexture&&a.enable(19),_.decodeVideoTextureEmissive&&a.enable(20),_.alphaToCoverage&&a.enable(21),_.numMultiviewViews&&a.enable(21),y.push(a.mask)}function x(y){const _=A[y.type];let L;if(_){const Q=Ti[_];L=lC.clone(Q.uniforms)}else L=y.uniforms;return L}function M(y,_){let L;for(let Q=0,O=h.length;Q<O;Q++){const X=h[Q];if(X.cacheKey===_){L=X,++L.usedTimes;break}}return L===void 0&&(L=new oD(n,_,y,s),h.push(L)),L}function w(y){if(--y.usedTimes===0){const _=h.indexOf(y);h[_]=h[h.length-1],h.pop(),y.destroy()}}function S(y){l.remove(y)}function B(){l.dispose()}return{getParameters:m,getProgramCacheKey:p,getUniforms:x,acquireProgram:M,releaseProgram:w,releaseShaderCache:S,programs:h,dispose:B}}function uD(){let n=new WeakMap;function e(o){return n.has(o)}function t(o){let a=n.get(o);return a===void 0&&(a={},n.set(o,a)),a}function i(o){n.delete(o)}function r(o,a,l){n.get(o)[a]=l}function s(){n=new WeakMap}return{has:e,get:t,remove:i,update:r,dispose:s}}function dD(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function ZE(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function ex(){const n=[];let e=0;const t=[],i=[],r=[];function s(){e=0,t.length=0,i.length=0,r.length=0}function o(u,d,f,A,g,m){let p=n[e];return p===void 0?(p={id:u.id,object:u,geometry:d,material:f,groupOrder:A,renderOrder:u.renderOrder,z:g,group:m},n[e]=p):(p.id=u.id,p.object=u,p.geometry=d,p.material=f,p.groupOrder=A,p.renderOrder=u.renderOrder,p.z=g,p.group=m),e++,p}function a(u,d,f,A,g,m){const p=o(u,d,f,A,g,m);f.transmission>0?i.push(p):f.transparent===!0?r.push(p):t.push(p)}function l(u,d,f,A,g,m){const p=o(u,d,f,A,g,m);f.transmission>0?i.unshift(p):f.transparent===!0?r.unshift(p):t.unshift(p)}function c(u,d){t.length>1&&t.sort(u||dD),i.length>1&&i.sort(d||ZE),r.length>1&&r.sort(d||ZE)}function h(){for(let u=e,d=n.length;u<d;u++){const f=n[u];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:t,transmissive:i,transparent:r,init:s,push:a,unshift:l,finish:h,sort:c}}function fD(){let n=new WeakMap;function e(i,r){const s=n.get(i);let o;return s===void 0?(o=new ex,n.set(i,[o])):r>=s.length?(o=new ex,s.push(o)):o=s[r],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function pD(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Y,color:new Ke};break;case"SpotLight":t={position:new Y,direction:new Y,color:new Ke,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Y,color:new Ke,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Y,skyColor:new Ke,groundColor:new Ke};break;case"RectAreaLight":t={color:new Ke,position:new Y,halfWidth:new Y,halfHeight:new Y};break}return n[e.id]=t,t}}}function mD(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ne};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ne};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ne,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let AD=0;function gD(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function vD(n){const e=new pD,t=mD(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)i.probe.push(new Y);const r=new Y,s=new ct,o=new ct;function a(c){let h=0,u=0,d=0;for(let y=0;y<9;y++)i.probe[y].set(0,0,0);let f=0,A=0,g=0,m=0,p=0,v=0,E=0,x=0,M=0,w=0,S=0;c.sort(gD);for(let y=0,_=c.length;y<_;y++){const L=c[y],Q=L.color,O=L.intensity,X=L.distance,te=L.shadow&&L.shadow.map?L.shadow.map.texture:null;if(L.isAmbientLight)h+=Q.r*O,u+=Q.g*O,d+=Q.b*O;else if(L.isLightProbe){for(let W=0;W<9;W++)i.probe[W].addScaledVector(L.sh.coefficients[W],O);S++}else if(L.isDirectionalLight){const W=e.get(L);if(W.color.copy(L.color).multiplyScalar(L.intensity),L.castShadow){const Z=L.shadow,q=t.get(L);q.shadowIntensity=Z.intensity,q.shadowBias=Z.bias,q.shadowNormalBias=Z.normalBias,q.shadowRadius=Z.radius,q.shadowMapSize=Z.mapSize,i.directionalShadow[f]=q,i.directionalShadowMap[f]=te,i.directionalShadowMatrix[f]=L.shadow.matrix,v++}i.directional[f]=W,f++}else if(L.isSpotLight){const W=e.get(L);W.position.setFromMatrixPosition(L.matrixWorld),W.color.copy(Q).multiplyScalar(O),W.distance=X,W.coneCos=Math.cos(L.angle),W.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),W.decay=L.decay,i.spot[g]=W;const Z=L.shadow;if(L.map&&(i.spotLightMap[M]=L.map,M++,Z.updateMatrices(L),L.castShadow&&w++),i.spotLightMatrix[g]=Z.matrix,L.castShadow){const q=t.get(L);q.shadowIntensity=Z.intensity,q.shadowBias=Z.bias,q.shadowNormalBias=Z.normalBias,q.shadowRadius=Z.radius,q.shadowMapSize=Z.mapSize,i.spotShadow[g]=q,i.spotShadowMap[g]=te,x++}g++}else if(L.isRectAreaLight){const W=e.get(L);W.color.copy(Q).multiplyScalar(O),W.halfWidth.set(L.width*.5,0,0),W.halfHeight.set(0,L.height*.5,0),i.rectArea[m]=W,m++}else if(L.isPointLight){const W=e.get(L);if(W.color.copy(L.color).multiplyScalar(L.intensity),W.distance=L.distance,W.decay=L.decay,L.castShadow){const Z=L.shadow,q=t.get(L);q.shadowIntensity=Z.intensity,q.shadowBias=Z.bias,q.shadowNormalBias=Z.normalBias,q.shadowRadius=Z.radius,q.shadowMapSize=Z.mapSize,q.shadowCameraNear=Z.camera.near,q.shadowCameraFar=Z.camera.far,i.pointShadow[A]=q,i.pointShadowMap[A]=te,i.pointShadowMatrix[A]=L.shadow.matrix,E++}i.point[A]=W,A++}else if(L.isHemisphereLight){const W=e.get(L);W.skyColor.copy(L.color).multiplyScalar(O),W.groundColor.copy(L.groundColor).multiplyScalar(O),i.hemi[p]=W,p++}}m>0&&(n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Ye.LTC_FLOAT_1,i.rectAreaLTC2=Ye.LTC_FLOAT_2):(i.rectAreaLTC1=Ye.LTC_HALF_1,i.rectAreaLTC2=Ye.LTC_HALF_2)),i.ambient[0]=h,i.ambient[1]=u,i.ambient[2]=d;const B=i.hash;(B.directionalLength!==f||B.pointLength!==A||B.spotLength!==g||B.rectAreaLength!==m||B.hemiLength!==p||B.numDirectionalShadows!==v||B.numPointShadows!==E||B.numSpotShadows!==x||B.numSpotMaps!==M||B.numLightProbes!==S)&&(i.directional.length=f,i.spot.length=g,i.rectArea.length=m,i.point.length=A,i.hemi.length=p,i.directionalShadow.length=v,i.directionalShadowMap.length=v,i.pointShadow.length=E,i.pointShadowMap.length=E,i.spotShadow.length=x,i.spotShadowMap.length=x,i.directionalShadowMatrix.length=v,i.pointShadowMatrix.length=E,i.spotLightMatrix.length=x+M-w,i.spotLightMap.length=M,i.numSpotLightShadowsWithMaps=w,i.numLightProbes=S,B.directionalLength=f,B.pointLength=A,B.spotLength=g,B.rectAreaLength=m,B.hemiLength=p,B.numDirectionalShadows=v,B.numPointShadows=E,B.numSpotShadows=x,B.numSpotMaps=M,B.numLightProbes=S,i.version=AD++)}function l(c,h){let u=0,d=0,f=0,A=0,g=0;const m=h.matrixWorldInverse;for(let p=0,v=c.length;p<v;p++){const E=c[p];if(E.isDirectionalLight){const x=i.directional[u];x.direction.setFromMatrixPosition(E.matrixWorld),r.setFromMatrixPosition(E.target.matrixWorld),x.direction.sub(r),x.direction.transformDirection(m),u++}else if(E.isSpotLight){const x=i.spot[f];x.position.setFromMatrixPosition(E.matrixWorld),x.position.applyMatrix4(m),x.direction.setFromMatrixPosition(E.matrixWorld),r.setFromMatrixPosition(E.target.matrixWorld),x.direction.sub(r),x.direction.transformDirection(m),f++}else if(E.isRectAreaLight){const x=i.rectArea[A];x.position.setFromMatrixPosition(E.matrixWorld),x.position.applyMatrix4(m),o.identity(),s.copy(E.matrixWorld),s.premultiply(m),o.extractRotation(s),x.halfWidth.set(E.width*.5,0,0),x.halfHeight.set(0,E.height*.5,0),x.halfWidth.applyMatrix4(o),x.halfHeight.applyMatrix4(o),A++}else if(E.isPointLight){const x=i.point[d];x.position.setFromMatrixPosition(E.matrixWorld),x.position.applyMatrix4(m),d++}else if(E.isHemisphereLight){const x=i.hemi[g];x.direction.setFromMatrixPosition(E.matrixWorld),x.direction.transformDirection(m),g++}}}return{setup:a,setupView:l,state:i}}function tx(n){const e=new vD(n),t=[],i=[];function r(h){c.camera=h,t.length=0,i.length=0}function s(h){t.push(h)}function o(h){i.push(h)}function a(){e.setup(t)}function l(h){e.setupView(t,h)}const c={lightsArray:t,shadowsArray:i,camera:null,lights:e,transmissionRenderTarget:{}};return{init:r,state:c,setupLights:a,setupLightsView:l,pushLight:s,pushShadow:o}}function ED(n){let e=new WeakMap;function t(r,s=0){const o=e.get(r);let a;return o===void 0?(a=new tx(n),e.set(r,[a])):s>=o.length?(a=new tx(n),o.push(a)):a=o[s],a}function i(){e=new WeakMap}return{get:t,dispose:i}}const xD=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,yD=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function _D(n,e,t){let i=new Fc;const r=new Ne,s=new Ne,o=new Dt,a=new x0({depthPacking:zb}),l=new y0,c={},h=t.maxTextureSize,u={[Or]:kn,[kn]:Or,[qi]:qi},d=new Ni({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ne},radius:{value:4}},vertexShader:xD,fragmentShader:yD}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const A=new yt;A.setAttribute("position",new Gt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new en(A,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=qg;let p=this.type;this.render=function(w,S,B){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||w.length===0)return;const y=n.getRenderTarget(),_=n.getActiveCubeFace(),L=n.getActiveMipmapLevel(),Q=n.state;Q.setBlending(Lr),Q.buffers.color.setClear(1,1,1,1),Q.buffers.depth.setTest(!0),Q.setScissorTest(!1);const O=p!==Qi&&this.type===Qi,X=p===Qi&&this.type!==Qi;for(let te=0,W=w.length;te<W;te++){const Z=w[te],q=Z.shadow;if(q===void 0){console.warn("THREE.WebGLShadowMap:",Z,"has no shadow.");continue}if(q.autoUpdate===!1&&q.needsUpdate===!1)continue;r.copy(q.mapSize);const re=q.getFrameExtents();if(r.multiply(re),s.copy(q.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/re.x),r.x=s.x*re.x,q.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/re.y),r.y=s.y*re.y,q.mapSize.y=s.y)),q.map===null||O===!0||X===!0){const _e=this.type!==Qi?{minFilter:xn,magFilter:xn}:{};q.map!==null&&q.map.dispose(),q.map=new Ui(r.x,r.y,_e),q.map.texture.name=Z.name+".shadowMap",q.camera.updateProjectionMatrix()}n.setRenderTarget(q.map),n.clear();const ue=q.getViewportCount();for(let _e=0;_e<ue;_e++){const Be=q.getViewport(_e);o.set(s.x*Be.x,s.y*Be.y,s.x*Be.z,s.y*Be.w),Q.viewport(o),q.updateMatrices(Z,_e),i=q.getFrustum(),x(S,B,q.camera,Z,this.type)}q.isPointLightShadow!==!0&&this.type===Qi&&v(q,B),q.needsUpdate=!1}p=this.type,m.needsUpdate=!1,n.setRenderTarget(y,_,L)};function v(w,S){const B=e.update(g);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,f.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),w.mapPass===null&&(w.mapPass=new Ui(r.x,r.y)),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,n.setRenderTarget(w.mapPass),n.clear(),n.renderBufferDirect(S,null,B,d,g,null),f.uniforms.shadow_pass.value=w.mapPass.texture,f.uniforms.resolution.value=w.mapSize,f.uniforms.radius.value=w.radius,n.setRenderTarget(w.map),n.clear(),n.renderBufferDirect(S,null,B,f,g,null)}function E(w,S,B,y){let _=null;const L=B.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(L!==void 0)_=L;else if(_=B.isPointLight===!0?l:a,n.localClippingEnabled&&S.clipShadows===!0&&Array.isArray(S.clippingPlanes)&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0||S.map&&S.alphaTest>0){const Q=_.uuid,O=S.uuid;let X=c[Q];X===void 0&&(X={},c[Q]=X);let te=X[O];te===void 0&&(te=_.clone(),X[O]=te,S.addEventListener("dispose",M)),_=te}if(_.visible=S.visible,_.wireframe=S.wireframe,y===Qi?_.side=S.shadowSide!==null?S.shadowSide:S.side:_.side=S.shadowSide!==null?S.shadowSide:u[S.side],_.alphaMap=S.alphaMap,_.alphaTest=S.alphaTest,_.map=S.map,_.clipShadows=S.clipShadows,_.clippingPlanes=S.clippingPlanes,_.clipIntersection=S.clipIntersection,_.displacementMap=S.displacementMap,_.displacementScale=S.displacementScale,_.displacementBias=S.displacementBias,_.wireframeLinewidth=S.wireframeLinewidth,_.linewidth=S.linewidth,B.isPointLight===!0&&_.isMeshDistanceMaterial===!0){const Q=n.properties.get(_);Q.light=B}return _}function x(w,S,B,y,_){if(w.visible===!1)return;if(w.layers.test(S.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&_===Qi)&&(!w.frustumCulled||i.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,w.matrixWorld);const O=e.update(w),X=w.material;if(Array.isArray(X)){const te=O.groups;for(let W=0,Z=te.length;W<Z;W++){const q=te[W],re=X[q.materialIndex];if(re&&re.visible){const ue=E(w,re,y,_);w.onBeforeShadow(n,w,S,B,O,ue,q),n.renderBufferDirect(B,null,O,ue,w,q),w.onAfterShadow(n,w,S,B,O,ue,q)}}}else if(X.visible){const te=E(w,X,y,_);w.onBeforeShadow(n,w,S,B,O,te,null),n.renderBufferDirect(B,null,O,te,w,null),w.onAfterShadow(n,w,S,B,O,te,null)}}const Q=w.children;for(let O=0,X=Q.length;O<X;O++)x(Q[O],S,B,y,_)}function M(w){w.target.removeEventListener("dispose",M);for(const B in c){const y=c[B],_=w.target.uuid;_ in y&&(y[_].dispose(),delete y[_])}}}const bD={[nd]:id,[rd]:ad,[sd]:ld,[To]:od,[id]:nd,[ad]:rd,[ld]:sd,[od]:To};function CD(n,e){function t(){let F=!1;const ae=new Dt;let ne=null;const ce=new Dt(0,0,0,0);return{setMask:function(ge){ne!==ge&&!F&&(n.colorMask(ge,ge,ge,ge),ne=ge)},setLocked:function(ge){F=ge},setClear:function(ge,xe,We,ke,He){He===!0&&(ge*=ke,xe*=ke,We*=ke),ae.set(ge,xe,We,ke),ce.equals(ae)===!1&&(n.clearColor(ge,xe,We,ke),ce.copy(ae))},reset:function(){F=!1,ne=null,ce.set(-1,0,0,0)}}}function i(){let F=!1,ae=!1,ne=null,ce=null,ge=null;return{setReversed:function(xe){if(ae!==xe){const We=e.get("EXT_clip_control");ae?We.clipControlEXT(We.LOWER_LEFT_EXT,We.ZERO_TO_ONE_EXT):We.clipControlEXT(We.LOWER_LEFT_EXT,We.NEGATIVE_ONE_TO_ONE_EXT);const ke=ge;ge=null,this.setClear(ke)}ae=xe},getReversed:function(){return ae},setTest:function(xe){xe?pe(n.DEPTH_TEST):oe(n.DEPTH_TEST)},setMask:function(xe){ne!==xe&&!F&&(n.depthMask(xe),ne=xe)},setFunc:function(xe){if(ae&&(xe=bD[xe]),ce!==xe){switch(xe){case nd:n.depthFunc(n.NEVER);break;case id:n.depthFunc(n.ALWAYS);break;case rd:n.depthFunc(n.LESS);break;case To:n.depthFunc(n.LEQUAL);break;case sd:n.depthFunc(n.EQUAL);break;case od:n.depthFunc(n.GEQUAL);break;case ad:n.depthFunc(n.GREATER);break;case ld:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}ce=xe}},setLocked:function(xe){F=xe},setClear:function(xe){ge!==xe&&(ae&&(xe=1-xe),n.clearDepth(xe),ge=xe)},reset:function(){F=!1,ne=null,ce=null,ge=null,ae=!1}}}function r(){let F=!1,ae=null,ne=null,ce=null,ge=null,xe=null,We=null,ke=null,He=null;return{setTest:function(Qe){F||(Qe?pe(n.STENCIL_TEST):oe(n.STENCIL_TEST))},setMask:function(Qe){ae!==Qe&&!F&&(n.stencilMask(Qe),ae=Qe)},setFunc:function(Qe,ht,Pt){(ne!==Qe||ce!==ht||ge!==Pt)&&(n.stencilFunc(Qe,ht,Pt),ne=Qe,ce=ht,ge=Pt)},setOp:function(Qe,ht,Pt){(xe!==Qe||We!==ht||ke!==Pt)&&(n.stencilOp(Qe,ht,Pt),xe=Qe,We=ht,ke=Pt)},setLocked:function(Qe){F=Qe},setClear:function(Qe){He!==Qe&&(n.clearStencil(Qe),He=Qe)},reset:function(){F=!1,ae=null,ne=null,ce=null,ge=null,xe=null,We=null,ke=null,He=null}}}const s=new t,o=new i,a=new r,l=new WeakMap,c=new WeakMap;let h={},u={},d=new WeakMap,f=[],A=null,g=!1,m=null,p=null,v=null,E=null,x=null,M=null,w=null,S=new Ke(0,0,0),B=0,y=!1,_=null,L=null,Q=null,O=null,X=null;const te=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let W=!1,Z=0;const q=n.getParameter(n.VERSION);q.indexOf("WebGL")!==-1?(Z=parseFloat(/^WebGL (\d)/.exec(q)[1]),W=Z>=1):q.indexOf("OpenGL ES")!==-1&&(Z=parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),W=Z>=2);let re=null,ue={};const _e=n.getParameter(n.SCISSOR_BOX),Be=n.getParameter(n.VIEWPORT),ze=new Dt().fromArray(_e),le=new Dt().fromArray(Be);function Ee(F,ae,ne,ce){const ge=new Uint8Array(4),xe=n.createTexture();n.bindTexture(F,xe),n.texParameteri(F,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(F,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let We=0;We<ne;We++)F===n.TEXTURE_3D||F===n.TEXTURE_2D_ARRAY?n.texImage3D(ae,0,n.RGBA,1,1,ce,0,n.RGBA,n.UNSIGNED_BYTE,ge):n.texImage2D(ae+We,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,ge);return xe}const Ue={};Ue[n.TEXTURE_2D]=Ee(n.TEXTURE_2D,n.TEXTURE_2D,1),Ue[n.TEXTURE_CUBE_MAP]=Ee(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),Ue[n.TEXTURE_2D_ARRAY]=Ee(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),Ue[n.TEXTURE_3D]=Ee(n.TEXTURE_3D,n.TEXTURE_3D,1,1),s.setClear(0,0,0,1),o.setClear(1),a.setClear(0),pe(n.DEPTH_TEST),o.setFunc(To),Te(!1),Re(dA),pe(n.CULL_FACE),V(Lr);function pe(F){h[F]!==!0&&(n.enable(F),h[F]=!0)}function oe(F){h[F]!==!1&&(n.disable(F),h[F]=!1)}function we(F,ae){return u[F]!==ae?(n.bindFramebuffer(F,ae),u[F]=ae,F===n.DRAW_FRAMEBUFFER&&(u[n.FRAMEBUFFER]=ae),F===n.FRAMEBUFFER&&(u[n.DRAW_FRAMEBUFFER]=ae),!0):!1}function Me(F,ae){let ne=f,ce=!1;if(F){ne=d.get(ae),ne===void 0&&(ne=[],d.set(ae,ne));const ge=F.textures;if(ne.length!==ge.length||ne[0]!==n.COLOR_ATTACHMENT0){for(let xe=0,We=ge.length;xe<We;xe++)ne[xe]=n.COLOR_ATTACHMENT0+xe;ne.length=ge.length,ce=!0}}else ne[0]!==n.BACK&&(ne[0]=n.BACK,ce=!0);ce&&n.drawBuffers(ne)}function Ve(F){return A!==F?(n.useProgram(F),A=F,!0):!1}const me={[ds]:n.FUNC_ADD,[hb]:n.FUNC_SUBTRACT,[ub]:n.FUNC_REVERSE_SUBTRACT};me[db]=n.MIN,me[fb]=n.MAX;const Ae={[pb]:n.ZERO,[mb]:n.ONE,[Ab]:n.SRC_COLOR,[ed]:n.SRC_ALPHA,[_b]:n.SRC_ALPHA_SATURATE,[xb]:n.DST_COLOR,[vb]:n.DST_ALPHA,[gb]:n.ONE_MINUS_SRC_COLOR,[td]:n.ONE_MINUS_SRC_ALPHA,[yb]:n.ONE_MINUS_DST_COLOR,[Eb]:n.ONE_MINUS_DST_ALPHA,[bb]:n.CONSTANT_COLOR,[Cb]:n.ONE_MINUS_CONSTANT_COLOR,[Mb]:n.CONSTANT_ALPHA,[Sb]:n.ONE_MINUS_CONSTANT_ALPHA};function V(F,ae,ne,ce,ge,xe,We,ke,He,Qe){if(F===Lr){g===!0&&(oe(n.BLEND),g=!1);return}if(g===!1&&(pe(n.BLEND),g=!0),F!==cb){if(F!==m||Qe!==y){if((p!==ds||x!==ds)&&(n.blendEquation(n.FUNC_ADD),p=ds,x=ds),Qe)switch(F){case bo:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case fA:n.blendFunc(n.ONE,n.ONE);break;case pA:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case mA:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",F);break}else switch(F){case bo:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case fA:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case pA:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case mA:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",F);break}v=null,E=null,M=null,w=null,S.set(0,0,0),B=0,m=F,y=Qe}return}ge=ge||ae,xe=xe||ne,We=We||ce,(ae!==p||ge!==x)&&(n.blendEquationSeparate(me[ae],me[ge]),p=ae,x=ge),(ne!==v||ce!==E||xe!==M||We!==w)&&(n.blendFuncSeparate(Ae[ne],Ae[ce],Ae[xe],Ae[We]),v=ne,E=ce,M=xe,w=We),(ke.equals(S)===!1||He!==B)&&(n.blendColor(ke.r,ke.g,ke.b,He),S.copy(ke),B=He),m=F,y=!1}function j(F,ae){F.side===qi?oe(n.CULL_FACE):pe(n.CULL_FACE);let ne=F.side===kn;ae&&(ne=!ne),Te(ne),F.blending===bo&&F.transparent===!1?V(Lr):V(F.blending,F.blendEquation,F.blendSrc,F.blendDst,F.blendEquationAlpha,F.blendSrcAlpha,F.blendDstAlpha,F.blendColor,F.blendAlpha,F.premultipliedAlpha),o.setFunc(F.depthFunc),o.setTest(F.depthTest),o.setMask(F.depthWrite),s.setMask(F.colorWrite);const ce=F.stencilWrite;a.setTest(ce),ce&&(a.setMask(F.stencilWriteMask),a.setFunc(F.stencilFunc,F.stencilRef,F.stencilFuncMask),a.setOp(F.stencilFail,F.stencilZFail,F.stencilZPass)),I(F.polygonOffset,F.polygonOffsetFactor,F.polygonOffsetUnits),F.alphaToCoverage===!0?pe(n.SAMPLE_ALPHA_TO_COVERAGE):oe(n.SAMPLE_ALPHA_TO_COVERAGE)}function Te(F){_!==F&&(F?n.frontFace(n.CW):n.frontFace(n.CCW),_=F)}function Re(F){F!==ob?(pe(n.CULL_FACE),F!==L&&(F===dA?n.cullFace(n.BACK):F===ab?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):oe(n.CULL_FACE),L=F}function b(F){F!==Q&&(W&&n.lineWidth(F),Q=F)}function I(F,ae,ne){F?(pe(n.POLYGON_OFFSET_FILL),(O!==ae||X!==ne)&&(n.polygonOffset(ae,ne),O=ae,X=ne)):oe(n.POLYGON_OFFSET_FILL)}function U(F){F?pe(n.SCISSOR_TEST):oe(n.SCISSOR_TEST)}function R(F){F===void 0&&(F=n.TEXTURE0+te-1),re!==F&&(n.activeTexture(F),re=F)}function T(F,ae,ne){ne===void 0&&(re===null?ne=n.TEXTURE0+te-1:ne=re);let ce=ue[ne];ce===void 0&&(ce={type:void 0,texture:void 0},ue[ne]=ce),(ce.type!==F||ce.texture!==ae)&&(re!==ne&&(n.activeTexture(ne),re=ne),n.bindTexture(F,ae||Ue[F]),ce.type=F,ce.texture=ae)}function G(){const F=ue[re];F!==void 0&&F.type!==void 0&&(n.bindTexture(F.type,null),F.type=void 0,F.texture=void 0)}function J(){try{n.compressedTexImage2D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function de(){try{n.compressedTexImage3D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function N(){try{n.texSubImage2D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function P(){try{n.texSubImage3D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function $(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function se(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function ve(){try{n.texStorage2D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function ie(){try{n.texStorage3D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function Se(){try{n.texImage2D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function be(){try{n.texImage3D.apply(n,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function Ie(F){ze.equals(F)===!1&&(n.scissor(F.x,F.y,F.z,F.w),ze.copy(F))}function Fe(F){le.equals(F)===!1&&(n.viewport(F.x,F.y,F.z,F.w),le.copy(F))}function Le(F,ae){let ne=c.get(ae);ne===void 0&&(ne=new WeakMap,c.set(ae,ne));let ce=ne.get(F);ce===void 0&&(ce=n.getUniformBlockIndex(ae,F.name),ne.set(F,ce))}function Ge(F,ae){const ce=c.get(ae).get(F);l.get(ae)!==ce&&(n.uniformBlockBinding(ae,ce,F.__bindingPointIndex),l.set(ae,ce))}function Ze(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),o.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},re=null,ue={},u={},d=new WeakMap,f=[],A=null,g=!1,m=null,p=null,v=null,E=null,x=null,M=null,w=null,S=new Ke(0,0,0),B=0,y=!1,_=null,L=null,Q=null,O=null,X=null,ze.set(0,0,n.canvas.width,n.canvas.height),le.set(0,0,n.canvas.width,n.canvas.height),s.reset(),o.reset(),a.reset()}return{buffers:{color:s,depth:o,stencil:a},enable:pe,disable:oe,bindFramebuffer:we,drawBuffers:Me,useProgram:Ve,setBlending:V,setMaterial:j,setFlipSided:Te,setCullFace:Re,setLineWidth:b,setPolygonOffset:I,setScissorTest:U,activeTexture:R,bindTexture:T,unbindTexture:G,compressedTexImage2D:J,compressedTexImage3D:de,texImage2D:Se,texImage3D:be,updateUBOMapping:Le,uniformBlockBinding:Ge,texStorage2D:ve,texStorage3D:ie,texSubImage2D:N,texSubImage3D:P,compressedTexSubImage2D:$,compressedTexSubImage3D:se,scissor:Ie,viewport:Fe,reset:Ze}}function MD(n,e,t,i,r,s,o){const a=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=e.has("OCULUS_multiview")?e.get("OCULUS_multiview"):null,h=new Ne,u=new WeakMap;let d;const f=new WeakMap;let A=[],g=!1,m=!1;try{m=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(N,P){return m?new OffscreenCanvas(N,P):dc("canvas")}function v(N,P,$){let se=1;const ve=de(N);if((ve.width>$||ve.height>$)&&(se=$/Math.max(ve.width,ve.height)),se<1)if(typeof HTMLImageElement<"u"&&N instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&N instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&N instanceof ImageBitmap||typeof VideoFrame<"u"&&N instanceof VideoFrame){const ie=Math.floor(se*ve.width),Se=Math.floor(se*ve.height);d===void 0&&(d=p(ie,Se));const be=P?p(ie,Se):d;return be.width=ie,be.height=Se,be.getContext("2d").drawImage(N,0,0,ie,Se),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ve.width+"x"+ve.height+") to ("+ie+"x"+Se+")."),be}else return"data"in N&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ve.width+"x"+ve.height+")."),N;return N}function E(N){return N.generateMipmaps}function x(N){n.generateMipmap(N)}function M(N){return N.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:N.isWebGL3DRenderTarget?n.TEXTURE_3D:N.isWebGLArrayRenderTarget||N.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function w(N,P,$,se,ve=!1){if(N!==null){if(n[N]!==void 0)return n[N];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+N+"'")}let ie=P;if(P===n.RED&&($===n.FLOAT&&(ie=n.R32F),$===n.HALF_FLOAT&&(ie=n.R16F),$===n.UNSIGNED_BYTE&&(ie=n.R8)),P===n.RED_INTEGER&&($===n.UNSIGNED_BYTE&&(ie=n.R8UI),$===n.UNSIGNED_SHORT&&(ie=n.R16UI),$===n.UNSIGNED_INT&&(ie=n.R32UI),$===n.BYTE&&(ie=n.R8I),$===n.SHORT&&(ie=n.R16I),$===n.INT&&(ie=n.R32I)),P===n.RG&&($===n.FLOAT&&(ie=n.RG32F),$===n.HALF_FLOAT&&(ie=n.RG16F),$===n.UNSIGNED_BYTE&&(ie=n.RG8)),P===n.RG_INTEGER&&($===n.UNSIGNED_BYTE&&(ie=n.RG8UI),$===n.UNSIGNED_SHORT&&(ie=n.RG16UI),$===n.UNSIGNED_INT&&(ie=n.RG32UI),$===n.BYTE&&(ie=n.RG8I),$===n.SHORT&&(ie=n.RG16I),$===n.INT&&(ie=n.RG32I)),P===n.RGB_INTEGER&&($===n.UNSIGNED_BYTE&&(ie=n.RGB8UI),$===n.UNSIGNED_SHORT&&(ie=n.RGB16UI),$===n.UNSIGNED_INT&&(ie=n.RGB32UI),$===n.BYTE&&(ie=n.RGB8I),$===n.SHORT&&(ie=n.RGB16I),$===n.INT&&(ie=n.RGB32I)),P===n.RGBA_INTEGER&&($===n.UNSIGNED_BYTE&&(ie=n.RGBA8UI),$===n.UNSIGNED_SHORT&&(ie=n.RGBA16UI),$===n.UNSIGNED_INT&&(ie=n.RGBA32UI),$===n.BYTE&&(ie=n.RGBA8I),$===n.SHORT&&(ie=n.RGBA16I),$===n.INT&&(ie=n.RGBA32I)),P===n.RGB&&$===n.UNSIGNED_INT_5_9_9_9_REV&&(ie=n.RGB9_E5),P===n.RGBA){const Se=ve?cc:wt.getTransfer(se);$===n.FLOAT&&(ie=n.RGBA32F),$===n.HALF_FLOAT&&(ie=n.RGBA16F),$===n.UNSIGNED_BYTE&&(ie=Se===Ut?n.SRGB8_ALPHA8:n.RGBA8),$===n.UNSIGNED_SHORT_4_4_4_4&&(ie=n.RGBA4),$===n.UNSIGNED_SHORT_5_5_5_1&&(ie=n.RGB5_A1)}return(ie===n.R16F||ie===n.R32F||ie===n.RG16F||ie===n.RG32F||ie===n.RGBA16F||ie===n.RGBA32F)&&e.get("EXT_color_buffer_float"),ie}function S(N,P){let $;return N?P===null||P===Gr||P===vs?$=n.DEPTH24_STENCIL8:P===Un?$=n.DEPTH32F_STENCIL8:P===Xa&&($=n.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):P===null||P===Gr||P===vs?$=n.DEPTH_COMPONENT24:P===Un?$=n.DEPTH_COMPONENT32F:P===Xa&&($=n.DEPTH_COMPONENT16),$}function B(N,P){return E(N)===!0||N.isFramebufferTexture&&N.minFilter!==xn&&N.minFilter!==ln?Math.log2(Math.max(P.width,P.height))+1:N.mipmaps!==void 0&&N.mipmaps.length>0?N.mipmaps.length:N.isCompressedTexture&&Array.isArray(N.image)?P.mipmaps.length:1}function y(N){const P=N.target;P.removeEventListener("dispose",y),L(P),P.isVideoTexture&&u.delete(P)}function _(N){const P=N.target;P.removeEventListener("dispose",_),O(P)}function L(N){const P=i.get(N);if(P.__webglInit===void 0)return;const $=N.source,se=f.get($);if(se){const ve=se[P.__cacheKey];ve.usedTimes--,ve.usedTimes===0&&Q(N),Object.keys(se).length===0&&f.delete($)}i.remove(N)}function Q(N){const P=i.get(N);n.deleteTexture(P.__webglTexture);const $=N.source,se=f.get($);delete se[P.__cacheKey],o.memory.textures--}function O(N){const P=i.get(N);if(N.depthTexture&&(N.depthTexture.dispose(),i.remove(N.depthTexture)),N.isWebGLCubeRenderTarget)for(let se=0;se<6;se++){if(Array.isArray(P.__webglFramebuffer[se]))for(let ve=0;ve<P.__webglFramebuffer[se].length;ve++)n.deleteFramebuffer(P.__webglFramebuffer[se][ve]);else n.deleteFramebuffer(P.__webglFramebuffer[se]);P.__webglDepthbuffer&&n.deleteRenderbuffer(P.__webglDepthbuffer[se])}else{if(Array.isArray(P.__webglFramebuffer))for(let se=0;se<P.__webglFramebuffer.length;se++)n.deleteFramebuffer(P.__webglFramebuffer[se]);else n.deleteFramebuffer(P.__webglFramebuffer);if(P.__webglDepthbuffer&&n.deleteRenderbuffer(P.__webglDepthbuffer),P.__webglMultisampledFramebuffer&&n.deleteFramebuffer(P.__webglMultisampledFramebuffer),P.__webglColorRenderbuffer)for(let se=0;se<P.__webglColorRenderbuffer.length;se++)P.__webglColorRenderbuffer[se]&&n.deleteRenderbuffer(P.__webglColorRenderbuffer[se]);P.__webglDepthRenderbuffer&&n.deleteRenderbuffer(P.__webglDepthRenderbuffer)}const $=N.textures;for(let se=0,ve=$.length;se<ve;se++){const ie=i.get($[se]);ie.__webglTexture&&(n.deleteTexture(ie.__webglTexture),o.memory.textures--),i.remove($[se])}i.remove(N)}let X=0;function te(){X=0}function W(){const N=X;return N>=r.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+N+" texture units while this GPU supports only "+r.maxTextures),X+=1,N}function Z(N){const P=[];return P.push(N.wrapS),P.push(N.wrapT),P.push(N.wrapR||0),P.push(N.magFilter),P.push(N.minFilter),P.push(N.anisotropy),P.push(N.internalFormat),P.push(N.format),P.push(N.type),P.push(N.generateMipmaps),P.push(N.premultiplyAlpha),P.push(N.flipY),P.push(N.unpackAlignment),P.push(N.colorSpace),P.join()}function q(N,P){const $=i.get(N);if(N.isVideoTexture&&G(N),N.isRenderTargetTexture===!1&&N.version>0&&$.__version!==N.version){const se=N.image;if(se===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(se.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else if(we($,N,P))return}t.bindTexture(n.TEXTURE_2D,$.__webglTexture,n.TEXTURE0+P)}function re(N,P){const $=i.get(N);if(N.version>0&&$.__version!==N.version){we($,N,P);return}t.bindTexture(n.TEXTURE_2D_ARRAY,$.__webglTexture,n.TEXTURE0+P)}function ue(N,P){const $=i.get(N);if(N.version>0&&$.__version!==N.version){we($,N,P);return}t.bindTexture(n.TEXTURE_3D,$.__webglTexture,n.TEXTURE0+P)}function _e(N,P){const $=i.get(N);if(N.version>0&&$.__version!==N.version){Me($,N,P);return}t.bindTexture(n.TEXTURE_CUBE_MAP,$.__webglTexture,n.TEXTURE0+P)}const Be={[sc]:n.REPEAT,[mi]:n.CLAMP_TO_EDGE,[oc]:n.MIRRORED_REPEAT},ze={[xn]:n.NEAREST,[Yg]:n.NEAREST_MIPMAP_NEAREST,[La]:n.NEAREST_MIPMAP_LINEAR,[ln]:n.LINEAR,[Ql]:n.LINEAR_MIPMAP_NEAREST,[Yi]:n.LINEAR_MIPMAP_LINEAR},le={[Vb]:n.NEVER,[jb]:n.ALWAYS,[Qb]:n.LESS,[s0]:n.LEQUAL,[Wb]:n.EQUAL,[Yb]:n.GEQUAL,[Xb]:n.GREATER,[qb]:n.NOTEQUAL};function Ee(N,P){if(P.type===Un&&e.has("OES_texture_float_linear")===!1&&(P.magFilter===ln||P.magFilter===Ql||P.magFilter===La||P.magFilter===Yi||P.minFilter===ln||P.minFilter===Ql||P.minFilter===La||P.minFilter===Yi)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(N,n.TEXTURE_WRAP_S,Be[P.wrapS]),n.texParameteri(N,n.TEXTURE_WRAP_T,Be[P.wrapT]),(N===n.TEXTURE_3D||N===n.TEXTURE_2D_ARRAY)&&n.texParameteri(N,n.TEXTURE_WRAP_R,Be[P.wrapR]),n.texParameteri(N,n.TEXTURE_MAG_FILTER,ze[P.magFilter]),n.texParameteri(N,n.TEXTURE_MIN_FILTER,ze[P.minFilter]),P.compareFunction&&(n.texParameteri(N,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(N,n.TEXTURE_COMPARE_FUNC,le[P.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(P.magFilter===xn||P.minFilter!==La&&P.minFilter!==Yi||P.type===Un&&e.has("OES_texture_float_linear")===!1)return;if(P.anisotropy>1||i.get(P).__currentAnisotropy){const $=e.get("EXT_texture_filter_anisotropic");n.texParameterf(N,$.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(P.anisotropy,r.getMaxAnisotropy())),i.get(P).__currentAnisotropy=P.anisotropy}}}function Ue(N,P){let $=!1;N.__webglInit===void 0&&(N.__webglInit=!0,P.addEventListener("dispose",y));const se=P.source;let ve=f.get(se);ve===void 0&&(ve={},f.set(se,ve));const ie=Z(P);if(ie!==N.__cacheKey){ve[ie]===void 0&&(ve[ie]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,$=!0),ve[ie].usedTimes++;const Se=ve[N.__cacheKey];Se!==void 0&&(ve[N.__cacheKey].usedTimes--,Se.usedTimes===0&&Q(P)),N.__cacheKey=ie,N.__webglTexture=ve[ie].texture}return $}function pe(N){g=N}function oe(){const N=g;g=!1;for(const P of A)we(P.textureProperties,P.texture,P.slot),P.texture.isPendingDeferredUpload=!1;A=[],g=N}function we(N,P,$){if(g)return P.isPendingDeferredUpload||(P.isPendingDeferredUpload=!0,A.push({textureProperties:N,texture:P,slot:$})),!1;let se=n.TEXTURE_2D;(P.isDataArrayTexture||P.isCompressedArrayTexture)&&(se=n.TEXTURE_2D_ARRAY),P.isData3DTexture&&(se=n.TEXTURE_3D);const ve=Ue(N,P),ie=P.source;t.bindTexture(se,N.__webglTexture,n.TEXTURE0+$);const Se=i.get(ie);if(ie.version!==Se.__version||ve===!0){t.activeTexture(n.TEXTURE0+$);const be=wt.getPrimaries(wt.workingColorSpace),Ie=P.colorSpace===xr?null:wt.getPrimaries(P.colorSpace),Fe=P.colorSpace===xr||be===Ie?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,P.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,P.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,P.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Fe);let Le=v(P.image,!1,r.maxTextureSize);Le=J(P,Le);const Ge=s.convert(P.format,P.colorSpace),Ze=s.convert(P.type);let F=w(P.internalFormat,Ge,Ze,P.colorSpace,P.isVideoTexture);Ee(se,P);let ae;const ne=P.mipmaps,ce=P.isVideoTexture!==!0,ge=Se.__version===void 0||ve===!0,xe=ie.dataReady,We=B(P,Le);if(P.isDepthTexture)F=S(P.format===xs,P.type),ge&&(ce?t.texStorage2D(n.TEXTURE_2D,1,F,Le.width,Le.height):t.texImage2D(n.TEXTURE_2D,0,F,Le.width,Le.height,0,Ge,Ze,null));else if(P.isDataTexture)if(ne.length>0){ce&&ge&&t.texStorage2D(n.TEXTURE_2D,We,F,ne[0].width,ne[0].height);for(let ke=0,He=ne.length;ke<He;ke++)ae=ne[ke],ce?xe&&t.texSubImage2D(n.TEXTURE_2D,ke,0,0,ae.width,ae.height,Ge,Ze,ae.data):t.texImage2D(n.TEXTURE_2D,ke,F,ae.width,ae.height,0,Ge,Ze,ae.data);P.generateMipmaps=!1}else ce?(ge&&t.texStorage2D(n.TEXTURE_2D,We,F,Le.width,Le.height),xe&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,Le.width,Le.height,Ge,Ze,Le.data)):t.texImage2D(n.TEXTURE_2D,0,F,Le.width,Le.height,0,Ge,Ze,Le.data);else if(P.isCompressedTexture)if(P.isCompressedArrayTexture){ce&&ge&&t.texStorage3D(n.TEXTURE_2D_ARRAY,We,F,ne[0].width,ne[0].height,Le.depth);for(let ke=0,He=ne.length;ke<He;ke++)if(ae=ne[ke],P.format!==On)if(Ge!==null)if(ce){if(xe)if(P.layerUpdates.size>0){const Qe=SA(ae.width,ae.height,P.format,P.type);for(const ht of P.layerUpdates){const Pt=ae.data.subarray(ht*Qe/ae.data.BYTES_PER_ELEMENT,(ht+1)*Qe/ae.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ke,0,0,ht,ae.width,ae.height,1,Ge,Pt)}P.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ke,0,0,0,ae.width,ae.height,Le.depth,Ge,ae.data)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,ke,F,ae.width,ae.height,Le.depth,0,ae.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else ce?xe&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,ke,0,0,0,ae.width,ae.height,Le.depth,Ge,Ze,ae.data):t.texImage3D(n.TEXTURE_2D_ARRAY,ke,F,ae.width,ae.height,Le.depth,0,Ge,Ze,ae.data)}else{ce&&ge&&t.texStorage2D(n.TEXTURE_2D,We,F,ne[0].width,ne[0].height);for(let ke=0,He=ne.length;ke<He;ke++)ae=ne[ke],P.format!==On?Ge!==null?ce?xe&&t.compressedTexSubImage2D(n.TEXTURE_2D,ke,0,0,ae.width,ae.height,Ge,ae.data):t.compressedTexImage2D(n.TEXTURE_2D,ke,F,ae.width,ae.height,0,ae.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):ce?xe&&t.texSubImage2D(n.TEXTURE_2D,ke,0,0,ae.width,ae.height,Ge,Ze,ae.data):t.texImage2D(n.TEXTURE_2D,ke,F,ae.width,ae.height,0,Ge,Ze,ae.data)}else if(P.isDataArrayTexture)if(ce){if(ge&&t.texStorage3D(n.TEXTURE_2D_ARRAY,We,F,Le.width,Le.height,Le.depth),xe)if(P.layerUpdates.size>0){const ke=SA(Le.width,Le.height,P.format,P.type);for(const He of P.layerUpdates){const Qe=Le.data.subarray(He*ke/Le.data.BYTES_PER_ELEMENT,(He+1)*ke/Le.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,He,Le.width,Le.height,1,Ge,Ze,Qe)}P.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,Le.width,Le.height,Le.depth,Ge,Ze,Le.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,F,Le.width,Le.height,Le.depth,0,Ge,Ze,Le.data);else if(P.isData3DTexture)ce?(ge&&t.texStorage3D(n.TEXTURE_3D,We,F,Le.width,Le.height,Le.depth),xe&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,Le.width,Le.height,Le.depth,Ge,Ze,Le.data)):t.texImage3D(n.TEXTURE_3D,0,F,Le.width,Le.height,Le.depth,0,Ge,Ze,Le.data);else if(P.isFramebufferTexture){if(ge)if(ce)t.texStorage2D(n.TEXTURE_2D,We,F,Le.width,Le.height);else{let ke=Le.width,He=Le.height;for(let Qe=0;Qe<We;Qe++)t.texImage2D(n.TEXTURE_2D,Qe,F,ke,He,0,Ge,Ze,null),ke>>=1,He>>=1}}else if(ne.length>0){if(ce&&ge){const ke=de(ne[0]);t.texStorage2D(n.TEXTURE_2D,We,F,ke.width,ke.height)}for(let ke=0,He=ne.length;ke<He;ke++)ae=ne[ke],ce?xe&&t.texSubImage2D(n.TEXTURE_2D,ke,0,0,Ge,Ze,ae):t.texImage2D(n.TEXTURE_2D,ke,F,Ge,Ze,ae);P.generateMipmaps=!1}else if(ce){if(ge){const ke=de(Le);t.texStorage2D(n.TEXTURE_2D,We,F,ke.width,ke.height)}xe&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,Ge,Ze,Le)}else t.texImage2D(n.TEXTURE_2D,0,F,Ge,Ze,Le);E(P)&&x(se),Se.__version=ie.version,P.onUpdate&&P.onUpdate(P)}return N.__version=P.version,!0}function Me(N,P,$){if(P.image.length!==6)return;const se=Ue(N,P),ve=P.source;t.bindTexture(n.TEXTURE_CUBE_MAP,N.__webglTexture,n.TEXTURE0+$);const ie=i.get(ve);if(ve.version!==ie.__version||se===!0){t.activeTexture(n.TEXTURE0+$);const Se=wt.getPrimaries(wt.workingColorSpace),be=P.colorSpace===xr?null:wt.getPrimaries(P.colorSpace),Ie=P.colorSpace===xr||Se===be?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,P.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,P.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,P.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ie);const Fe=P.isCompressedTexture||P.image[0].isCompressedTexture,Le=P.image[0]&&P.image[0].isDataTexture,Ge=[];for(let He=0;He<6;He++)!Fe&&!Le?Ge[He]=v(P.image[He],!0,r.maxCubemapSize):Ge[He]=Le?P.image[He].image:P.image[He],Ge[He]=J(P,Ge[He]);const Ze=Ge[0],F=s.convert(P.format,P.colorSpace),ae=s.convert(P.type),ne=w(P.internalFormat,F,ae,P.colorSpace),ce=P.isVideoTexture!==!0,ge=ie.__version===void 0||se===!0,xe=ve.dataReady;let We=B(P,Ze);Ee(n.TEXTURE_CUBE_MAP,P);let ke;if(Fe){ce&&ge&&t.texStorage2D(n.TEXTURE_CUBE_MAP,We,ne,Ze.width,Ze.height);for(let He=0;He<6;He++){ke=Ge[He].mipmaps;for(let Qe=0;Qe<ke.length;Qe++){const ht=ke[Qe];P.format!==On?F!==null?ce?xe&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe,0,0,ht.width,ht.height,F,ht.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe,ne,ht.width,ht.height,0,ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):ce?xe&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe,0,0,ht.width,ht.height,F,ae,ht.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe,ne,ht.width,ht.height,0,F,ae,ht.data)}}}else{if(ke=P.mipmaps,ce&&ge){ke.length>0&&We++;const He=de(Ge[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,We,ne,He.width,He.height)}for(let He=0;He<6;He++)if(Le){ce?xe&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,0,0,0,Ge[He].width,Ge[He].height,F,ae,Ge[He].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,0,ne,Ge[He].width,Ge[He].height,0,F,ae,Ge[He].data);for(let Qe=0;Qe<ke.length;Qe++){const Pt=ke[Qe].image[He].image;ce?xe&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe+1,0,0,Pt.width,Pt.height,F,ae,Pt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe+1,ne,Pt.width,Pt.height,0,F,ae,Pt.data)}}else{ce?xe&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,0,0,0,F,ae,Ge[He]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,0,ne,F,ae,Ge[He]);for(let Qe=0;Qe<ke.length;Qe++){const ht=ke[Qe];ce?xe&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe+1,0,0,F,ae,ht.image[He]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+He,Qe+1,ne,F,ae,ht.image[He])}}}E(P)&&x(n.TEXTURE_CUBE_MAP),ie.__version=ve.version,P.onUpdate&&P.onUpdate(P)}N.__version=P.version}function Ve(N,P,$,se,ve,ie){const Se=s.convert($.format,$.colorSpace),be=s.convert($.type),Ie=w($.internalFormat,Se,be,$.colorSpace),Fe=i.get(P),Le=i.get($);if(Le.__renderTarget=P,!Fe.__hasExternalTextures){const Ze=Math.max(1,P.width>>ie),F=Math.max(1,P.height>>ie);P.isWebGLMultiviewRenderTarget===!0?t.texStorage3D(n.TEXTURE_2D_ARRAY,0,Ie,P.width,P.height,P.numViews):ve===n.TEXTURE_3D||ve===n.TEXTURE_2D_ARRAY?t.texImage3D(ve,ie,Ie,Ze,F,P.depth,0,Se,be,null):t.texImage2D(ve,ie,Ie,Ze,F,0,Se,be,null)}t.bindFramebuffer(n.FRAMEBUFFER,N);const Ge=T(P);P.isWebGLMultiviewRenderTarget===!0?Ge?c.framebufferTextureMultisampleMultiviewOVR(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,Le.__webglTexture,0,R(P),0,P.numViews):c.framebufferTextureMultiviewOVR(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,Le.__webglTexture,0,0,P.numViews):(ve===n.TEXTURE_2D||ve>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&ve<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&(Ge?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,se,ve,Le.__webglTexture,0,R(P)):n.framebufferTexture2D(n.FRAMEBUFFER,se,ve,Le.__webglTexture,ie)),t.bindFramebuffer(n.FRAMEBUFFER,null)}function me(N,P,$){if(n.bindRenderbuffer(n.RENDERBUFFER,N),P.isWebGLMultiviewRenderTarget===!0){const se=T(P),ve=P.numViews,ie=P.depthTexture;let Se=n.DEPTH_COMPONENT24,be=n.DEPTH_ATTACHMENT;ie&&ie.isDepthTexture&&(ie.type===Un?Se=n.DEPTH_COMPONENT32F:ie.type===vs&&(Se=n.DEPTH24_STENCIL8,be=n.DEPTH_STENCIL_ATTACHMENT));let Ie=i.get(P.depthTexture).__webglTexture;Ie===void 0&&(Ie=n.createTexture(),n.bindTexture(n.TEXTURE_2D_ARRAY,Ie),n.texStorage3D(n.TEXTURE_2D_ARRAY,1,Se,P.width,P.height,ve)),se?c.framebufferTextureMultisampleMultiviewOVR(n.FRAMEBUFFER,be,Ie,0,R(P),0,ve):c.framebufferTextureMultiviewOVR(n.FRAMEBUFFER,be,Ie,0,0,ve)}else if(P.depthBuffer){const se=P.depthTexture,ve=se&&se.isDepthTexture?se.type:null,ie=S(P.stencilBuffer,ve),Se=P.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,be=R(P);T(P)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,be,ie,P.width,P.height):$?n.renderbufferStorageMultisample(n.RENDERBUFFER,be,ie,P.width,P.height):n.renderbufferStorage(n.RENDERBUFFER,ie,P.width,P.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,Se,n.RENDERBUFFER,N)}else{const se=P.textures;for(let ve=0;ve<se.length;ve++){const ie=se[ve],Se=s.convert(ie.format,ie.colorSpace),be=s.convert(ie.type),Ie=w(ie.internalFormat,Se,be,ie.colorSpace),Fe=R(P);$&&T(P)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Fe,Ie,P.width,P.height):T(P)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Fe,Ie,P.width,P.height):n.renderbufferStorage(n.RENDERBUFFER,Ie,P.width,P.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function Ae(N,P){if(P&&P.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,N),!(P.depthTexture&&P.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const se=i.get(P.depthTexture);se.__renderTarget=P,(!se.__webglTexture||P.depthTexture.image.width!==P.width||P.depthTexture.image.height!==P.height)&&(P.depthTexture.image.width=P.width,P.depthTexture.image.height=P.height,P.depthTexture.needsUpdate=!0),P.depthTexture.image.depth!=1?re(P.depthTexture,0):q(P.depthTexture,0);const ve=se.__webglTexture,ie=R(P);if(P.isWebGLMultiviewRenderTarget===!0){const Se=T(P),be=P.numViews;if(P.depthTexture.format===Es)Se?c.framebufferTextureMultisampleMultiviewOVR(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,ve,0,ie,0,be):c.framebufferTextureMultiviewOVR(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,ve,0,0,be);else if(P.depthTexture.format===xs)Se?c.framebufferTextureMultisampleMultiviewOVR(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,ve,0,ie,0,be):c.framebufferTextureMultiviewOVR(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,ve,0,0,be);else throw new Error("Unknown depthTexture format")}else if(P.depthTexture.format===Es)T(P)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ve,0,ie):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ve,0);else if(P.depthTexture.format===xs)T(P)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ve,0,ie):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ve,0);else throw new Error("Unknown depthTexture format")}function V(N){const P=i.get(N),$=N.isWebGLCubeRenderTarget===!0;if(P.__boundDepthTexture!==N.depthTexture){const se=N.depthTexture;if(P.__depthDisposeCallback&&P.__depthDisposeCallback(),se){const ve=()=>{delete P.__boundDepthTexture,delete P.__depthDisposeCallback,se.removeEventListener("dispose",ve)};se.addEventListener("dispose",ve),P.__depthDisposeCallback=ve}P.__boundDepthTexture=se}if(N.depthTexture&&!P.__autoAllocateDepthBuffer){if($)throw new Error("target.depthTexture not supported in Cube render targets");Ae(P.__webglFramebuffer,N)}else if($){P.__webglDepthbuffer=[];for(let se=0;se<6;se++)if(t.bindFramebuffer(n.FRAMEBUFFER,P.__webglFramebuffer[se]),P.__webglDepthbuffer[se]===void 0)P.__webglDepthbuffer[se]=n.createRenderbuffer(),me(P.__webglDepthbuffer[se],N,!1);else{const ve=N.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ie=P.__webglDepthbuffer[se];n.bindRenderbuffer(n.RENDERBUFFER,ie),n.framebufferRenderbuffer(n.FRAMEBUFFER,ve,n.RENDERBUFFER,ie)}}else if(t.bindFramebuffer(n.FRAMEBUFFER,P.__webglFramebuffer),P.__webglDepthbuffer===void 0)P.__webglDepthbuffer=n.createRenderbuffer(),me(P.__webglDepthbuffer,N,!1);else{const se=N.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ve=P.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,ve),n.framebufferRenderbuffer(n.FRAMEBUFFER,se,n.RENDERBUFFER,ve)}t.bindFramebuffer(n.FRAMEBUFFER,null)}function j(N,P,$){const se=i.get(N);P!==void 0&&Ve(se.__webglFramebuffer,N,N.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),$!==void 0&&V(N)}function Te(N){const P=N.texture,$=i.get(N),se=i.get(P);N.addEventListener("dispose",_);const ve=N.textures,ie=N.isWebGLCubeRenderTarget===!0,Se=ve.length>1;if(Se||(se.__webglTexture===void 0&&(se.__webglTexture=n.createTexture()),se.__version=P.version,o.memory.textures++),ie){$.__webglFramebuffer=[];for(let be=0;be<6;be++)if(P.mipmaps&&P.mipmaps.length>0){$.__webglFramebuffer[be]=[];for(let Ie=0;Ie<P.mipmaps.length;Ie++)$.__webglFramebuffer[be][Ie]=n.createFramebuffer()}else $.__webglFramebuffer[be]=n.createFramebuffer()}else{if(P.mipmaps&&P.mipmaps.length>0){$.__webglFramebuffer=[];for(let be=0;be<P.mipmaps.length;be++)$.__webglFramebuffer[be]=n.createFramebuffer()}else $.__webglFramebuffer=n.createFramebuffer();if(Se)for(let be=0,Ie=ve.length;be<Ie;be++){const Fe=i.get(ve[be]);Fe.__webglTexture===void 0&&(Fe.__webglTexture=n.createTexture(),o.memory.textures++)}if(N.samples>0&&T(N)===!1){$.__webglMultisampledFramebuffer=n.createFramebuffer(),$.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,$.__webglMultisampledFramebuffer);for(let be=0;be<ve.length;be++){const Ie=ve[be];$.__webglColorRenderbuffer[be]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,$.__webglColorRenderbuffer[be]);const Fe=s.convert(Ie.format,Ie.colorSpace),Le=s.convert(Ie.type),Ge=w(Ie.internalFormat,Fe,Le,Ie.colorSpace,N.isXRRenderTarget===!0),Ze=R(N);n.renderbufferStorageMultisample(n.RENDERBUFFER,Ze,Ge,N.width,N.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+be,n.RENDERBUFFER,$.__webglColorRenderbuffer[be])}n.bindRenderbuffer(n.RENDERBUFFER,null),N.depthBuffer&&($.__webglDepthRenderbuffer=n.createRenderbuffer(),me($.__webglDepthRenderbuffer,N,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(ie){t.bindTexture(n.TEXTURE_CUBE_MAP,se.__webglTexture),Ee(n.TEXTURE_CUBE_MAP,P);for(let be=0;be<6;be++)if(P.mipmaps&&P.mipmaps.length>0)for(let Ie=0;Ie<P.mipmaps.length;Ie++)Ve($.__webglFramebuffer[be][Ie],N,P,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+be,Ie);else Ve($.__webglFramebuffer[be],N,P,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+be,0);E(P)&&x(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Se){for(let be=0,Ie=ve.length;be<Ie;be++){const Fe=ve[be],Le=i.get(Fe);t.bindTexture(n.TEXTURE_2D,Le.__webglTexture),Ee(n.TEXTURE_2D,Fe),Ve($.__webglFramebuffer,N,Fe,n.COLOR_ATTACHMENT0+be,n.TEXTURE_2D,0),E(Fe)&&x(n.TEXTURE_2D)}t.unbindTexture()}else{let be=n.TEXTURE_2D;if((N.isWebGL3DRenderTarget||N.isWebGLArrayRenderTarget)&&(be=N.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),N.isWebGLMultiviewRenderTarget===!0&&(be=n.TEXTURE_2D_ARRAY),t.bindTexture(be,se.__webglTexture),Ee(be,P),P.mipmaps&&P.mipmaps.length>0)for(let Ie=0;Ie<P.mipmaps.length;Ie++)Ve($.__webglFramebuffer[Ie],N,P,n.COLOR_ATTACHMENT0,be,Ie);else Ve($.__webglFramebuffer,N,P,n.COLOR_ATTACHMENT0,be,0);E(P)&&x(be),t.unbindTexture()}(N.depthBuffer||N.isWebGLMultiviewRenderTarget===!0)&&this.setupDepthRenderbuffer(N)}function Re(N){const P=N.textures;for(let $=0,se=P.length;$<se;$++){const ve=P[$];if(E(ve)){const ie=M(N),Se=i.get(ve).__webglTexture;t.bindTexture(ie,Se),x(ie),t.unbindTexture()}}}const b=[],I=[];function U(N){if(N.samples>0){if(T(N)===!1){const P=N.textures,$=N.width,se=N.height;let ve=n.COLOR_BUFFER_BIT;const ie=N.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Se=i.get(N),be=P.length>1;if(be)for(let Ie=0;Ie<P.length;Ie++)t.bindFramebuffer(n.FRAMEBUFFER,Se.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ie,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,Se.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ie,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,Se.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Se.__webglFramebuffer);for(let Ie=0;Ie<P.length;Ie++){if(N.resolveDepthBuffer&&(N.depthBuffer&&(ve|=n.DEPTH_BUFFER_BIT),N.stencilBuffer&&N.resolveStencilBuffer&&(ve|=n.STENCIL_BUFFER_BIT)),be){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,Se.__webglColorRenderbuffer[Ie]);const Fe=i.get(P[Ie]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,Fe,0)}n.blitFramebuffer(0,0,$,se,0,0,$,se,ve,n.NEAREST),l===!0&&(b.length=0,I.length=0,b.push(n.COLOR_ATTACHMENT0+Ie),N.depthBuffer&&N.resolveDepthBuffer===!1&&(b.push(ie),I.push(ie),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,I)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,b))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),be)for(let Ie=0;Ie<P.length;Ie++){t.bindFramebuffer(n.FRAMEBUFFER,Se.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ie,n.RENDERBUFFER,Se.__webglColorRenderbuffer[Ie]);const Fe=i.get(P[Ie]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,Se.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Ie,n.TEXTURE_2D,Fe,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Se.__webglMultisampledFramebuffer)}else if(N.depthBuffer&&N.resolveDepthBuffer===!1&&l){const P=N.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[P])}}}function R(N){return Math.min(r.maxSamples,N.samples)}function T(N){const P=i.get(N);return N.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&P.__useRenderToTexture!==!1}function G(N){const P=o.render.frame;u.get(N)!==P&&(u.set(N,P),N.update())}function J(N,P){const $=N.colorSpace,se=N.format,ve=N.type;return N.isCompressedTexture===!0||N.isVideoTexture===!0||$!==Io&&$!==xr&&(wt.getTransfer($)===Ut?(se!==On||ve!==er)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",$)),P}function de(N){return typeof HTMLImageElement<"u"&&N instanceof HTMLImageElement?(h.width=N.naturalWidth||N.width,h.height=N.naturalHeight||N.height):typeof VideoFrame<"u"&&N instanceof VideoFrame?(h.width=N.displayWidth,h.height=N.displayHeight):(h.width=N.width,h.height=N.height),h}this.allocateTextureUnit=W,this.resetTextureUnits=te,this.setTexture2D=q,this.setTexture2DArray=re,this.setTexture3D=ue,this.setTextureCube=_e,this.rebindTextures=j,this.uploadTexture=we,this.setupRenderTarget=Te,this.updateRenderTargetMipmap=Re,this.updateMultisampleRenderTarget=U,this.setupDepthTexture=Ae,this.setupDepthRenderbuffer=V,this.setupFrameBufferTexture=Ve,this.useMultisampledRTT=T,this.runDeferredUploads=oe,this.setDeferTextureUploads=pe}function pM(n,e){function t(i,r=xr){let s;const o=wt.getTransfer(r);if(i===er)return n.UNSIGNED_BYTE;if(i===lf)return n.UNSIGNED_SHORT_4_4_4_4;if(i===cf)return n.UNSIGNED_SHORT_5_5_5_1;if(i===Kg)return n.UNSIGNED_INT_5_9_9_9_REV;if(i===jg)return n.BYTE;if(i===$g)return n.SHORT;if(i===Xa)return n.UNSIGNED_SHORT;if(i===af)return n.INT;if(i===Gr)return n.UNSIGNED_INT;if(i===Un)return n.FLOAT;if(i===il)return n.HALF_FLOAT;if(i===Jg)return n.ALPHA;if(i===Zg)return n.RGB;if(i===On)return n.RGBA;if(i===e0)return n.LUMINANCE;if(i===t0)return n.LUMINANCE_ALPHA;if(i===Es)return n.DEPTH_COMPONENT;if(i===xs)return n.DEPTH_STENCIL;if(i===hf)return n.RED;if(i===Lc)return n.RED_INTEGER;if(i===n0)return n.RG;if(i===uf)return n.RG_INTEGER;if(i===df)return n.RGBA_INTEGER;if(i===Wl||i===Xl||i===ql||i===Yl)if(o===Ut)if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(i===Wl)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===Xl)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===ql)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===Yl)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=e.get("WEBGL_compressed_texture_s3tc"),s!==null){if(i===Wl)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===Xl)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===ql)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===Yl)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===cd||i===hd||i===ud||i===dd)if(s=e.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(i===cd)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===hd)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===ud)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===dd)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===fd||i===pd||i===md)if(s=e.get("WEBGL_compressed_texture_etc"),s!==null){if(i===fd||i===pd)return o===Ut?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(i===md)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===Ad||i===gd||i===vd||i===Ed||i===xd||i===yd||i===_d||i===bd||i===Cd||i===Md||i===Sd||i===wd||i===Td||i===Id)if(s=e.get("WEBGL_compressed_texture_astc"),s!==null){if(i===Ad)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===gd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===vd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===Ed)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===xd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===yd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===_d)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===bd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===Cd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===Md)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===Sd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===wd)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===Td)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===Id)return o===Ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===jl||i===Rd||i===Bd)if(s=e.get("EXT_texture_compression_bptc"),s!==null){if(i===jl)return o===Ut?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===Rd)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===Bd)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(i===i0||i===Ld||i===Dd||i===Pd)if(s=e.get("EXT_texture_compression_rgtc"),s!==null){if(i===jl)return s.COMPRESSED_RED_RGTC1_EXT;if(i===Ld)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===Dd)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===Pd)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return i===vs?n.UNSIGNED_INT_24_8:n[i]!==void 0?n[i]:null}return{convert:t}}class mM extends Ui{constructor(e,t,i,r={}){super(e,t,r),this.depthBuffer=!1,this.stencilBuffer=!1,this.numViews=i}copy(e){return super.copy(e),this.numViews=e.numViews,this}}mM.prototype.isWebGLMultiviewRenderTarget=!0;const SD=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,wD=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;let TD=class{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,i){if(this.texture===null){const r=new mn,s=e.properties.get(r);s.__webglTexture=t.texture,(t.depthNear!==i.depthNear||t.depthFar!==i.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=r}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,i=new Ni({vertexShader:SD,fragmentShader:wD,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new en(new Bf(20,20),i)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}},ID=class extends tr{constructor(e,t,i,r){super();const s=this;let o=null,a=1;var l=null;let c=null,h="local-floor",u=1,d=null,f=null;var A=[];let g=null,m=null,p=null,v=null;const E=new TD,x=t.getContextAttributes();let M=null,w=null;const S=[],B=[],y=new Ne;let _=null;const L=new gn;L.viewport=new Dt;const Q=new gn;Q.viewport=new Dt;const O=[L,Q],X=new iM;let te=null,W=null;this.cameraAutoUpdate=!0,this.layersEnabled=!1,this.enabled=!1,this.isPresenting=!1,this.isMultiview=!1,this.getCameraPose=function(){return f},this.getController=function(oe){let we=S[oe];return we===void 0&&(we=new Ou,S[oe]=we),we.getTargetRaySpace()},this.getControllerGrip=function(oe){let we=S[oe];return we===void 0&&(we=new Ou,S[oe]=we),we.getGripSpace()},this.getHand=function(oe){let we=S[oe];return we===void 0&&(we=new Ou,S[oe]=we),we.getHandSpace()};function Z(oe){const we=B.indexOf(oe.inputSource);if(we===-1)return;const Me=S[we];Me!==void 0&&(Me.update(oe.inputSource,oe.frame,d||c),Me.dispatchEvent({type:oe.type,data:oe.inputSource}))}function q(){o.removeEventListener("select",Z),o.removeEventListener("selectstart",Z),o.removeEventListener("selectend",Z),o.removeEventListener("squeeze",Z),o.removeEventListener("squeezestart",Z),o.removeEventListener("squeezeend",Z),o.removeEventListener("end",q),o.removeEventListener("inputsourceschange",re);for(let oe=0;oe<S.length;oe++){const we=B[oe];we!==null&&(B[oe]=null,S[oe].disconnect(we))}te=null,W=null,E.reset(),s.isPresenting=!1,e.setRenderTarget(M),p=null,m=null,g=null,o=null,w=null,pe.stop(),e.setPixelRatio(_),e.setSize(y.width,y.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(oe){a=oe,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(oe){h=oe,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return d||c},this.setReferenceSpace=function(oe){d=oe},this.getBaseLayer=function(){return m!==null?m:p},this.getBinding=function(){return g},this.getRenderTarget=function(){return w},this.getFrame=function(){return v},this.getSession=function(){return o},this.setSession=async function(oe){if(o=oe,o!==null){if(M=e.getRenderTarget(),o.addEventListener("select",Z),o.addEventListener("selectstart",Z),o.addEventListener("selectend",Z),o.addEventListener("squeeze",Z),o.addEventListener("squeezestart",Z),o.addEventListener("squeezeend",Z),o.addEventListener("end",q),o.addEventListener("inputsourceschange",re),x.xrCompatible!==!0&&await t.makeXRCompatible(),_=e.getPixelRatio(),e.getSize(y),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let Me=null,Ve=null,me=null;x.depth&&(me=x.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Me=x.stencil?xs:Es,Ve=x.stencil?vs:Gr),s.isMultiview=r&&i.has("OCULUS_multiview");const Ae={colorFormat:t.RGBA8,depthFormat:me,scaleFactor:a};s.isMultiview&&(Ae.textureType="texture-array"),g=new XRWebGLBinding(o,t),m=g.createProjectionLayer(Ae),o.updateRenderState({layers:[m]}),e.setPixelRatio(1),e.setSize(m.textureWidth,m.textureHeight,!1);const V={format:On,type:er,depthTexture:new d0(m.textureWidth,m.textureHeight,Ve,void 0,void 0,void 0,void 0,void 0,void 0,Me),stencilBuffer:x.stencil,colorSpace:e.outputColorSpace,samples:x.antialias?4:0,resolveDepthBuffer:m.ignoreDepthValues===!1};if(s.isMultiview){const j=i.get("OCULUS_multiview");this.maxNumViews=t.getParameter(j.MAX_VIEWS_OVR),w=new mM(m.textureWidth,m.textureHeight,2,V)}else w=new Ui(m.textureWidth,m.textureHeight,V)}else{const Me={antialias:x.antialias,alpha:!0,depth:x.depth,stencil:x.stencil,framebufferScaleFactor:a};p=new XRWebGLLayer(o,t,Me),o.updateRenderState({baseLayer:p}),e.setPixelRatio(1),e.setSize(p.framebufferWidth,p.framebufferHeight,!1),w=new Ui(p.framebufferWidth,p.framebufferHeight,{format:On,type:er,colorSpace:e.outputColorSpace,stencilBuffer:x.stencil})}w.isXRRenderTarget=!0,this.setFoveation(u),d=null,c=await o.requestReferenceSpace(h),pe.setContext(o),pe.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(o!==null)return o.environmentBlendMode},this.addLayer=function(oe){!window.XRWebGLBinding||!this.layersEnabled||!o||(A.push(oe),this.updateLayers())},this.removeLayer=function(oe){A.splice(A.indexOf(oe),1),!(!window.XRWebGLBinding||!this.layersEnabled||!o)&&this.updateLayers()},this.updateLayers=function(){var oe=A.map(function(we){return we});oe.unshift(o.renderState.layers[0]),o.updateRenderState({layers:oe})},this.getDepthTexture=function(){return E.getDepthTexture()};function re(oe){for(let we=0;we<oe.removed.length;we++){const Me=oe.removed[we],Ve=B.indexOf(Me);Ve>=0&&(B[Ve]=null,S[Ve].disconnect(Me))}for(let we=0;we<oe.added.length;we++){const Me=oe.added[we];let Ve=B.indexOf(Me);if(Ve===-1){for(let Ae=0;Ae<S.length;Ae++)if(Ae>=B.length){B.push(Me),Ve=Ae;break}else if(B[Ae]===null){B[Ae]=Me,Ve=Ae;break}if(Ve===-1)break}const me=S[Ve];me&&me.connect(Me)}}const ue=new Y,_e=new Y;function Be(oe,we,Me){ue.setFromMatrixPosition(we.matrixWorld),_e.setFromMatrixPosition(Me.matrixWorld);const Ve=ue.distanceTo(_e),me=we.projectionMatrix.elements,Ae=Me.projectionMatrix.elements,V=me[14]/(me[10]-1),j=me[14]/(me[10]+1),Te=(me[9]+1)/me[5],Re=(me[9]-1)/me[5],b=(me[8]-1)/me[0],I=(Ae[8]+1)/Ae[0],U=V*b,R=V*I,T=Ve/(-b+I),G=T*-b;if(we.matrixWorld.decompose(oe.position,oe.quaternion,oe.scale),oe.translateX(G),oe.translateZ(T),oe.matrixWorld.compose(oe.position,oe.quaternion,oe.scale),oe.matrixWorldInverse.copy(oe.matrixWorld).invert(),me[10]===-1)oe.projectionMatrix.copy(we.projectionMatrix),oe.projectionMatrixInverse.copy(we.projectionMatrixInverse);else{const J=V+T,de=j+T,N=U-G,P=R+(Ve-G),$=Te*j/de*J,se=Re*j/de*J;oe.projectionMatrix.makePerspective(N,P,$,se,J,de),oe.projectionMatrixInverse.copy(oe.projectionMatrix).invert()}}function ze(oe,we){we===null?oe.matrixWorld.copy(oe.matrix):oe.matrixWorld.multiplyMatrices(we.matrixWorld,oe.matrix),oe.matrixWorldInverse.copy(oe.matrixWorld).invert()}this.setPoseTarget=function(oe){oe!==void 0&&(l=oe)},this.updateCamera=function(oe){if(o===null)return;let we=oe.near,Me=oe.far;E.texture!==null&&(E.depthNear>0&&(we=E.depthNear),E.depthFar>0&&(Me=E.depthFar)),X.near=Q.near=L.near=we,X.far=Q.far=L.far=Me,(te!==X.near||W!==X.far)&&(o.updateRenderState({depthNear:X.near,depthFar:X.far}),te=X.near,W=X.far),L.layers.mask=oe.layers.mask|2,Q.layers.mask=oe.layers.mask|4,X.layers.mask=L.layers.mask|Q.layers.mask;const Ve=X.cameras;var me=l||oe;const Ae=me.parent;ze(X,Ae);for(let V=0;V<Ve.length;V++)ze(Ve[V],Ae);Ve.length===2?Be(X,L,Q):X.projectionMatrix.copy(L.projectionMatrix),le(oe,X,me)};function le(oe,we,Me){we.matrixWorld.decompose(we.position,we.quaternion,we.scale),Me.parent===null?Me.matrix.copy(we.matrixWorld):(Me.matrix.copy(Me.parent.matrixWorld),Me.matrix.invert(),Me.matrix.multiply(we.matrixWorld)),Me.matrix.decompose(Me.position,Me.quaternion,Me.scale),Me.updateMatrixWorld(!0),oe.projectionMatrix.copy(we.projectionMatrix),oe.projectionMatrixInverse.copy(we.projectionMatrixInverse),oe.isPerspectiveCamera&&(oe.fov=qa*2*Math.atan(1/oe.projectionMatrix.elements[5]),oe.zoom=1)}this.getCamera=function(){return X},this.getFoveation=function(){if(!(m===null&&p===null))return u},this.setFoveation=function(oe){u=oe,m!==null&&(m.fixedFoveation=oe),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=oe)},this.hasDepthSensing=function(){return E.texture!==null},this.getDepthSensingMesh=function(){return E.getMesh(X)};let Ee=null;function Ue(oe,we){if(f=we.getViewerPose(d||c),v=we,f!==null){const Me=f.views;p!==null&&(e.setRenderTargetFramebuffer(w,p.framebuffer),e.setRenderTarget(w));let Ve=!1;Me.length!==X.cameras.length&&(X.cameras.length=0,Ve=!0);for(let V=0;V<Me.length;V++){const j=Me[V];let Te=null;if(p!==null)Te=p.getViewport(j);else{const b=g.getViewSubImage(m,j);Te=b.viewport,V===0&&(e.setRenderTargetTextures(w,b.colorTexture,m.ignoreDepthValues?void 0:b.depthStencilTexture),e.setRenderTarget(w))}let Re=O[V];Re===void 0&&(Re=new gn,Re.layers.enable(V),Re.viewport=new Dt,O[V]=Re),Re.matrix.fromArray(j.transform.matrix),Re.matrix.decompose(Re.position,Re.quaternion,Re.scale),Re.projectionMatrix.fromArray(j.projectionMatrix),Re.projectionMatrixInverse.copy(Re.projectionMatrix).invert(),Re.viewport.set(Te.x,Te.y,Te.width,Te.height),V===0&&(X.matrix.copy(Re.matrix),X.matrix.decompose(X.position,X.quaternion,X.scale)),Ve===!0&&X.cameras.push(Re)}const me=o.enabledFeatures;if(me&&me.includes("depth-sensing")&&o.depthUsage=="gpu-optimized"&&g){const V=g.getDepthInformation(Me[0]);V&&V.isValid&&V.texture&&E.init(e,V,o.renderState)}}for(let Me=0;Me<S.length;Me++){const Ve=B[Me],me=S[Me];Ve!==null&&me!==void 0&&me.update(Ve,we,d||c)}Ee&&Ee(oe,we),we.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:we}),v=null}const pe=new cM;pe.setAnimationLoop(Ue),this.setAnimationLoop=function(oe){Ee=oe},this.dispose=function(){}}};const Xs=new Fi,RD=new ct;function BD(n,e){function t(m,p){m.matrixAutoUpdate===!0&&m.updateMatrix(),p.value.copy(m.matrix)}function i(m,p){p.color.getRGB(m.fogColor.value,aC(n)),p.isFog?(m.fogNear.value=p.near,m.fogFar.value=p.far):p.isFogExp2&&(m.fogDensity.value=p.density)}function r(m,p,v,E,x){p.isMeshBasicMaterial||p.isMeshLambertMaterial?s(m,p):p.isMeshToonMaterial?(s(m,p),u(m,p)):p.isMeshPhongMaterial?(s(m,p),h(m,p)):p.isMeshStandardMaterial?(s(m,p),d(m,p),p.isMeshPhysicalMaterial&&f(m,p,x)):p.isMeshMatcapMaterial?(s(m,p),A(m,p)):p.isMeshDepthMaterial?s(m,p):p.isMeshDistanceMaterial?(s(m,p),g(m,p)):p.isMeshNormalMaterial?s(m,p):p.isLineBasicMaterial?(o(m,p),p.isLineDashedMaterial&&a(m,p)):p.isPointsMaterial?l(m,p,v,E):p.isSpriteMaterial?c(m,p):p.isShadowMaterial?(m.color.value.copy(p.color),m.opacity.value=p.opacity):p.isShaderMaterial&&(p.uniformsNeedUpdate=!1)}function s(m,p){m.opacity.value=p.opacity,p.color&&m.diffuse.value.copy(p.color),p.emissive&&m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),p.map&&(m.map.value=p.map,t(p.map,m.mapTransform)),p.alphaMap&&(m.alphaMap.value=p.alphaMap,t(p.alphaMap,m.alphaMapTransform)),p.bumpMap&&(m.bumpMap.value=p.bumpMap,t(p.bumpMap,m.bumpMapTransform),m.bumpScale.value=p.bumpScale,p.side===kn&&(m.bumpScale.value*=-1)),p.normalMap&&(m.normalMap.value=p.normalMap,t(p.normalMap,m.normalMapTransform),m.normalScale.value.copy(p.normalScale),p.side===kn&&m.normalScale.value.negate()),p.displacementMap&&(m.displacementMap.value=p.displacementMap,t(p.displacementMap,m.displacementMapTransform),m.displacementScale.value=p.displacementScale,m.displacementBias.value=p.displacementBias),p.emissiveMap&&(m.emissiveMap.value=p.emissiveMap,t(p.emissiveMap,m.emissiveMapTransform)),p.specularMap&&(m.specularMap.value=p.specularMap,t(p.specularMap,m.specularMapTransform)),p.alphaTest>0&&(m.alphaTest.value=p.alphaTest);const v=e.get(p),E=v.envMap,x=v.envMapRotation;E&&(m.envMap.value=E,Xs.copy(x),Xs.x*=-1,Xs.y*=-1,Xs.z*=-1,E.isCubeTexture&&E.isRenderTargetTexture===!1&&(Xs.y*=-1,Xs.z*=-1),m.envMapRotation.value.setFromMatrix4(RD.makeRotationFromEuler(Xs)),m.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=p.reflectivity,m.ior.value=p.ior,m.refractionRatio.value=p.refractionRatio),p.lightMap&&(m.lightMap.value=p.lightMap,m.lightMapIntensity.value=p.lightMapIntensity,t(p.lightMap,m.lightMapTransform)),p.aoMap&&(m.aoMap.value=p.aoMap,m.aoMapIntensity.value=p.aoMapIntensity,t(p.aoMap,m.aoMapTransform))}function o(m,p){m.diffuse.value.copy(p.color),m.opacity.value=p.opacity,p.map&&(m.map.value=p.map,t(p.map,m.mapTransform))}function a(m,p){m.dashSize.value=p.dashSize,m.totalSize.value=p.dashSize+p.gapSize,m.scale.value=p.scale}function l(m,p,v,E){m.diffuse.value.copy(p.color),m.opacity.value=p.opacity,m.size.value=p.size*v,m.scale.value=E*.5,p.map&&(m.map.value=p.map,t(p.map,m.uvTransform)),p.alphaMap&&(m.alphaMap.value=p.alphaMap,t(p.alphaMap,m.alphaMapTransform)),p.alphaTest>0&&(m.alphaTest.value=p.alphaTest)}function c(m,p){m.diffuse.value.copy(p.color),m.opacity.value=p.opacity,m.rotation.value=p.rotation,p.map&&(m.map.value=p.map,t(p.map,m.mapTransform)),p.alphaMap&&(m.alphaMap.value=p.alphaMap,t(p.alphaMap,m.alphaMapTransform)),p.alphaTest>0&&(m.alphaTest.value=p.alphaTest)}function h(m,p){m.specular.value.copy(p.specular),m.shininess.value=Math.max(p.shininess,1e-4)}function u(m,p){p.gradientMap&&(m.gradientMap.value=p.gradientMap)}function d(m,p){m.metalness.value=p.metalness,p.metalnessMap&&(m.metalnessMap.value=p.metalnessMap,t(p.metalnessMap,m.metalnessMapTransform)),m.roughness.value=p.roughness,p.roughnessMap&&(m.roughnessMap.value=p.roughnessMap,t(p.roughnessMap,m.roughnessMapTransform)),p.envMap&&(m.envMapIntensity.value=p.envMapIntensity)}function f(m,p,v){m.ior.value=p.ior,p.sheen>0&&(m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),m.sheenRoughness.value=p.sheenRoughness,p.sheenColorMap&&(m.sheenColorMap.value=p.sheenColorMap,t(p.sheenColorMap,m.sheenColorMapTransform)),p.sheenRoughnessMap&&(m.sheenRoughnessMap.value=p.sheenRoughnessMap,t(p.sheenRoughnessMap,m.sheenRoughnessMapTransform))),p.clearcoat>0&&(m.clearcoat.value=p.clearcoat,m.clearcoatRoughness.value=p.clearcoatRoughness,p.clearcoatMap&&(m.clearcoatMap.value=p.clearcoatMap,t(p.clearcoatMap,m.clearcoatMapTransform)),p.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=p.clearcoatRoughnessMap,t(p.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),p.clearcoatNormalMap&&(m.clearcoatNormalMap.value=p.clearcoatNormalMap,t(p.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),p.side===kn&&m.clearcoatNormalScale.value.negate())),p.dispersion>0&&(m.dispersion.value=p.dispersion),p.iridescence>0&&(m.iridescence.value=p.iridescence,m.iridescenceIOR.value=p.iridescenceIOR,m.iridescenceThicknessMinimum.value=p.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=p.iridescenceThicknessRange[1],p.iridescenceMap&&(m.iridescenceMap.value=p.iridescenceMap,t(p.iridescenceMap,m.iridescenceMapTransform)),p.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=p.iridescenceThicknessMap,t(p.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),p.transmission>0&&(m.transmission.value=p.transmission,m.transmissionSamplerMap.value=v.texture,m.transmissionSamplerSize.value.set(v.width,v.height),p.transmissionMap&&(m.transmissionMap.value=p.transmissionMap,t(p.transmissionMap,m.transmissionMapTransform)),m.thickness.value=p.thickness,p.thicknessMap&&(m.thicknessMap.value=p.thicknessMap,t(p.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=p.attenuationDistance,m.attenuationColor.value.copy(p.attenuationColor)),p.anisotropy>0&&(m.anisotropyVector.value.set(p.anisotropy*Math.cos(p.anisotropyRotation),p.anisotropy*Math.sin(p.anisotropyRotation)),p.anisotropyMap&&(m.anisotropyMap.value=p.anisotropyMap,t(p.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=p.specularIntensity,m.specularColor.value.copy(p.specularColor),p.specularColorMap&&(m.specularColorMap.value=p.specularColorMap,t(p.specularColorMap,m.specularColorMapTransform)),p.specularIntensityMap&&(m.specularIntensityMap.value=p.specularIntensityMap,t(p.specularIntensityMap,m.specularIntensityMapTransform))}function A(m,p){p.matcap&&(m.matcap.value=p.matcap)}function g(m,p){const v=e.get(p).light;m.referencePosition.value.setFromMatrixPosition(v.matrixWorld),m.nearDistance.value=v.shadow.camera.near,m.farDistance.value=v.shadow.camera.far}return{refreshFogUniforms:i,refreshMaterialUniforms:r}}function LD(n,e,t,i){let r={},s={},o=[];const a=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function l(v,E){const x=E.program;i.uniformBlockBinding(v,x)}function c(v,E){let x=r[v.id];x===void 0&&(A(v),x=h(v),r[v.id]=x,v.addEventListener("dispose",m));const M=E.program;i.updateUBOMapping(v,M);const w=e.render.frame;s[v.id]!==w&&(d(v),s[v.id]=w)}function h(v){const E=u();v.__bindingPointIndex=E;const x=n.createBuffer(),M=v.__size,w=v.usage;return n.bindBuffer(n.UNIFORM_BUFFER,x),n.bufferData(n.UNIFORM_BUFFER,M,w),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,E,x),x}function u(){for(let v=0;v<a;v++)if(o.indexOf(v)===-1)return o.push(v),v;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(v){const E=r[v.id],x=v.uniforms,M=v.__cache;n.bindBuffer(n.UNIFORM_BUFFER,E);for(let w=0,S=x.length;w<S;w++){const B=Array.isArray(x[w])?x[w]:[x[w]];for(let y=0,_=B.length;y<_;y++){const L=B[y];if(f(L,w,y,M)===!0){const Q=L.__offset,O=Array.isArray(L.value)?L.value:[L.value];let X=0;for(let te=0;te<O.length;te++){const W=O[te],Z=g(W);typeof W=="number"||typeof W=="boolean"?(L.__data[0]=W,n.bufferSubData(n.UNIFORM_BUFFER,Q+X,L.__data)):W.isMatrix3?(L.__data[0]=W.elements[0],L.__data[1]=W.elements[1],L.__data[2]=W.elements[2],L.__data[3]=0,L.__data[4]=W.elements[3],L.__data[5]=W.elements[4],L.__data[6]=W.elements[5],L.__data[7]=0,L.__data[8]=W.elements[6],L.__data[9]=W.elements[7],L.__data[10]=W.elements[8],L.__data[11]=0):(W.toArray(L.__data,X),X+=Z.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,Q,L.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function f(v,E,x,M){const w=v.value,S=E+"_"+x;if(M[S]===void 0)return typeof w=="number"||typeof w=="boolean"?M[S]=w:M[S]=w.clone(),!0;{const B=M[S];if(typeof w=="number"||typeof w=="boolean"){if(B!==w)return M[S]=w,!0}else if(B.equals(w)===!1)return B.copy(w),!0}return!1}function A(v){const E=v.uniforms;let x=0;const M=16;for(let S=0,B=E.length;S<B;S++){const y=Array.isArray(E[S])?E[S]:[E[S]];for(let _=0,L=y.length;_<L;_++){const Q=y[_],O=Array.isArray(Q.value)?Q.value:[Q.value];for(let X=0,te=O.length;X<te;X++){const W=O[X],Z=g(W),q=x%M,re=q%Z.boundary,ue=q+re;x+=re,ue!==0&&M-ue<Z.storage&&(x+=M-ue),Q.__data=new Float32Array(Z.storage/Float32Array.BYTES_PER_ELEMENT),Q.__offset=x,x+=Z.storage}}}const w=x%M;return w>0&&(x+=M-w),v.__size=x,v.__cache={},this}function g(v){const E={boundary:0,storage:0};return typeof v=="number"||typeof v=="boolean"?(E.boundary=4,E.storage=4):v.isVector2?(E.boundary=8,E.storage=8):v.isVector3||v.isColor?(E.boundary=16,E.storage=12):v.isVector4?(E.boundary=16,E.storage=16):v.isMatrix3?(E.boundary=48,E.storage=48):v.isMatrix4?(E.boundary=64,E.storage=64):v.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",v),E}function m(v){const E=v.target;E.removeEventListener("dispose",m);const x=o.indexOf(E.__bindingPointIndex);o.splice(x,1),n.deleteBuffer(r[E.id]),delete r[E.id],delete s[E.id]}function p(){for(const v in r)n.deleteBuffer(r[v]);o=[],r={},s={}}return{bind:l,update:c,dispose:p}}let DD=class{constructor(e={}){const{canvas:t=Zb(),context:i=null,depth:r=!0,stencil:s=!1,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:u=!1,reverseDepthBuffer:d=!1,multiviewStereo:f=!1}=e;this.isWebGLRenderer=!0;let A;if(i!==null){if(typeof WebGLRenderingContext<"u"&&i instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");A=i.getContextAttributes().alpha}else A=o;const g=new Uint32Array(4),m=new Int32Array(4);let p=null,v=null;const E=[],x=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Xn,this.toneMapping=Dr,this.toneMappingExposure=1;const M=this;let w=!1,S=0,B=0,y=null,_=-1,L=null;const Q=new Dt,O=new Dt;let X=null;const te=new Ke(0);let W=0,Z=t.width,q=t.height,re=1,ue=null,_e=null;const Be=new Dt(0,0,Z,q),ze=new Dt(0,0,Z,q);let le=!1;const Ee=new Fc;let Ue=!1,pe=!1;this.transmissionResolutionScale=1;const oe=new ct,we=new ct,Me=new Y,Ve=new Dt,me={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Ae=!1;function V(){return y===null?re:1}let j=i;function Te(D,z){return t.getContext(D,z)}try{const D={alpha:!0,depth:r,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:u};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${sf}`),t.addEventListener("webglcontextlost",xe,!1),t.addEventListener("webglcontextrestored",We,!1),t.addEventListener("webglcontextcreationerror",ke,!1),j===null){const z="webgl2";if(j=Te(z,D),j===null)throw Te(z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(D){throw console.error("THREE.WebGLRenderer: "+D.message),D}let Re,b,I,U,R,T,G,J,de,N,P,$,se,ve,ie,Se,be,Ie,Fe,Le,Ge,Ze,F,ae,ne;function ce(){Re=new VB(j),Re.init(),F=new pM(j,Re),b=new NB(j,Re,e,F),I=new CD(j,Re),b.reverseDepthBuffer&&d&&I.buffers.depth.setReversed(!0),U=new XB(j),R=new uD,T=new MD(j,Re,I,R,b,F,U),G=new kB(M),J=new HB(M),de=new Z2(j),ae=new UB(j,de),N=new QB(j,de,U,ae),P=new jB(j,N,de,U),Le=new qB(j,b,T),Se=new OB(R),$=new hD(M,G,J,Re,b,ae,Se),se=new BD(M,R),ve=new fD,ie=new ED(Re),Fe=new PB(M,G,J,I,P,A,l),Ie=new YB(M,Re,j),be=new _D(M,P,b),ne=new LD(j,U,b,I),Ge=new FB(j,Re,U),Ze=new WB(j,Re,U),U.programs=$.programs,M.capabilities=b,M.extensions=Re,M.properties=R,M.renderLists=ve,M.shadowMap=be,M.state=I,M.info=U}ce();const ge=new ID(M,j);this.xr=ge,this.getContext=function(){return j},this.getContextAttributes=function(){return j.getContextAttributes()},this.forceContextLoss=function(){const D=Re.get("WEBGL_lose_context");D&&D.loseContext()},this.forceContextRestore=function(){const D=Re.get("WEBGL_lose_context");D&&D.restoreContext()},this.getPixelRatio=function(){return re},this.setPixelRatio=function(D){D!==void 0&&(re=D,this.setSize(Z,q,!1))},this.getSize=function(D){return D.set(Z,q)},this.setSize=function(D,z,k=!0){if(ge.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}Z=D,q=z,t.width=Math.floor(D*re),t.height=Math.floor(z*re),k===!0&&(t.style.width=D+"px",t.style.height=z+"px"),this.setViewport(0,0,D,z)},this.getDrawingBufferSize=function(D){return D.set(Z*re,q*re).floor()},this.setDrawingBufferSize=function(D,z,k){Z=D,q=z,re=k,t.width=Math.floor(D*k),t.height=Math.floor(z*k),this.setViewport(0,0,D,z)},this.getCurrentViewport=function(D){return D.copy(Q)},this.getViewport=function(D){return D.copy(Be)},this.setViewport=function(D,z,k,ee){D.isVector4?Be.set(D.x,D.y,D.z,D.w):Be.set(D,z,k,ee),I.viewport(Q.copy(Be).multiplyScalar(re).round())},this.getScissor=function(D){return D.copy(ze)},this.setScissor=function(D,z,k,ee){D.isVector4?ze.set(D.x,D.y,D.z,D.w):ze.set(D,z,k,ee),I.scissor(O.copy(ze).multiplyScalar(re).round())},this.getScissorTest=function(){return le},this.setScissorTest=function(D){I.setScissorTest(le=D)},this.setOpaqueSort=function(D){ue=D},this.setTransparentSort=function(D){_e=D},this.getClearColor=function(D){return D.copy(Fe.getClearColor())},this.setClearColor=function(){Fe.setClearColor.apply(Fe,arguments)},this.getClearAlpha=function(){return Fe.getClearAlpha()},this.setClearAlpha=function(){Fe.setClearAlpha.apply(Fe,arguments)},this.clear=function(D=!0,z=!0,k=!0){let ee=0;if(D){let K=!1;if(y!==null){const fe=y.texture.format;K=fe===df||fe===uf||fe===Lc}if(K){const fe=y.texture.type,Ce=fe===er||fe===Gr||fe===Xa||fe===vs||fe===lf||fe===cf,De=Fe.getClearColor(),Pe=Fe.getClearAlpha(),Oe=De.r,qe=De.g,Xe=De.b;Ce?(g[0]=Oe,g[1]=qe,g[2]=Xe,g[3]=Pe,j.clearBufferuiv(j.COLOR,0,g)):(m[0]=Oe,m[1]=qe,m[2]=Xe,m[3]=Pe,j.clearBufferiv(j.COLOR,0,m))}else ee|=j.COLOR_BUFFER_BIT}z&&(ee|=j.DEPTH_BUFFER_BIT),k&&(ee|=j.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),j.clear(ee)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",xe,!1),t.removeEventListener("webglcontextrestored",We,!1),t.removeEventListener("webglcontextcreationerror",ke,!1),Fe.dispose(),ve.dispose(),ie.dispose(),R.dispose(),G.dispose(),J.dispose(),P.dispose(),ae.dispose(),ne.dispose(),$.dispose(),ge.dispose(),ge.removeEventListener("sessionstart",zi),ge.removeEventListener("sessionend",ko),Hi.stop()};function xe(D){D.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function We(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const D=U.autoReset,z=be.enabled,k=be.autoUpdate,ee=be.needsUpdate,K=be.type;ce(),U.autoReset=D,be.enabled=z,be.autoUpdate=k,be.needsUpdate=ee,be.type=K}function ke(D){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",D.statusMessage)}function He(D){const z=D.target;z.removeEventListener("dispose",He),Qe(z)}function Qe(D){ht(D),R.remove(D)}function ht(D){const z=R.get(D).programs;z!==void 0&&(z.forEach(function(k){$.releaseProgram(k)}),D.isShaderMaterial&&$.releaseShaderCache(D))}this.renderBufferDirect=function(D,z,k,ee,K,fe){z===null&&(z=me);const Ce=K.isMesh&&K.matrixWorld.determinant()<0,De=Kf(D,z,k,ee,K);I.setMaterial(ee,Ce);let Pe=k.index,Oe=1;if(ee.wireframe===!0){if(Pe=N.getWireframeAttribute(k),Pe===void 0)return;Oe=2}const qe=k.drawRange,Xe=k.attributes.position;let it=qe.start*Oe,rt=(qe.start+qe.count)*Oe;fe!==null&&(it=Math.max(it,fe.start*Oe),rt=Math.min(rt,(fe.start+fe.count)*Oe)),Pe!==null?(it=Math.max(it,0),rt=Math.min(rt,Pe.count)):Xe!=null&&(it=Math.max(it,0),rt=Math.min(rt,Xe.count));const st=rt-it;if(st<0||st===1/0)return;ae.setup(K,ee,De,k,Pe);let $e,at=Ge;if(Pe!==null&&($e=de.get(Pe),at=Ze,at.setIndex($e)),K.isMesh)ee.wireframe===!0?(I.setLineWidth(ee.wireframeLinewidth*V()),at.setMode(j.LINES)):at.setMode(j.TRIANGLES);else if(K.isLine){let lt=ee.linewidth;lt===void 0&&(lt=1),I.setLineWidth(lt*V()),K.isLineSegments?at.setMode(j.LINES):K.isLineLoop?at.setMode(j.LINE_LOOP):at.setMode(j.LINE_STRIP)}else K.isPoints?at.setMode(j.POINTS):K.isSprite&&at.setMode(j.TRIANGLES);if(K.isBatchedMesh)if(K._multiDrawInstances!==null)at.renderMultiDrawInstances(K._multiDrawStarts,K._multiDrawCounts,K._multiDrawCount,K._multiDrawInstances);else if(Re.get("WEBGL_multi_draw"))at.renderMultiDraw(K._multiDrawStarts,K._multiDrawCounts,K._multiDrawCount);else{const lt=K._multiDrawStarts,Je=K._multiDrawCounts,oi=K._multiDrawCount,ut=Pe?de.get(Pe).bytesPerElement:1,tn=R.get(ee).currentProgram.getUniforms();for(let Mt=0;Mt<oi;Mt++)tn.setValue(j,"_gl_DrawID",Mt),at.render(lt[Mt]/ut,Je[Mt])}else if(K.isInstancedMesh)at.renderInstances(it,st,K.count);else if(k.isInstancedBufferGeometry){const lt=k._maxInstanceCount!==void 0?k._maxInstanceCount:1/0,Je=Math.min(k.instanceCount,lt);at.renderInstances(it,st,Je)}else at.render(it,st)};function Pt(D,z,k){D.transparent===!0&&D.side===qi&&D.forceSinglePass===!1?(D.side=kn,D.needsUpdate=!0,Ds(D,z,k),D.side=Or,D.needsUpdate=!0,Ds(D,z,k),D.side=qi):Ds(D,z,k)}this.compile=function(D,z,k=null){k===null&&(k=D),v=ie.get(k),v.init(z),x.push(v),k.traverseVisible(function(K){K.isLight&&K.layers.test(z.layers)&&(v.pushLight(K),K.castShadow&&v.pushShadow(K))}),D!==k&&D.traverseVisible(function(K){K.isLight&&K.layers.test(z.layers)&&(v.pushLight(K),K.castShadow&&v.pushShadow(K))}),v.setupLights();const ee=new Set;return D.traverse(function(K){if(!(K.isMesh||K.isPoints||K.isLine||K.isSprite))return;const fe=K.material;if(fe)if(Array.isArray(fe))for(let Ce=0;Ce<fe.length;Ce++){const De=fe[Ce];Pt(De,k,K),ee.add(De)}else Pt(fe,k,K),ee.add(fe)}),x.pop(),v=null,ee},this.compileAsync=function(D,z,k=null){const ee=this.compile(D,z,k);return new Promise(K=>{function fe(){if(ee.forEach(function(Ce){R.get(Ce).currentProgram.isReady()&&ee.delete(Ce)}),ee.size===0){K(D);return}setTimeout(fe,10)}Re.get("KHR_parallel_shader_compile")!==null?fe():setTimeout(fe,10)})};let Oo=null;function qc(D){Oo&&Oo(D)}function zi(){Hi.stop()}function ko(){Hi.start()}const Hi=new cM;Hi.setAnimationLoop(qc),typeof self<"u"&&Hi.setContext(self),this.setAnimationLoop=function(D){Oo=D,ge.setAnimationLoop(D),D===null?Hi.stop():Hi.start()},ge.addEventListener("sessionstart",zi),ge.addEventListener("sessionend",ko),this.render=function(D,z){if(z!==void 0&&z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(w===!0)return;if(D.matrixWorldAutoUpdate===!0&&D.updateMatrixWorld(),z.parent===null&&z.matrixWorldAutoUpdate===!0&&z.updateMatrixWorld(),ge.enabled===!0&&ge.isPresenting===!0&&(ge.cameraAutoUpdate===!0&&ge.updateCamera(z),z=ge.getCamera()),D.isScene===!0&&D.onBeforeRender(M,D,z,y),v=ie.get(D,x.length),v.init(z),x.push(v),we.multiplyMatrices(z.projectionMatrix,z.matrixWorldInverse),Ee.setFromProjectionMatrix(we),pe=this.localClippingEnabled,Ue=Se.init(this.clippingPlanes,pe),p=ve.get(D,E.length),p.init(),E.push(p),ge.enabled===!0&&ge.isPresenting===!0){const fe=M.xr.getDepthSensingMesh();fe!==null&&Go(fe,z,-1/0,M.sortObjects)}Go(D,z,0,M.sortObjects),p.finish(),M.sortObjects===!0&&p.sort(ue,_e),Ae=ge.enabled===!1||ge.isPresenting===!1||ge.hasDepthSensing()===!1,Ae&&Fe.addToRenderList(p,D),this.info.render.frame++,Ue===!0&&Se.beginShadows();const k=v.state.shadowsArray;be.render(k,D,z),Ue===!0&&Se.endShadows(),this.info.autoReset===!0&&this.info.reset();const ee=p.opaque,K=p.transmissive;if(v.setupLights(),z.isArrayCamera){const fe=z.cameras;if(K.length>0)for(let Ce=0,De=fe.length;Ce<De;Ce++){const Pe=fe[Ce];cl(ee,K,D,Pe)}if(Ae&&Fe.render(D),ge.enabled&&ge.isMultiview)T.setDeferTextureUploads(!0),Qr(p,D,z,z.cameras[0].viewport);else for(let Ce=0,De=fe.length;Ce<De;Ce++){const Pe=fe[Ce];Qr(p,D,Pe,Pe.viewport)}}else K.length>0&&cl(ee,K,D,z),Ae&&Fe.render(D),Qr(p,D,z);y!==null&&B===0&&(T.updateMultisampleRenderTarget(y),T.updateRenderTargetMipmap(y)),D.isScene===!0&&D.onAfterRender(M,D,z),ae.resetDefaultState(),_=-1,L=null,x.pop(),x.length>0?(v=x[x.length-1],Ue===!0&&Se.setGlobalState(M.clippingPlanes,v.state.camera)):v=null,E.pop(),E.length>0?p=E[E.length-1]:p=null};function Go(D,z,k,ee){if(D.visible===!1)return;if(D.layers.test(z.layers)){if(D.isGroup)k=D.renderOrder;else if(D.isLOD)D.autoUpdate===!0&&D.update(z);else if(D.isLight)v.pushLight(D),D.castShadow&&v.pushShadow(D);else if(D.isSprite){if(!D.frustumCulled||Ee.intersectsSprite(D)){ee&&Ve.setFromMatrixPosition(D.matrixWorld).applyMatrix4(we);const Ce=P.update(D),De=D.material;De.visible&&p.push(D,Ce,De,k,Ve.z,null)}}else if((D.isMesh||D.isLine||D.isPoints)&&(!D.frustumCulled||Ee.intersectsObject(D))){const Ce=P.update(D),De=D.material;if(ee&&(D.boundingSphere!==void 0?(D.boundingSphere===null&&D.computeBoundingSphere(),Ve.copy(D.boundingSphere.center)):(Ce.boundingSphere===null&&Ce.computeBoundingSphere(),Ve.copy(Ce.boundingSphere.center)),Ve.applyMatrix4(D.matrixWorld).applyMatrix4(we)),Array.isArray(De)){const Pe=Ce.groups;for(let Oe=0,qe=Pe.length;Oe<qe;Oe++){const Xe=Pe[Oe],it=De[Xe.materialIndex];it&&it.visible&&p.push(D,Ce,it,k,Ve.z,Xe)}}else De.visible&&p.push(D,Ce,De,k,Ve.z,null)}}const fe=D.children;for(let Ce=0,De=fe.length;Ce<De;Ce++)Go(fe[Ce],z,k,ee)}function Qr(D,z,k,ee){const K=D.opaque,fe=D.transmissive,Ce=D.transparent;v.setupLightsView(k),Ue===!0&&Se.setGlobalState(M.clippingPlanes,k),ee&&I.viewport(Q.copy(ee)),K.length>0&&ir(K,z,k),fe.length>0&&ir(fe,z,k),Ce.length>0&&ir(Ce,z,k),I.buffers.depth.setTest(!0),I.buffers.depth.setMask(!0),I.buffers.color.setMask(!0),I.setPolygonOffset(!1)}function cl(D,z,k,ee){if((k.isScene===!0?k.overrideMaterial:null)!==null)return;v.state.transmissionRenderTarget[ee.id]===void 0&&(v.state.transmissionRenderTarget[ee.id]=new Ui(1,1,{generateMipmaps:!0,type:Re.has("EXT_color_buffer_half_float")||Re.has("EXT_color_buffer_float")?il:er,minFilter:Yi,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:wt.workingColorSpace}));const fe=v.state.transmissionRenderTarget[ee.id],Ce=ee.viewport||Q;fe.setSize(Ce.z*M.transmissionResolutionScale,Ce.w*M.transmissionResolutionScale);const De=M.getRenderTarget();M.setRenderTarget(fe),M.getClearColor(te),W=M.getClearAlpha(),W<1&&M.setClearColor(16777215,.5),M.clear(),Ae&&Fe.render(k);const Pe=M.toneMapping;M.toneMapping=Dr;const Oe=ee.viewport;if(ee.viewport!==void 0&&(ee.viewport=void 0),v.setupLightsView(ee),Ue===!0&&Se.setGlobalState(M.clippingPlanes,ee),ir(D,k,ee),T.updateMultisampleRenderTarget(fe),T.updateRenderTargetMipmap(fe),Re.has("WEBGL_multisampled_render_to_texture")===!1){let qe=!1;for(let Xe=0,it=z.length;Xe<it;Xe++){const rt=z[Xe],st=rt.object,$e=rt.geometry,at=rt.material,lt=rt.group;if(at.side===qi&&st.layers.test(ee.layers)){const Je=at.side;at.side=kn,at.needsUpdate=!0,hl(st,k,ee,$e,at,lt),at.side=Je,at.needsUpdate=!0,qe=!0}}qe===!0&&(T.updateMultisampleRenderTarget(fe),T.updateRenderTargetMipmap(fe))}M.setRenderTarget(De),M.setClearColor(te,W),Oe!==void 0&&(ee.viewport=Oe),M.toneMapping=Pe}function ir(D,z,k){const ee=z.isScene===!0?z.overrideMaterial:null;for(let K=0,fe=D.length;K<fe;K++){const Ce=D[K],De=Ce.object,Pe=Ce.geometry,Oe=ee===null?Ce.material:ee,qe=Ce.group;De.layers.test(k.layers)&&hl(De,z,k,Pe,Oe,qe)}}function hl(D,z,k,ee,K,fe){D.onBeforeRender(M,z,k,ee,K,fe),D.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,D.matrixWorld),D.normalMatrix.getNormalMatrix(D.modelViewMatrix),K.onBeforeRender(M,z,k,ee,D,fe),K.transparent===!0&&K.side===qi&&K.forceSinglePass===!1?(K.side=kn,K.needsUpdate=!0,M.renderBufferDirect(k,z,ee,K,D,fe),K.side=Or,K.needsUpdate=!0,M.renderBufferDirect(k,z,ee,K,D,fe),K.side=qi):M.renderBufferDirect(k,z,ee,K,D,fe),D.onAfterRender(M,z,k,ee,K,fe)}function Ds(D,z,k){z.isScene!==!0&&(z=me);const ee=R.get(D),K=v.state.lights,fe=v.state.shadowsArray,Ce=K.state.version,De=$.getParameters(D,K.state,fe,z,k),Pe=$.getProgramCacheKey(De);let Oe=ee.programs;ee.environment=D.isMeshStandardMaterial?z.environment:null,ee.fog=z.fog,ee.envMap=(D.isMeshStandardMaterial?J:G).get(D.envMap||ee.environment),ee.envMapRotation=ee.environment!==null&&D.envMap===null?z.environmentRotation:D.envMapRotation,Oe===void 0&&(D.addEventListener("dispose",He),Oe=new Map,ee.programs=Oe);let qe=Oe.get(Pe);if(qe!==void 0){if(ee.currentProgram===qe&&ee.lightsStateVersion===Ce)return jc(D,De),qe}else De.uniforms=$.getUniforms(D),D.onBeforeCompile(De,M),qe=$.acquireProgram(De,Pe),Oe.set(Pe,qe),ee.uniforms=De.uniforms;const Xe=ee.uniforms;return(!D.isShaderMaterial&&!D.isRawShaderMaterial||D.clipping===!0)&&(Xe.clippingPlanes=Se.uniform),jc(D,De),ee.needsLights=Zf(D),ee.lightsStateVersion=Ce,ee.needsLights&&(Xe.ambientLightColor.value=K.state.ambient,Xe.lightProbe.value=K.state.probe,Xe.directionalLights.value=K.state.directional,Xe.directionalLightShadows.value=K.state.directionalShadow,Xe.spotLights.value=K.state.spot,Xe.spotLightShadows.value=K.state.spotShadow,Xe.rectAreaLights.value=K.state.rectArea,Xe.ltc_1.value=K.state.rectAreaLTC1,Xe.ltc_2.value=K.state.rectAreaLTC2,Xe.pointLights.value=K.state.point,Xe.pointLightShadows.value=K.state.pointShadow,Xe.hemisphereLights.value=K.state.hemi,Xe.directionalShadowMap.value=K.state.directionalShadowMap,Xe.directionalShadowMatrix.value=K.state.directionalShadowMatrix,Xe.spotShadowMap.value=K.state.spotShadowMap,Xe.spotLightMatrix.value=K.state.spotLightMatrix,Xe.spotLightMap.value=K.state.spotLightMap,Xe.pointShadowMap.value=K.state.pointShadowMap,Xe.pointShadowMatrix.value=K.state.pointShadowMatrix),ee.currentProgram=qe,ee.uniformsList=null,qe}function Yc(D){if(D.uniformsList===null){const z=D.currentProgram.getUniforms();D.uniformsList=ku.seqWithValue(z.seq,D.uniforms)}return D.uniformsList}function jc(D,z){const k=R.get(D);k.outputColorSpace=z.outputColorSpace,k.batching=z.batching,k.batchingColor=z.batchingColor,k.instancing=z.instancing,k.instancingColor=z.instancingColor,k.instancingMorph=z.instancingMorph,k.skinning=z.skinning,k.morphTargets=z.morphTargets,k.morphNormals=z.morphNormals,k.morphColors=z.morphColors,k.morphTargetsCount=z.morphTargetsCount,k.numClippingPlanes=z.numClippingPlanes,k.numIntersection=z.numClipIntersection,k.vertexAlphas=z.vertexAlphas,k.vertexTangents=z.vertexTangents,k.toneMapping=z.toneMapping,k.numMultiviewViews=z.numMultiviewViews}function Kf(D,z,k,ee,K){z.isScene!==!0&&(z=me),T.resetTextureUnits();const fe=z.fog,Ce=ee.isMeshStandardMaterial?z.environment:null,De=y===null?M.outputColorSpace:y.isXRRenderTarget===!0?y.texture.colorSpace:Io,Pe=(ee.isMeshStandardMaterial?J:G).get(ee.envMap||Ce),Oe=ee.vertexColors===!0&&!!k.attributes.color&&k.attributes.color.itemSize===4,qe=!!k.attributes.tangent&&(!!ee.normalMap||ee.anisotropy>0),Xe=!!k.morphAttributes.position,it=!!k.morphAttributes.normal,rt=!!k.morphAttributes.color;let st=Dr;ee.toneMapped&&(y===null||y.isXRRenderTarget===!0)&&(st=M.toneMapping);const $e=y&&y.isWebGLMultiviewRenderTarget?y.numViews:0,at=k.morphAttributes.position||k.morphAttributes.normal||k.morphAttributes.color,lt=at!==void 0?at.length:0,Je=R.get(ee),oi=v.state.lights;if(Ue===!0&&(pe===!0||D!==L)){const Nt=D===L&&ee.id===_;Se.setState(ee,D,Nt)}let ut=!1;ee.version===Je.__version?(Je.needsLights&&Je.lightsStateVersion!==oi.state.version||Je.outputColorSpace!==De||K.isBatchedMesh&&Je.batching===!1||!K.isBatchedMesh&&Je.batching===!0||K.isBatchedMesh&&Je.batchingColor===!0&&K.colorTexture===null||K.isBatchedMesh&&Je.batchingColor===!1&&K.colorTexture!==null||K.isInstancedMesh&&Je.instancing===!1||!K.isInstancedMesh&&Je.instancing===!0||K.isSkinnedMesh&&Je.skinning===!1||!K.isSkinnedMesh&&Je.skinning===!0||K.isInstancedMesh&&Je.instancingColor===!0&&K.instanceColor===null||K.isInstancedMesh&&Je.instancingColor===!1&&K.instanceColor!==null||K.isInstancedMesh&&Je.instancingMorph===!0&&K.morphTexture===null||K.isInstancedMesh&&Je.instancingMorph===!1&&K.morphTexture!==null||Je.envMap!==Pe||ee.fog===!0&&Je.fog!==fe||Je.numClippingPlanes!==void 0&&(Je.numClippingPlanes!==Se.numPlanes||Je.numIntersection!==Se.numIntersection)||Je.vertexAlphas!==Oe||Je.vertexTangents!==qe||Je.morphTargets!==Xe||Je.morphNormals!==it||Je.morphColors!==rt||Je.toneMapping!==st||Je.morphTargetsCount!==lt||Je.numMultiviewViews!==$e)&&(ut=!0):(ut=!0,Je.__version=ee.version);let tn=Je.currentProgram;ut===!0&&(tn=Ds(ee,z,K));let Mt=!1,Kt=!1,nn=!1;const ft=tn.getUniforms(),It=Je.uniforms;if(I.useProgram(tn.program)&&(Mt=!0,Kt=!0,nn=!0),ee.id!==_&&(_=ee.id,Kt=!0),Mt||L!==D){tn.numMultiviewViews>0?(Ie.updateCameraProjectionMatricesUniform(D,ft),Ie.updateCameraViewMatricesUniform(D,ft)):(I.buffers.depth.getReversed()?(oe.copy(D.projectionMatrix),x1(oe),y1(oe),ft.setValue(j,"projectionMatrix",oe)):ft.setValue(j,"projectionMatrix",D.projectionMatrix),ft.setValue(j,"viewMatrix",D.matrixWorldInverse));const Nt=ft.map.cameraPosition;Nt!==void 0&&Nt.setValue(j,Me.setFromMatrixPosition(D.matrixWorld)),b.logarithmicDepthBuffer&&ft.setValue(j,"logDepthBufFC",2/(Math.log(D.far+1)/Math.LN2)),(ee.isMeshPhongMaterial||ee.isMeshToonMaterial||ee.isMeshLambertMaterial||ee.isMeshBasicMaterial||ee.isMeshStandardMaterial||ee.isShaderMaterial)&&ft.setValue(j,"isOrthographic",D.isOrthographicCamera===!0),L!==D&&(L=D,Kt=!0,nn=!0)}if(K.isSkinnedMesh){ft.setOptional(j,K,"bindMatrix"),ft.setOptional(j,K,"bindMatrixInverse");const Nt=K.skeleton;Nt&&(Nt.boneTexture===null&&Nt.computeBoneTexture(),ft.setValue(j,"boneTexture",Nt.boneTexture,T))}K.isBatchedMesh&&(ft.setOptional(j,K,"batchingTexture"),ft.setValue(j,"batchingTexture",K._matricesTexture,T),ft.setOptional(j,K,"batchingIdTexture"),ft.setValue(j,"batchingIdTexture",K._indirectTexture,T),ft.setOptional(j,K,"batchingColorTexture"),K._colorsTexture!==null&&ft.setValue(j,"batchingColorTexture",K._colorsTexture,T));const ai=k.morphAttributes;if((ai.position!==void 0||ai.normal!==void 0||ai.color!==void 0)&&Le.update(K,k,tn),(Kt||Je.receiveShadow!==K.receiveShadow)&&(Je.receiveShadow=K.receiveShadow,ft.setValue(j,"receiveShadow",K.receiveShadow)),ee.isMeshGouraudMaterial&&ee.envMap!==null&&(It.envMap.value=Pe,It.flipEnvMap.value=Pe.isCubeTexture&&Pe.isRenderTargetTexture===!1?-1:1),ee.isMeshStandardMaterial&&ee.envMap===null&&z.environment!==null&&(It.envMapIntensity.value=z.environmentIntensity),Kt&&(ft.setValue(j,"toneMappingExposure",M.toneMappingExposure),Je.needsLights&&Jf(It,nn),fe&&ee.fog===!0&&se.refreshFogUniforms(It,fe),se.refreshMaterialUniforms(It,ee,re,q,v.state.transmissionRenderTarget[D.id]),ku.upload(j,Yc(Je),It,T)),ee.isShaderMaterial&&ee.uniformsNeedUpdate===!0&&(ku.upload(j,Yc(Je),It,T),ee.uniformsNeedUpdate=!1),ee.isSpriteMaterial&&ft.setValue(j,"center",K.center),tn.numMultiviewViews>0?Ie.updateObjectMatricesUniforms(K,D,ft):(ft.setValue(j,"modelViewMatrix",K.modelViewMatrix),ft.setValue(j,"normalMatrix",K.normalMatrix)),ft.setValue(j,"modelMatrix",K.matrixWorld),ee.isShaderMaterial||ee.isRawShaderMaterial){const Nt=ee.uniformsGroups;for(let zo=0,Ho=Nt.length;zo<Ho;zo++){const Cv=Nt[zo];ne.update(Cv,tn),ne.bind(Cv,tn)}}return tn}function Jf(D,z){D.ambientLightColor.needsUpdate=z,D.lightProbe.needsUpdate=z,D.directionalLights.needsUpdate=z,D.directionalLightShadows.needsUpdate=z,D.pointLights.needsUpdate=z,D.pointLightShadows.needsUpdate=z,D.spotLights.needsUpdate=z,D.spotLightShadows.needsUpdate=z,D.rectAreaLights.needsUpdate=z,D.hemisphereLights.needsUpdate=z}function Zf(D){return D.isMeshLambertMaterial||D.isMeshToonMaterial||D.isMeshPhongMaterial||D.isMeshStandardMaterial||D.isShadowMaterial||D.isShaderMaterial&&D.lights===!0}this.setTexture2D=function(){var D=!1;return function(k,ee){k&&k.isWebGLRenderTarget&&(D||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),D=!0),k=k.texture),T.setTexture2D(k,ee)}}(),this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return B},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(D,z,k){R.get(D.texture).__webglTexture=z,R.get(D.depthTexture).__webglTexture=k;const ee=R.get(D);ee.__hasExternalTextures=!0,ee.__autoAllocateDepthBuffer=k===void 0,!ee.__autoAllocateDepthBuffer&&(!y||!y.isWebGLMultiviewRenderTarget)&&Re.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ee.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(D,z){const k=R.get(D);k.__webglFramebuffer=z,k.__useDefaultFramebuffer=z===void 0};const ep=j.createFramebuffer();this.setRenderTarget=function(D,z=0,k=0){D===null&&this.xr.isPresenting&&(D=this.xr.getRenderTarget()),y=D,S=z,B=k;let ee=!0,K=null,fe=!1,Ce=!1;if(D){const Pe=R.get(D);if(Pe.__useDefaultFramebuffer!==void 0)I.bindFramebuffer(j.FRAMEBUFFER,null),ee=!1;else if(Pe.__webglFramebuffer===void 0)T.setupRenderTarget(D);else if(Pe.__hasExternalTextures)T.rebindTextures(D,R.get(D.texture).__webglTexture,R.get(D.depthTexture).__webglTexture);else if(D.depthBuffer){const Xe=D.depthTexture;if(Pe.__boundDepthTexture!==Xe){if(Xe!==null&&R.has(Xe)&&(D.width!==Xe.image.width||D.height!==Xe.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");T.setupDepthRenderbuffer(D)}}const Oe=D.texture;(Oe.isData3DTexture||Oe.isDataArrayTexture||Oe.isCompressedArrayTexture)&&(Ce=!0);const qe=R.get(D).__webglFramebuffer;D.isWebGLCubeRenderTarget?(Array.isArray(qe[z])?K=qe[z][k]:K=qe[z],fe=!0):D.samples>0&&T.useMultisampledRTT(D)===!1?K=R.get(D).__webglMultisampledFramebuffer:Array.isArray(qe)?K=qe[k]:K=qe,Q.copy(D.viewport),O.copy(D.scissor),X=D.scissorTest}else Q.copy(Be).multiplyScalar(re).floor(),O.copy(ze).multiplyScalar(re).floor(),X=le;if(k!==0&&(K=ep),I.bindFramebuffer(j.FRAMEBUFFER,K)&&ee&&I.drawBuffers(D,K),I.viewport(Q),I.scissor(O),I.setScissorTest(X),fe){const Pe=R.get(D.texture);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_CUBE_MAP_POSITIVE_X+z,Pe.__webglTexture,k)}else if(Ce){const Pe=R.get(D.texture),Oe=z;j.framebufferTextureLayer(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,Pe.__webglTexture,k,Oe)}else if(D!==null&&k!==0){const Pe=R.get(D.texture);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,Pe.__webglTexture,k)}_=-1},this.readRenderTargetPixels=function(D,z,k,ee,K,fe,Ce){if(!(D&&D.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let De=R.get(D).__webglFramebuffer;if(D.isWebGLCubeRenderTarget&&Ce!==void 0&&(De=De[Ce]),De){I.bindFramebuffer(j.FRAMEBUFFER,De);try{const Pe=D.texture,Oe=Pe.format,qe=Pe.type;if(!b.textureFormatReadable(Oe)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!b.textureTypeReadable(qe)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}z>=0&&z<=D.width-ee&&k>=0&&k<=D.height-K&&j.readPixels(z,k,ee,K,F.convert(Oe),F.convert(qe),fe)}finally{const Pe=y!==null?R.get(y).__webglFramebuffer:null;I.bindFramebuffer(j.FRAMEBUFFER,Pe)}}},this.readRenderTargetPixelsAsync=async function(D,z,k,ee,K,fe,Ce){if(!(D&&D.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let De=R.get(D).__webglFramebuffer;if(D.isWebGLCubeRenderTarget&&Ce!==void 0&&(De=De[Ce]),De){const Pe=D.texture,Oe=Pe.format,qe=Pe.type;if(!b.textureFormatReadable(Oe))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!b.textureTypeReadable(qe))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(z>=0&&z<=D.width-ee&&k>=0&&k<=D.height-K){I.bindFramebuffer(j.FRAMEBUFFER,De);const Xe=j.createBuffer();j.bindBuffer(j.PIXEL_PACK_BUFFER,Xe),j.bufferData(j.PIXEL_PACK_BUFFER,fe.byteLength,j.STREAM_READ),j.readPixels(z,k,ee,K,F.convert(Oe),F.convert(qe),0);const it=y!==null?R.get(y).__webglFramebuffer:null;I.bindFramebuffer(j.FRAMEBUFFER,it);const rt=j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE,0);return j.flush(),await E1(j,rt,4),j.bindBuffer(j.PIXEL_PACK_BUFFER,Xe),j.getBufferSubData(j.PIXEL_PACK_BUFFER,0,fe),j.deleteBuffer(Xe),j.deleteSync(rt),fe}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(D,z=null,k=0){D.isTexture!==!0&&(Ta("WebGLRenderer: copyFramebufferToTexture function signature has changed."),z=arguments[0]||null,D=arguments[1]);const ee=Math.pow(2,-k),K=Math.floor(D.image.width*ee),fe=Math.floor(D.image.height*ee),Ce=z!==null?z.x:0,De=z!==null?z.y:0;T.setTexture2D(D,0),j.copyTexSubImage2D(j.TEXTURE_2D,k,0,0,Ce,De,K,fe),I.unbindTexture()};const H=j.createFramebuffer(),he=j.createFramebuffer();this.copyTextureToTexture=function(D,z,k=null,ee=null,K=0,fe=null){D.isTexture!==!0&&(Ta("WebGLRenderer: copyTextureToTexture function signature has changed."),ee=arguments[0]||null,D=arguments[1],z=arguments[2],fe=arguments[3]||0,k=null),fe===null&&(K!==0?(Ta("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),fe=K,K=0):fe=0);let Ce,De,Pe,Oe,qe,Xe,it,rt,st;const $e=D.isCompressedTexture?D.mipmaps[fe]:D.image;if(k!==null)Ce=k.max.x-k.min.x,De=k.max.y-k.min.y,Pe=k.isBox3?k.max.z-k.min.z:1,Oe=k.min.x,qe=k.min.y,Xe=k.isBox3?k.min.z:0;else{const It=Math.pow(2,-K);Ce=Math.floor($e.width*It),De=Math.floor($e.height*It),D.isDataArrayTexture?Pe=$e.depth:D.isData3DTexture?Pe=Math.floor($e.depth*It):Pe=1,Oe=0,qe=0,Xe=0}ee!==null?(it=ee.x,rt=ee.y,st=ee.z):(it=0,rt=0,st=0);const at=F.convert(z.format),lt=F.convert(z.type);let Je;z.isData3DTexture?(T.setTexture3D(z,0),Je=j.TEXTURE_3D):z.isDataArrayTexture||z.isCompressedArrayTexture?(T.setTexture2DArray(z,0),Je=j.TEXTURE_2D_ARRAY):(T.setTexture2D(z,0),Je=j.TEXTURE_2D),j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,z.flipY),j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL,z.premultiplyAlpha),j.pixelStorei(j.UNPACK_ALIGNMENT,z.unpackAlignment);const oi=j.getParameter(j.UNPACK_ROW_LENGTH),ut=j.getParameter(j.UNPACK_IMAGE_HEIGHT),tn=j.getParameter(j.UNPACK_SKIP_PIXELS),Mt=j.getParameter(j.UNPACK_SKIP_ROWS),Kt=j.getParameter(j.UNPACK_SKIP_IMAGES);j.pixelStorei(j.UNPACK_ROW_LENGTH,$e.width),j.pixelStorei(j.UNPACK_IMAGE_HEIGHT,$e.height),j.pixelStorei(j.UNPACK_SKIP_PIXELS,Oe),j.pixelStorei(j.UNPACK_SKIP_ROWS,qe),j.pixelStorei(j.UNPACK_SKIP_IMAGES,Xe);const nn=D.isDataArrayTexture||D.isData3DTexture,ft=z.isDataArrayTexture||z.isData3DTexture;if(D.isDepthTexture){const It=R.get(D),ai=R.get(z),Nt=R.get(It.__renderTarget),zo=R.get(ai.__renderTarget);I.bindFramebuffer(j.READ_FRAMEBUFFER,Nt.__webglFramebuffer),I.bindFramebuffer(j.DRAW_FRAMEBUFFER,zo.__webglFramebuffer);for(let Ho=0;Ho<Pe;Ho++)nn&&(j.framebufferTextureLayer(j.READ_FRAMEBUFFER,j.COLOR_ATTACHMENT0,R.get(D).__webglTexture,K,Xe+Ho),j.framebufferTextureLayer(j.DRAW_FRAMEBUFFER,j.COLOR_ATTACHMENT0,R.get(z).__webglTexture,fe,st+Ho)),j.blitFramebuffer(Oe,qe,Ce,De,it,rt,Ce,De,j.DEPTH_BUFFER_BIT,j.NEAREST);I.bindFramebuffer(j.READ_FRAMEBUFFER,null),I.bindFramebuffer(j.DRAW_FRAMEBUFFER,null)}else if(K!==0||D.isRenderTargetTexture||R.has(D)){const It=R.get(D),ai=R.get(z);I.bindFramebuffer(j.READ_FRAMEBUFFER,H),I.bindFramebuffer(j.DRAW_FRAMEBUFFER,he);for(let Nt=0;Nt<Pe;Nt++)nn?j.framebufferTextureLayer(j.READ_FRAMEBUFFER,j.COLOR_ATTACHMENT0,It.__webglTexture,K,Xe+Nt):j.framebufferTexture2D(j.READ_FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,It.__webglTexture,K),ft?j.framebufferTextureLayer(j.DRAW_FRAMEBUFFER,j.COLOR_ATTACHMENT0,ai.__webglTexture,fe,st+Nt):j.framebufferTexture2D(j.DRAW_FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,ai.__webglTexture,fe),K!==0?j.blitFramebuffer(Oe,qe,Ce,De,it,rt,Ce,De,j.COLOR_BUFFER_BIT,j.NEAREST):ft?j.copyTexSubImage3D(Je,fe,it,rt,st+Nt,Oe,qe,Ce,De):j.copyTexSubImage2D(Je,fe,it,rt,Oe,qe,Ce,De);I.bindFramebuffer(j.READ_FRAMEBUFFER,null),I.bindFramebuffer(j.DRAW_FRAMEBUFFER,null)}else ft?D.isDataTexture||D.isData3DTexture?j.texSubImage3D(Je,fe,it,rt,st,Ce,De,Pe,at,lt,$e.data):z.isCompressedArrayTexture?j.compressedTexSubImage3D(Je,fe,it,rt,st,Ce,De,Pe,at,$e.data):j.texSubImage3D(Je,fe,it,rt,st,Ce,De,Pe,at,lt,$e):D.isDataTexture?j.texSubImage2D(j.TEXTURE_2D,fe,it,rt,Ce,De,at,lt,$e.data):D.isCompressedTexture?j.compressedTexSubImage2D(j.TEXTURE_2D,fe,it,rt,$e.width,$e.height,at,$e.data):j.texSubImage2D(j.TEXTURE_2D,fe,it,rt,Ce,De,at,lt,$e);j.pixelStorei(j.UNPACK_ROW_LENGTH,oi),j.pixelStorei(j.UNPACK_IMAGE_HEIGHT,ut),j.pixelStorei(j.UNPACK_SKIP_PIXELS,tn),j.pixelStorei(j.UNPACK_SKIP_ROWS,Mt),j.pixelStorei(j.UNPACK_SKIP_IMAGES,Kt),fe===0&&z.generateMipmaps&&j.generateMipmap(Je),I.unbindTexture()},this.copyTextureToTexture3D=function(D,z,k=null,ee=null,K=0){return D.isTexture!==!0&&(Ta("WebGLRenderer: copyTextureToTexture3D function signature has changed."),k=arguments[0]||null,ee=arguments[1]||null,D=arguments[2],z=arguments[3],K=arguments[4]||0),Ta('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(D,z,k,ee,K)},this.initRenderTarget=function(D){R.get(D).__webglFramebuffer===void 0&&T.setupRenderTarget(D)},this.initTexture=function(D){D.isCubeTexture?T.setTextureCube(D,0):D.isData3DTexture?T.setTexture3D(D,0):D.isDataArrayTexture||D.isCompressedArrayTexture?T.setTexture2DArray(D,0):T.setTexture2D(D,0),I.unbindTexture()},this.resetState=function(){S=0,B=0,y=null,I.reset(),ae.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Li}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorspace=wt._getDrawingBufferColorSpace(e),t.unpackColorSpace=wt._getUnpackColorSpace()}};const PD=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:Lb,AddEquation:ds,AddOperation:Tb,AdditiveAnimationBlendMode:r0,AdditiveBlending:fA,AgXToneMapping:Pb,AlphaFormat:Jg,AlwaysCompare:jb,AlwaysDepth:id,AlwaysStencilFunc:gA,AmbientLight:KC,AnimationAction:aM,AnimationClip:Ec,AnimationLoader:WT,AnimationMixer:x2,AnimationObjectGroup:v2,AnimationUtils:zT,ArcCurve:yC,ArrayCamera:iM,ArrowHelper:Q2,AttachedBindMode:AA,Audio:sM,AudioAnalyser:l2,AudioContext:w0,AudioListener:s2,AudioLoader:n2,AxesHelper:W2,BackSide:kn,BasicDepthPacking:Gb,BasicShadowMap:xw,BatchedMesh:gC,Bone:h0,BooleanKeyframeTrack:Po,Box2:R2,Box3:Gn,Box3Helper:H2,BoxGeometry:Pc,BoxHelper:z2,BufferAttribute:Gt,BufferGeometry:yt,BufferGeometryLoader:nM,ByteType:jg,Cache:Mr,Camera:gf,CameraHelper:G2,CanvasTexture:uT,CapsuleGeometry:Cf,CatmullRomCurve3:_C,CineonToneMapping:Bb,CircleGeometry:Mf,ClampToEdgeWrapping:mi,Clock:rM,Color:Ke,ColorKeyframeTrack:C0,ColorManagement:wt,CompressedArrayTexture:cT,CompressedCubeTexture:hT,CompressedTexture:_f,CompressedTextureLoader:XT,ConeGeometry:Sf,ConstantAlphaFactor:Mb,ConstantColorFactor:bb,Controls:q2,CubeCamera:cC,CubeReflectionMapping:kr,CubeRefractionMapping:bs,CubeTexture:Uc,CubeTextureLoader:qT,CubeUVReflectionMapping:nl,CubicBezierCurve:p0,CubicBezierCurve3:bC,CubicInterpolant:VC,CullFaceBack:dA,CullFaceFront:ab,CullFaceFrontBack:Ew,CullFaceNone:ob,Curve:ki,CurvePath:MC,CustomBlending:cb,CustomToneMapping:Db,CylinderGeometry:sl,Cylindrical:I2,Data3DTexture:mf,DataArrayTexture:Dc,DataTexture:Ki,DataTextureLoader:YT,DataUtils:F1,DecrementStencilOp:Pw,DecrementWrapStencilOp:Fw,DefaultLoadingManager:XC,DepthFormat:Es,DepthStencilFormat:xs,DepthTexture:d0,DetachedBindMode:Fb,DirectionalLight:$C,DirectionalLightHelper:k2,DiscreteInterpolant:QC,DodecahedronGeometry:wf,DoubleSide:qi,DstAlphaFactor:vb,DstColorFactor:xb,DynamicCopyUsage:Kw,DynamicDrawUsage:Ww,DynamicReadUsage:Yw,EdgesGeometry:SC,EllipseCurve:bf,EqualCompare:Wb,EqualDepth:sd,EqualStencilFunc:Gw,EquirectangularReflectionMapping:ic,EquirectangularRefractionMapping:rc,Euler:Fi,EventDispatcher:tr,ExtrudeGeometry:If,FileLoader:zr,Float16BufferAttribute:V1,Float32BufferAttribute:et,FloatType:Un,Fog:Ef,FogExp2:vf,FramebufferTexture:lT,FrontSide:Or,Frustum:Fc,GLBufferAttribute:S2,GLSL1:Zw,GLSL3:vA,GreaterCompare:Xb,GreaterDepth:ad,GreaterEqualCompare:Yb,GreaterEqualDepth:od,GreaterEqualStencilFunc:Qw,GreaterStencilFunc:Hw,GridHelper:N2,Group:Pa,HalfFloatType:il,HemisphereLight:qC,HemisphereLightHelper:F2,IcosahedronGeometry:Rf,ImageBitmapLoader:t2,ImageLoader:xc,ImageUtils:eC,IncrementStencilOp:Dw,IncrementWrapStencilOp:Uw,InstancedBufferAttribute:ja,InstancedBufferGeometry:tM,InstancedInterleavedBuffer:M2,InstancedMesh:AC,Int16BufferAttribute:z1,Int32BufferAttribute:H1,Int8BufferAttribute:O1,IntType:af,InterleavedBuffer:xf,InterleavedBufferAttribute:Ro,Interpolant:Gc,InterpolateDiscrete:ac,InterpolateLinear:Ud,InterpolateSmooth:Uu,InvertStencilOp:Nw,KeepStencilOp:lo,KeyframeTrack:Gi,LOD:pC,LatheGeometry:Nc,Layers:Af,LessCompare:Qb,LessDepth:rd,LessEqualCompare:s0,LessEqualDepth:To,LessEqualStencilFunc:zw,LessStencilFunc:kw,Light:Ls,LightProbe:eM,Line:Cs,Line3:B2,LineBasicMaterial:Hn,LineCurve:m0,LineCurve3:CC,LineDashedMaterial:GC,LineLoop:vC,LineSegments:nr,LinearFilter:ln,LinearInterpolant:b0,LinearMipMapLinearFilter:Cw,LinearMipMapNearestFilter:bw,LinearMipmapLinearFilter:Yi,LinearMipmapNearestFilter:Ql,LinearSRGBColorSpace:Io,LinearToneMapping:Ib,LinearTransfer:cc,Loader:$n,LoaderUtils:CA,LoadingManager:M0,LoopOnce:Nb,LoopPingPong:kb,LoopRepeat:Ob,LuminanceAlphaFormat:t0,LuminanceFormat:e0,MOUSE:gw,Material:Tn,MaterialLoader:kf,MathUtils:g1,Matrix2:B0,Matrix3:At,Matrix4:ct,MaxEquation:fb,Mesh:en,MeshBasicMaterial:Rs,MeshDepthMaterial:x0,MeshDistanceMaterial:y0,MeshLambertMaterial:OC,MeshMatcapMaterial:kC,MeshNormalMaterial:NC,MeshPhongMaterial:UC,MeshPhysicalMaterial:PC,MeshStandardMaterial:E0,MeshToonMaterial:FC,MinEquation:db,MirroredRepeatWrapping:oc,MixOperation:wb,MultiplyBlending:mA,MultiplyOperation:Bc,NearestFilter:xn,NearestMipMapLinearFilter:_w,NearestMipMapNearestFilter:yw,NearestMipmapLinearFilter:La,NearestMipmapNearestFilter:Yg,NeutralToneMapping:Ub,NeverCompare:Vb,NeverDepth:nd,NeverStencilFunc:Ow,NoBlending:Lr,NoColorSpace:xr,NoToneMapping:Dr,NormalAnimationBlendMode:ff,NormalBlending:bo,NotEqualCompare:qb,NotEqualDepth:ld,NotEqualStencilFunc:Vw,NumberKeyframeTrack:gc,Object3D:Ft,ObjectLoader:ZT,ObjectSpaceNormalMap:Hb,OctahedronGeometry:Oc,OneFactor:mb,OneMinusConstantAlphaFactor:Sb,OneMinusConstantColorFactor:Cb,OneMinusDstAlphaFactor:Eb,OneMinusDstColorFactor:yb,OneMinusSrcAlphaFactor:td,OneMinusSrcColorFactor:gb,OrthographicCamera:Of,PCFShadowMap:qg,PCFSoftShadowMap:lb,PMREMGenerator:wA,Path:fc,PerspectiveCamera:gn,Plane:cs,PlaneGeometry:Bf,PlaneHelper:V2,PointLight:jC,PointLightHelper:P2,Points:EC,PointsMaterial:u0,PolarGridHelper:O2,PolyhedronGeometry:Bs,PositionalAudio:a2,PropertyBinding:Tt,PropertyMixer:oM,QuadraticBezierCurve:A0,QuadraticBezierCurve3:g0,Quaternion:Yn,QuaternionKeyframeTrack:zc,QuaternionLinearInterpolant:WC,RED_GREEN_RGTC2_Format:Dd,RED_RGTC1_Format:i0,REVISION:sf,RGBADepthPacking:zb,RGBAFormat:On,RGBAIntegerFormat:df,RGBA_ASTC_10x10_Format:wd,RGBA_ASTC_10x5_Format:Cd,RGBA_ASTC_10x6_Format:Md,RGBA_ASTC_10x8_Format:Sd,RGBA_ASTC_12x10_Format:Td,RGBA_ASTC_12x12_Format:Id,RGBA_ASTC_4x4_Format:Ad,RGBA_ASTC_5x4_Format:gd,RGBA_ASTC_5x5_Format:vd,RGBA_ASTC_6x5_Format:Ed,RGBA_ASTC_6x6_Format:xd,RGBA_ASTC_8x5_Format:yd,RGBA_ASTC_8x6_Format:_d,RGBA_ASTC_8x8_Format:bd,RGBA_BPTC_Format:jl,RGBA_ETC2_EAC_Format:md,RGBA_PVRTC_2BPPV1_Format:dd,RGBA_PVRTC_4BPPV1_Format:ud,RGBA_S3TC_DXT1_Format:Xl,RGBA_S3TC_DXT3_Format:ql,RGBA_S3TC_DXT5_Format:Yl,RGBDepthPacking:Iw,RGBFormat:Zg,RGBIntegerFormat:Mw,RGB_BPTC_SIGNED_Format:Rd,RGB_BPTC_UNSIGNED_Format:Bd,RGB_ETC1_Format:fd,RGB_ETC2_Format:pd,RGB_PVRTC_2BPPV1_Format:hd,RGB_PVRTC_4BPPV1_Format:cd,RGB_S3TC_DXT1_Format:Wl,RGDepthPacking:Rw,RGFormat:n0,RGIntegerFormat:uf,RawShaderMaterial:DC,Ray:rl,Raycaster:w2,RectAreaLight:JC,RedFormat:hf,RedIntegerFormat:Lc,ReinhardToneMapping:Rb,RenderTarget:pf,RenderTarget3D:y2,RenderTargetArray:_2,RepeatWrapping:sc,ReplaceStencilOp:Lw,ReverseSubtractEquation:ub,RingGeometry:Lf,SIGNED_RED_GREEN_RGTC2_Format:Pd,SIGNED_RED_RGTC1_Format:Ld,SRGBColorSpace:Xn,SRGBTransfer:Ut,Scene:uC,ShaderChunk:vt,ShaderLib:Ti,ShaderMaterial:Ni,ShadowMaterial:LC,Shape:Mo,ShapeGeometry:Df,ShapePath:X2,ShapeUtils:Ji,ShortType:$g,Skeleton:yf,SkeletonHelper:D2,SkinnedMesh:mC,Source:Eo,Sphere:wn,SphereGeometry:kc,Spherical:T2,SphericalHarmonics3:ZC,SplineCurve:v0,SpotLight:YC,SpotLightHelper:L2,Sprite:fC,SpriteMaterial:c0,SrcAlphaFactor:ed,SrcAlphaSaturateFactor:_b,SrcColorFactor:Ab,StaticCopyUsage:$w,StaticDrawUsage:hc,StaticReadUsage:qw,StereoCamera:i2,StreamCopyUsage:Jw,StreamDrawUsage:Xw,StreamReadUsage:jw,StringKeyframeTrack:Uo,SubtractEquation:hb,SubtractiveBlending:pA,TOUCH:vw,TangentSpaceNormalMap:Is,TetrahedronGeometry:Pf,Texture:mn,TextureLoader:jT,TextureUtils:J2,TimestampQuery:e1,TorusGeometry:Uf,TorusKnotGeometry:Ff,Triangle:fs,TriangleFanDrawMode:Tw,TriangleStripDrawMode:ww,TrianglesDrawMode:Sw,TubeGeometry:Nf,UVMapping:of,Uint16BufferAttribute:a0,Uint32BufferAttribute:l0,Uint8BufferAttribute:k1,Uint8ClampedBufferAttribute:G1,Uniform:R0,UniformsGroup:C2,UniformsLib:Ye,UniformsUtils:lC,UnsignedByteType:er,UnsignedInt248Type:vs,UnsignedInt5999Type:Kg,UnsignedIntType:Gr,UnsignedShort4444Type:lf,UnsignedShort5551Type:cf,UnsignedShortType:Xa,VSMShadowMap:Qi,Vector2:Ne,Vector3:Y,Vector4:Dt,VectorKeyframeTrack:vc,VideoFrameTexture:aT,VideoTexture:xC,WebGL3DRenderTarget:S1,WebGLArrayRenderTarget:M1,WebGLCoordinateSystem:Li,WebGLCubeRenderTarget:hC,WebGLRenderTarget:Ui,WebGLRenderer:DD,WebGLUtils:pM,WebGPUCoordinateSystem:uc,WebXRController:Ou,WireframeGeometry:BC,WrapAroundEnding:lc,ZeroCurvatureEnding:go,ZeroFactor:pb,ZeroSlopeEnding:vo,ZeroStencilOp:Bw,createCanvasElement:Zb},Symbol.toStringTag,{value:"Module"}));var UD={},AM={8167:n=>{var e=Object.prototype.toString;n.exports=function(t){return t.BYTES_PER_ELEMENT&&e.call(t.buffer)==="[object ArrayBuffer]"||Array.isArray(t)}},5734:n=>{n.exports=function(e,t){return typeof e=="number"?e:typeof t=="number"?t:0}},7961:(n,e)=>{e.byteLength=function(c){var h=a(c),u=h[0],d=h[1];return 3*(u+d)/4-d},e.toByteArray=function(c){var h,u,d=a(c),f=d[0],A=d[1],g=new r(function(v,E,x){return 3*(E+x)/4-x}(0,f,A)),m=0,p=A>0?f-4:f;for(u=0;u<p;u+=4)h=i[c.charCodeAt(u)]<<18|i[c.charCodeAt(u+1)]<<12|i[c.charCodeAt(u+2)]<<6|i[c.charCodeAt(u+3)],g[m++]=h>>16&255,g[m++]=h>>8&255,g[m++]=255&h;return A===2&&(h=i[c.charCodeAt(u)]<<2|i[c.charCodeAt(u+1)]>>4,g[m++]=255&h),A===1&&(h=i[c.charCodeAt(u)]<<10|i[c.charCodeAt(u+1)]<<4|i[c.charCodeAt(u+2)]>>2,g[m++]=h>>8&255,g[m++]=255&h),g},e.fromByteArray=function(c){for(var h,u=c.length,d=u%3,f=[],A=16383,g=0,m=u-d;g<m;g+=A)f.push(l(c,g,g+A>m?m:g+A));return d===1?(h=c[u-1],f.push(t[h>>2]+t[h<<4&63]+"==")):d===2&&(h=(c[u-2]<<8)+c[u-1],f.push(t[h>>10]+t[h>>4&63]+t[h<<2&63]+"=")),f.join("")};for(var t=[],i=[],r=typeof Uint8Array<"u"?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0;o<64;++o)t[o]=s[o],i[s.charCodeAt(o)]=o;function a(c){var h=c.length;if(h%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var u=c.indexOf("=");return u===-1&&(u=h),[u,u===h?0:4-u%4]}function l(c,h,u){for(var d,f,A=[],g=h;g<u;g+=3)d=(c[g]<<16&16711680)+(c[g+1]<<8&65280)+(255&c[g+2]),A.push(t[(f=d)>>18&63]+t[f>>12&63]+t[f>>6&63]+t[63&f]);return A.join("")}i[45]=62,i[95]=63},911:(n,e,t)=>{var i=t(9922).hp;n.exports=function(r,s){if(i.isBuffer(r)&&i.isBuffer(s)){if(typeof r.equals=="function")return r.equals(s);if(r.length!==s.length)return!1;for(var o=0;o<r.length;o++)if(r[o]!==s[o])return!1;return!0}}},9922:(n,e,t)=>{const i=t(7961),r=t(1024),s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;e.hp=l,e.IS=50;const o=2147483647;function a(b){if(b>o)throw new RangeError('The value "'+b+'" is invalid for option "size"');const I=new Uint8Array(b);return Object.setPrototypeOf(I,l.prototype),I}function l(b,I,U){if(typeof b=="number"){if(typeof I=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return u(b)}return c(b,I,U)}function c(b,I,U){if(typeof b=="string")return function(G,J){if(typeof J=="string"&&J!==""||(J="utf8"),!l.isEncoding(J))throw new TypeError("Unknown encoding: "+J);const de=0|g(G,J);let N=a(de);const P=N.write(G,J);return P!==de&&(N=N.slice(0,P)),N}(b,I);if(ArrayBuffer.isView(b))return function(G){if(Ae(G,Uint8Array)){const J=new Uint8Array(G);return f(J.buffer,J.byteOffset,J.byteLength)}return d(G)}(b);if(b==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof b);if(Ae(b,ArrayBuffer)||b&&Ae(b.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Ae(b,SharedArrayBuffer)||b&&Ae(b.buffer,SharedArrayBuffer)))return f(b,I,U);if(typeof b=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const R=b.valueOf&&b.valueOf();if(R!=null&&R!==b)return l.from(R,I,U);const T=function(G){if(l.isBuffer(G)){const J=0|A(G.length),de=a(J);return de.length===0||G.copy(de,0,0,J),de}return G.length!==void 0?typeof G.length!="number"||V(G.length)?a(0):d(G):G.type==="Buffer"&&Array.isArray(G.data)?d(G.data):void 0}(b);if(T)return T;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof b[Symbol.toPrimitive]=="function")return l.from(b[Symbol.toPrimitive]("string"),I,U);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof b)}function h(b){if(typeof b!="number")throw new TypeError('"size" argument must be of type number');if(b<0)throw new RangeError('The value "'+b+'" is invalid for option "size"')}function u(b){return h(b),a(b<0?0:0|A(b))}function d(b){const I=b.length<0?0:0|A(b.length),U=a(I);for(let R=0;R<I;R+=1)U[R]=255&b[R];return U}function f(b,I,U){if(I<0||b.byteLength<I)throw new RangeError('"offset" is outside of buffer bounds');if(b.byteLength<I+(U||0))throw new RangeError('"length" is outside of buffer bounds');let R;return R=I===void 0&&U===void 0?new Uint8Array(b):U===void 0?new Uint8Array(b,I):new Uint8Array(b,I,U),Object.setPrototypeOf(R,l.prototype),R}function A(b){if(b>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return 0|b}function g(b,I){if(l.isBuffer(b))return b.length;if(ArrayBuffer.isView(b)||Ae(b,ArrayBuffer))return b.byteLength;if(typeof b!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof b);const U=b.length,R=arguments.length>2&&arguments[2]===!0;if(!R&&U===0)return 0;let T=!1;for(;;)switch(I){case"ascii":case"latin1":case"binary":return U;case"utf8":case"utf-8":return Me(b).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*U;case"hex":return U>>>1;case"base64":return Ve(b).length;default:if(T)return R?-1:Me(b).length;I=(""+I).toLowerCase(),T=!0}}function m(b,I,U){let R=!1;if((I===void 0||I<0)&&(I=0),I>this.length||((U===void 0||U>this.length)&&(U=this.length),U<=0)||(U>>>=0)<=(I>>>=0))return"";for(b||(b="utf8");;)switch(b){case"hex":return X(this,I,U);case"utf8":case"utf-8":return _(this,I,U);case"ascii":return Q(this,I,U);case"latin1":case"binary":return O(this,I,U);case"base64":return y(this,I,U);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return te(this,I,U);default:if(R)throw new TypeError("Unknown encoding: "+b);b=(b+"").toLowerCase(),R=!0}}function p(b,I,U){const R=b[I];b[I]=b[U],b[U]=R}function v(b,I,U,R,T){if(b.length===0)return-1;if(typeof U=="string"?(R=U,U=0):U>2147483647?U=2147483647:U<-2147483648&&(U=-2147483648),V(U=+U)&&(U=T?0:b.length-1),U<0&&(U=b.length+U),U>=b.length){if(T)return-1;U=b.length-1}else if(U<0){if(!T)return-1;U=0}if(typeof I=="string"&&(I=l.from(I,R)),l.isBuffer(I))return I.length===0?-1:E(b,I,U,R,T);if(typeof I=="number")return I&=255,typeof Uint8Array.prototype.indexOf=="function"?T?Uint8Array.prototype.indexOf.call(b,I,U):Uint8Array.prototype.lastIndexOf.call(b,I,U):E(b,[I],U,R,T);throw new TypeError("val must be string, number or Buffer")}function E(b,I,U,R,T){let G,J=1,de=b.length,N=I.length;if(R!==void 0&&((R=String(R).toLowerCase())==="ucs2"||R==="ucs-2"||R==="utf16le"||R==="utf-16le")){if(b.length<2||I.length<2)return-1;J=2,de/=2,N/=2,U/=2}function P($,se){return J===1?$[se]:$.readUInt16BE(se*J)}if(T){let $=-1;for(G=U;G<de;G++)if(P(b,G)===P(I,$===-1?0:G-$)){if($===-1&&($=G),G-$+1===N)return $*J}else $!==-1&&(G-=G-$),$=-1}else for(U+N>de&&(U=de-N),G=U;G>=0;G--){let $=!0;for(let se=0;se<N;se++)if(P(b,G+se)!==P(I,se)){$=!1;break}if($)return G}return-1}function x(b,I,U,R){U=Number(U)||0;const T=b.length-U;R?(R=Number(R))>T&&(R=T):R=T;const G=I.length;let J;for(R>G/2&&(R=G/2),J=0;J<R;++J){const de=parseInt(I.substr(2*J,2),16);if(V(de))return J;b[U+J]=de}return J}function M(b,I,U,R){return me(Me(I,b.length-U),b,U,R)}function w(b,I,U,R){return me(function(T){const G=[];for(let J=0;J<T.length;++J)G.push(255&T.charCodeAt(J));return G}(I),b,U,R)}function S(b,I,U,R){return me(Ve(I),b,U,R)}function B(b,I,U,R){return me(function(T,G){let J,de,N;const P=[];for(let $=0;$<T.length&&!((G-=2)<0);++$)J=T.charCodeAt($),de=J>>8,N=J%256,P.push(N),P.push(de);return P}(I,b.length-U),b,U,R)}function y(b,I,U){return I===0&&U===b.length?i.fromByteArray(b):i.fromByteArray(b.slice(I,U))}function _(b,I,U){U=Math.min(b.length,U);const R=[];let T=I;for(;T<U;){const G=b[T];let J=null,de=G>239?4:G>223?3:G>191?2:1;if(T+de<=U){let N,P,$,se;switch(de){case 1:G<128&&(J=G);break;case 2:N=b[T+1],(192&N)==128&&(se=(31&G)<<6|63&N,se>127&&(J=se));break;case 3:N=b[T+1],P=b[T+2],(192&N)==128&&(192&P)==128&&(se=(15&G)<<12|(63&N)<<6|63&P,se>2047&&(se<55296||se>57343)&&(J=se));break;case 4:N=b[T+1],P=b[T+2],$=b[T+3],(192&N)==128&&(192&P)==128&&(192&$)==128&&(se=(15&G)<<18|(63&N)<<12|(63&P)<<6|63&$,se>65535&&se<1114112&&(J=se))}}J===null?(J=65533,de=1):J>65535&&(J-=65536,R.push(J>>>10&1023|55296),J=56320|1023&J),R.push(J),T+=de}return function(G){const J=G.length;if(J<=L)return String.fromCharCode.apply(String,G);let de="",N=0;for(;N<J;)de+=String.fromCharCode.apply(String,G.slice(N,N+=L));return de}(R)}l.TYPED_ARRAY_SUPPORT=function(){try{const b=new Uint8Array(1),I={foo:function(){return 42}};return Object.setPrototypeOf(I,Uint8Array.prototype),Object.setPrototypeOf(b,I),b.foo()===42}catch{return!1}}(),l.TYPED_ARRAY_SUPPORT||typeof console>"u"||typeof console.error!="function"||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(b,I,U){return c(b,I,U)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(b,I,U){return function(R,T,G){return h(R),R<=0?a(R):T!==void 0?typeof G=="string"?a(R).fill(T,G):a(R).fill(T):a(R)}(b,I,U)},l.allocUnsafe=function(b){return u(b)},l.allocUnsafeSlow=function(b){return u(b)},l.isBuffer=function(b){return b!=null&&b._isBuffer===!0&&b!==l.prototype},l.compare=function(b,I){if(Ae(b,Uint8Array)&&(b=l.from(b,b.offset,b.byteLength)),Ae(I,Uint8Array)&&(I=l.from(I,I.offset,I.byteLength)),!l.isBuffer(b)||!l.isBuffer(I))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(b===I)return 0;let U=b.length,R=I.length;for(let T=0,G=Math.min(U,R);T<G;++T)if(b[T]!==I[T]){U=b[T],R=I[T];break}return U<R?-1:R<U?1:0},l.isEncoding=function(b){switch(String(b).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(b,I){if(!Array.isArray(b))throw new TypeError('"list" argument must be an Array of Buffers');if(b.length===0)return l.alloc(0);let U;if(I===void 0)for(I=0,U=0;U<b.length;++U)I+=b[U].length;const R=l.allocUnsafe(I);let T=0;for(U=0;U<b.length;++U){let G=b[U];if(Ae(G,Uint8Array))T+G.length>R.length?(l.isBuffer(G)||(G=l.from(G)),G.copy(R,T)):Uint8Array.prototype.set.call(R,G,T);else{if(!l.isBuffer(G))throw new TypeError('"list" argument must be an Array of Buffers');G.copy(R,T)}T+=G.length}return R},l.byteLength=g,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const b=this.length;if(b%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let I=0;I<b;I+=2)p(this,I,I+1);return this},l.prototype.swap32=function(){const b=this.length;if(b%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let I=0;I<b;I+=4)p(this,I,I+3),p(this,I+1,I+2);return this},l.prototype.swap64=function(){const b=this.length;if(b%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let I=0;I<b;I+=8)p(this,I,I+7),p(this,I+1,I+6),p(this,I+2,I+5),p(this,I+3,I+4);return this},l.prototype.toString=function(){const b=this.length;return b===0?"":arguments.length===0?_(this,0,b):m.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(b){if(!l.isBuffer(b))throw new TypeError("Argument must be a Buffer");return this===b||l.compare(this,b)===0},l.prototype.inspect=function(){let b="";const I=e.IS;return b=this.toString("hex",0,I).replace(/(.{2})/g,"$1 ").trim(),this.length>I&&(b+=" ... "),"<Buffer "+b+">"},s&&(l.prototype[s]=l.prototype.inspect),l.prototype.compare=function(b,I,U,R,T){if(Ae(b,Uint8Array)&&(b=l.from(b,b.offset,b.byteLength)),!l.isBuffer(b))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof b);if(I===void 0&&(I=0),U===void 0&&(U=b?b.length:0),R===void 0&&(R=0),T===void 0&&(T=this.length),I<0||U>b.length||R<0||T>this.length)throw new RangeError("out of range index");if(R>=T&&I>=U)return 0;if(R>=T)return-1;if(I>=U)return 1;if(this===b)return 0;let G=(T>>>=0)-(R>>>=0),J=(U>>>=0)-(I>>>=0);const de=Math.min(G,J),N=this.slice(R,T),P=b.slice(I,U);for(let $=0;$<de;++$)if(N[$]!==P[$]){G=N[$],J=P[$];break}return G<J?-1:J<G?1:0},l.prototype.includes=function(b,I,U){return this.indexOf(b,I,U)!==-1},l.prototype.indexOf=function(b,I,U){return v(this,b,I,U,!0)},l.prototype.lastIndexOf=function(b,I,U){return v(this,b,I,U,!1)},l.prototype.write=function(b,I,U,R){if(I===void 0)R="utf8",U=this.length,I=0;else if(U===void 0&&typeof I=="string")R=I,U=this.length,I=0;else{if(!isFinite(I))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");I>>>=0,isFinite(U)?(U>>>=0,R===void 0&&(R="utf8")):(R=U,U=void 0)}const T=this.length-I;if((U===void 0||U>T)&&(U=T),b.length>0&&(U<0||I<0)||I>this.length)throw new RangeError("Attempt to write outside buffer bounds");R||(R="utf8");let G=!1;for(;;)switch(R){case"hex":return x(this,b,I,U);case"utf8":case"utf-8":return M(this,b,I,U);case"ascii":case"latin1":case"binary":return w(this,b,I,U);case"base64":return S(this,b,I,U);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return B(this,b,I,U);default:if(G)throw new TypeError("Unknown encoding: "+R);R=(""+R).toLowerCase(),G=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const L=4096;function Q(b,I,U){let R="";U=Math.min(b.length,U);for(let T=I;T<U;++T)R+=String.fromCharCode(127&b[T]);return R}function O(b,I,U){let R="";U=Math.min(b.length,U);for(let T=I;T<U;++T)R+=String.fromCharCode(b[T]);return R}function X(b,I,U){const R=b.length;(!I||I<0)&&(I=0),(!U||U<0||U>R)&&(U=R);let T="";for(let G=I;G<U;++G)T+=j[b[G]];return T}function te(b,I,U){const R=b.slice(I,U);let T="";for(let G=0;G<R.length-1;G+=2)T+=String.fromCharCode(R[G]+256*R[G+1]);return T}function W(b,I,U){if(b%1!=0||b<0)throw new RangeError("offset is not uint");if(b+I>U)throw new RangeError("Trying to access beyond buffer length")}function Z(b,I,U,R,T,G){if(!l.isBuffer(b))throw new TypeError('"buffer" argument must be a Buffer instance');if(I>T||I<G)throw new RangeError('"value" argument is out of bounds');if(U+R>b.length)throw new RangeError("Index out of range")}function q(b,I,U,R,T){Ue(I,R,T,b,U,7);let G=Number(I&BigInt(4294967295));b[U++]=G,G>>=8,b[U++]=G,G>>=8,b[U++]=G,G>>=8,b[U++]=G;let J=Number(I>>BigInt(32)&BigInt(4294967295));return b[U++]=J,J>>=8,b[U++]=J,J>>=8,b[U++]=J,J>>=8,b[U++]=J,U}function re(b,I,U,R,T){Ue(I,R,T,b,U,7);let G=Number(I&BigInt(4294967295));b[U+7]=G,G>>=8,b[U+6]=G,G>>=8,b[U+5]=G,G>>=8,b[U+4]=G;let J=Number(I>>BigInt(32)&BigInt(4294967295));return b[U+3]=J,J>>=8,b[U+2]=J,J>>=8,b[U+1]=J,J>>=8,b[U]=J,U+8}function ue(b,I,U,R,T,G){if(U+R>b.length)throw new RangeError("Index out of range");if(U<0)throw new RangeError("Index out of range")}function _e(b,I,U,R,T){return I=+I,U>>>=0,T||ue(b,0,U,4),r.write(b,I,U,R,23,4),U+4}function Be(b,I,U,R,T){return I=+I,U>>>=0,T||ue(b,0,U,8),r.write(b,I,U,R,52,8),U+8}l.prototype.slice=function(b,I){const U=this.length;(b=~~b)<0?(b+=U)<0&&(b=0):b>U&&(b=U),(I=I===void 0?U:~~I)<0?(I+=U)<0&&(I=0):I>U&&(I=U),I<b&&(I=b);const R=this.subarray(b,I);return Object.setPrototypeOf(R,l.prototype),R},l.prototype.readUintLE=l.prototype.readUIntLE=function(b,I,U){b>>>=0,I>>>=0,U||W(b,I,this.length);let R=this[b],T=1,G=0;for(;++G<I&&(T*=256);)R+=this[b+G]*T;return R},l.prototype.readUintBE=l.prototype.readUIntBE=function(b,I,U){b>>>=0,I>>>=0,U||W(b,I,this.length);let R=this[b+--I],T=1;for(;I>0&&(T*=256);)R+=this[b+--I]*T;return R},l.prototype.readUint8=l.prototype.readUInt8=function(b,I){return b>>>=0,I||W(b,1,this.length),this[b]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(b,I){return b>>>=0,I||W(b,2,this.length),this[b]|this[b+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(b,I){return b>>>=0,I||W(b,2,this.length),this[b]<<8|this[b+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(b,I){return b>>>=0,I||W(b,4,this.length),(this[b]|this[b+1]<<8|this[b+2]<<16)+16777216*this[b+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(b,I){return b>>>=0,I||W(b,4,this.length),16777216*this[b]+(this[b+1]<<16|this[b+2]<<8|this[b+3])},l.prototype.readBigUInt64LE=Te(function(b){pe(b>>>=0,"offset");const I=this[b],U=this[b+7];I!==void 0&&U!==void 0||oe(b,this.length-8);const R=I+256*this[++b]+65536*this[++b]+this[++b]*2**24,T=this[++b]+256*this[++b]+65536*this[++b]+U*2**24;return BigInt(R)+(BigInt(T)<<BigInt(32))}),l.prototype.readBigUInt64BE=Te(function(b){pe(b>>>=0,"offset");const I=this[b],U=this[b+7];I!==void 0&&U!==void 0||oe(b,this.length-8);const R=I*2**24+65536*this[++b]+256*this[++b]+this[++b],T=this[++b]*2**24+65536*this[++b]+256*this[++b]+U;return(BigInt(R)<<BigInt(32))+BigInt(T)}),l.prototype.readIntLE=function(b,I,U){b>>>=0,I>>>=0,U||W(b,I,this.length);let R=this[b],T=1,G=0;for(;++G<I&&(T*=256);)R+=this[b+G]*T;return T*=128,R>=T&&(R-=Math.pow(2,8*I)),R},l.prototype.readIntBE=function(b,I,U){b>>>=0,I>>>=0,U||W(b,I,this.length);let R=I,T=1,G=this[b+--R];for(;R>0&&(T*=256);)G+=this[b+--R]*T;return T*=128,G>=T&&(G-=Math.pow(2,8*I)),G},l.prototype.readInt8=function(b,I){return b>>>=0,I||W(b,1,this.length),128&this[b]?-1*(255-this[b]+1):this[b]},l.prototype.readInt16LE=function(b,I){b>>>=0,I||W(b,2,this.length);const U=this[b]|this[b+1]<<8;return 32768&U?4294901760|U:U},l.prototype.readInt16BE=function(b,I){b>>>=0,I||W(b,2,this.length);const U=this[b+1]|this[b]<<8;return 32768&U?4294901760|U:U},l.prototype.readInt32LE=function(b,I){return b>>>=0,I||W(b,4,this.length),this[b]|this[b+1]<<8|this[b+2]<<16|this[b+3]<<24},l.prototype.readInt32BE=function(b,I){return b>>>=0,I||W(b,4,this.length),this[b]<<24|this[b+1]<<16|this[b+2]<<8|this[b+3]},l.prototype.readBigInt64LE=Te(function(b){pe(b>>>=0,"offset");const I=this[b],U=this[b+7];I!==void 0&&U!==void 0||oe(b,this.length-8);const R=this[b+4]+256*this[b+5]+65536*this[b+6]+(U<<24);return(BigInt(R)<<BigInt(32))+BigInt(I+256*this[++b]+65536*this[++b]+this[++b]*2**24)}),l.prototype.readBigInt64BE=Te(function(b){pe(b>>>=0,"offset");const I=this[b],U=this[b+7];I!==void 0&&U!==void 0||oe(b,this.length-8);const R=(I<<24)+65536*this[++b]+256*this[++b]+this[++b];return(BigInt(R)<<BigInt(32))+BigInt(this[++b]*2**24+65536*this[++b]+256*this[++b]+U)}),l.prototype.readFloatLE=function(b,I){return b>>>=0,I||W(b,4,this.length),r.read(this,b,!0,23,4)},l.prototype.readFloatBE=function(b,I){return b>>>=0,I||W(b,4,this.length),r.read(this,b,!1,23,4)},l.prototype.readDoubleLE=function(b,I){return b>>>=0,I||W(b,8,this.length),r.read(this,b,!0,52,8)},l.prototype.readDoubleBE=function(b,I){return b>>>=0,I||W(b,8,this.length),r.read(this,b,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(b,I,U,R){b=+b,I>>>=0,U>>>=0,R||Z(this,b,I,U,Math.pow(2,8*U)-1,0);let T=1,G=0;for(this[I]=255&b;++G<U&&(T*=256);)this[I+G]=b/T&255;return I+U},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(b,I,U,R){b=+b,I>>>=0,U>>>=0,R||Z(this,b,I,U,Math.pow(2,8*U)-1,0);let T=U-1,G=1;for(this[I+T]=255&b;--T>=0&&(G*=256);)this[I+T]=b/G&255;return I+U},l.prototype.writeUint8=l.prototype.writeUInt8=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,1,255,0),this[I]=255&b,I+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,2,65535,0),this[I]=255&b,this[I+1]=b>>>8,I+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,2,65535,0),this[I]=b>>>8,this[I+1]=255&b,I+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,4,4294967295,0),this[I+3]=b>>>24,this[I+2]=b>>>16,this[I+1]=b>>>8,this[I]=255&b,I+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,4,4294967295,0),this[I]=b>>>24,this[I+1]=b>>>16,this[I+2]=b>>>8,this[I+3]=255&b,I+4},l.prototype.writeBigUInt64LE=Te(function(b,I=0){return q(this,b,I,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeBigUInt64BE=Te(function(b,I=0){return re(this,b,I,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeIntLE=function(b,I,U,R){if(b=+b,I>>>=0,!R){const de=Math.pow(2,8*U-1);Z(this,b,I,U,de-1,-de)}let T=0,G=1,J=0;for(this[I]=255&b;++T<U&&(G*=256);)b<0&&J===0&&this[I+T-1]!==0&&(J=1),this[I+T]=(b/G|0)-J&255;return I+U},l.prototype.writeIntBE=function(b,I,U,R){if(b=+b,I>>>=0,!R){const de=Math.pow(2,8*U-1);Z(this,b,I,U,de-1,-de)}let T=U-1,G=1,J=0;for(this[I+T]=255&b;--T>=0&&(G*=256);)b<0&&J===0&&this[I+T+1]!==0&&(J=1),this[I+T]=(b/G|0)-J&255;return I+U},l.prototype.writeInt8=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,1,127,-128),b<0&&(b=255+b+1),this[I]=255&b,I+1},l.prototype.writeInt16LE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,2,32767,-32768),this[I]=255&b,this[I+1]=b>>>8,I+2},l.prototype.writeInt16BE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,2,32767,-32768),this[I]=b>>>8,this[I+1]=255&b,I+2},l.prototype.writeInt32LE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,4,2147483647,-2147483648),this[I]=255&b,this[I+1]=b>>>8,this[I+2]=b>>>16,this[I+3]=b>>>24,I+4},l.prototype.writeInt32BE=function(b,I,U){return b=+b,I>>>=0,U||Z(this,b,I,4,2147483647,-2147483648),b<0&&(b=4294967295+b+1),this[I]=b>>>24,this[I+1]=b>>>16,this[I+2]=b>>>8,this[I+3]=255&b,I+4},l.prototype.writeBigInt64LE=Te(function(b,I=0){return q(this,b,I,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),l.prototype.writeBigInt64BE=Te(function(b,I=0){return re(this,b,I,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),l.prototype.writeFloatLE=function(b,I,U){return _e(this,b,I,!0,U)},l.prototype.writeFloatBE=function(b,I,U){return _e(this,b,I,!1,U)},l.prototype.writeDoubleLE=function(b,I,U){return Be(this,b,I,!0,U)},l.prototype.writeDoubleBE=function(b,I,U){return Be(this,b,I,!1,U)},l.prototype.copy=function(b,I,U,R){if(!l.isBuffer(b))throw new TypeError("argument should be a Buffer");if(U||(U=0),R||R===0||(R=this.length),I>=b.length&&(I=b.length),I||(I=0),R>0&&R<U&&(R=U),R===U||b.length===0||this.length===0)return 0;if(I<0)throw new RangeError("targetStart out of bounds");if(U<0||U>=this.length)throw new RangeError("Index out of range");if(R<0)throw new RangeError("sourceEnd out of bounds");R>this.length&&(R=this.length),b.length-I<R-U&&(R=b.length-I+U);const T=R-U;return this===b&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(I,U,R):Uint8Array.prototype.set.call(b,this.subarray(U,R),I),T},l.prototype.fill=function(b,I,U,R){if(typeof b=="string"){if(typeof I=="string"?(R=I,I=0,U=this.length):typeof U=="string"&&(R=U,U=this.length),R!==void 0&&typeof R!="string")throw new TypeError("encoding must be a string");if(typeof R=="string"&&!l.isEncoding(R))throw new TypeError("Unknown encoding: "+R);if(b.length===1){const G=b.charCodeAt(0);(R==="utf8"&&G<128||R==="latin1")&&(b=G)}}else typeof b=="number"?b&=255:typeof b=="boolean"&&(b=Number(b));if(I<0||this.length<I||this.length<U)throw new RangeError("Out of range index");if(U<=I)return this;let T;if(I>>>=0,U=U===void 0?this.length:U>>>0,b||(b=0),typeof b=="number")for(T=I;T<U;++T)this[T]=b;else{const G=l.isBuffer(b)?b:l.from(b,R),J=G.length;if(J===0)throw new TypeError('The value "'+b+'" is invalid for argument "value"');for(T=0;T<U-I;++T)this[T+I]=G[T%J]}return this};const ze={};function le(b,I,U){ze[b]=class extends U{constructor(){super(),Object.defineProperty(this,"message",{value:I.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${b}]`,this.stack,delete this.name}get code(){return b}set code(R){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:R,writable:!0})}toString(){return`${this.name} [${b}]: ${this.message}`}}}function Ee(b){let I="",U=b.length;const R=b[0]==="-"?1:0;for(;U>=R+4;U-=3)I=`_${b.slice(U-3,U)}${I}`;return`${b.slice(0,U)}${I}`}function Ue(b,I,U,R,T,G){if(b>U||b<I){const J=typeof I=="bigint"?"n":"";let de;throw de=I===0||I===BigInt(0)?`>= 0${J} and < 2${J} ** ${8*(G+1)}${J}`:`>= -(2${J} ** ${8*(G+1)-1}${J}) and < 2 ** ${8*(G+1)-1}${J}`,new ze.ERR_OUT_OF_RANGE("value",de,b)}(function(J,de,N){pe(de,"offset"),J[de]!==void 0&&J[de+N]!==void 0||oe(de,J.length-(N+1))})(R,T,G)}function pe(b,I){if(typeof b!="number")throw new ze.ERR_INVALID_ARG_TYPE(I,"number",b)}function oe(b,I,U){throw Math.floor(b)!==b?(pe(b,U),new ze.ERR_OUT_OF_RANGE("offset","an integer",b)):I<0?new ze.ERR_BUFFER_OUT_OF_BOUNDS:new ze.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${I}`,b)}le("ERR_BUFFER_OUT_OF_BOUNDS",function(b){return b?`${b} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),le("ERR_INVALID_ARG_TYPE",function(b,I){return`The "${b}" argument must be of type number. Received type ${typeof I}`},TypeError),le("ERR_OUT_OF_RANGE",function(b,I,U){let R=`The value of "${b}" is out of range.`,T=U;return Number.isInteger(U)&&Math.abs(U)>2**32?T=Ee(String(U)):typeof U=="bigint"&&(T=String(U),(U>BigInt(2)**BigInt(32)||U<-(BigInt(2)**BigInt(32)))&&(T=Ee(T)),T+="n"),R+=` It must be ${I}. Received ${T}`,R},RangeError);const we=/[^+/0-9A-Za-z-_]/g;function Me(b,I){let U;I=I||1/0;const R=b.length;let T=null;const G=[];for(let J=0;J<R;++J){if(U=b.charCodeAt(J),U>55295&&U<57344){if(!T){if(U>56319){(I-=3)>-1&&G.push(239,191,189);continue}if(J+1===R){(I-=3)>-1&&G.push(239,191,189);continue}T=U;continue}if(U<56320){(I-=3)>-1&&G.push(239,191,189),T=U;continue}U=65536+(T-55296<<10|U-56320)}else T&&(I-=3)>-1&&G.push(239,191,189);if(T=null,U<128){if((I-=1)<0)break;G.push(U)}else if(U<2048){if((I-=2)<0)break;G.push(U>>6|192,63&U|128)}else if(U<65536){if((I-=3)<0)break;G.push(U>>12|224,U>>6&63|128,63&U|128)}else{if(!(U<1114112))throw new Error("Invalid code point");if((I-=4)<0)break;G.push(U>>18|240,U>>12&63|128,U>>6&63|128,63&U|128)}}return G}function Ve(b){return i.toByteArray(function(I){if((I=(I=I.split("=")[0]).trim().replace(we,"")).length<2)return"";for(;I.length%4!=0;)I+="=";return I}(b))}function me(b,I,U,R){let T;for(T=0;T<R&&!(T+U>=I.length||T>=b.length);++T)I[T+U]=b[T];return T}function Ae(b,I){return b instanceof I||b!=null&&b.constructor!=null&&b.constructor.name!=null&&b.constructor.name===I.name}function V(b){return b!=b}const j=function(){const b="0123456789abcdef",I=new Array(256);for(let U=0;U<16;++U){const R=16*U;for(let T=0;T<16;++T)I[R+T]=b[U]+b[T]}return I}();function Te(b){return typeof BigInt>"u"?Re:b}function Re(){throw new Error("BigInt not supported")}},9089:n=>{n.exports=function(e){var t=[];return t.toString=function(){return this.map(function(i){var r="",s=i[5]!==void 0;return i[4]&&(r+="@supports (".concat(i[4],") {")),i[2]&&(r+="@media ".concat(i[2]," {")),s&&(r+="@layer".concat(i[5].length>0?" ".concat(i[5]):""," {")),r+=e(i),s&&(r+="}"),i[2]&&(r+="}"),i[4]&&(r+="}"),r}).join("")},t.i=function(i,r,s,o,a){typeof i=="string"&&(i=[[null,i,void 0]]);var l={};if(s)for(var c=0;c<this.length;c++){var h=this[c][0];h!=null&&(l[h]=!0)}for(var u=0;u<i.length;u++){var d=[].concat(i[u]);s&&l[d[0]]||(a!==void 0&&(d[5]===void 0||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=a),r&&(d[2]&&(d[1]="@media ".concat(d[2]," {").concat(d[1],"}")),d[2]=r),o&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=o):d[4]="".concat(o)),t.push(d))}},t}},6492:n=>{n.exports=function(e,t){return t||(t={}),e&&(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e)}},963:n=>{n.exports=function(e){var t=e[1],i=e[3];if(!i)return t;if(typeof btoa=="function"){var r=btoa(unescape(encodeURIComponent(JSON.stringify(i)))),s="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r),o="/*# ".concat(s," */");return[t].concat([o]).join(`
`)}return[t].join(`
`)}},8878:(n,e,t)=>{e.formatArgs=function(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const s="color: "+this.color;r.splice(1,0,s,"color: inherit");let o=0,a=0;r[0].replace(/%[a-zA-Z%]/g,l=>{l!=="%%"&&(o++,l==="%c"&&(a=o))}),r.splice(a,0,s)},e.save=function(r){try{r?e.storage.setItem("debug",r):e.storage.removeItem("debug")}catch{}},e.load=function(){let r;try{r=e.storage.getItem("debug")}catch{}return!r&&typeof process<"u"&&"env"in process&&(r=UD.DEBUG),r},e.useColors=function(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let r;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(r=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(r[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage=function(){try{return localStorage}catch{}}(),e.destroy=(()=>{let r=!1;return()=>{r||(r=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.log=console.debug||console.log||(()=>{}),n.exports=t(8945)(e);const{formatters:i}=n.exports;i.j=function(r){try{return JSON.stringify(r)}catch(s){return"[UnexpectedJSONParseError]: "+s.message}}},8945:(n,e,t)=>{n.exports=function(i){function r(a){let l,c,h,u=null;function d(...f){if(!d.enabled)return;const A=d,g=Number(new Date),m=g-(l||g);A.diff=m,A.prev=l,A.curr=g,l=g,f[0]=r.coerce(f[0]),typeof f[0]!="string"&&f.unshift("%O");let p=0;f[0]=f[0].replace(/%([a-zA-Z%])/g,(v,E)=>{if(v==="%%")return"%";p++;const x=r.formatters[E];if(typeof x=="function"){const M=f[p];v=x.call(A,M),f.splice(p,1),p--}return v}),r.formatArgs.call(A,f),(A.log||r.log).apply(A,f)}return d.namespace=a,d.useColors=r.useColors(),d.color=r.selectColor(a),d.extend=s,d.destroy=r.destroy,Object.defineProperty(d,"enabled",{enumerable:!0,configurable:!1,get:()=>u!==null?u:(c!==r.namespaces&&(c=r.namespaces,h=r.enabled(a)),h),set:f=>{u=f}}),typeof r.init=="function"&&r.init(d),d}function s(a,l){const c=r(this.namespace+(l===void 0?":":l)+a);return c.log=this.log,c}function o(a,l){let c=0,h=0,u=-1,d=0;for(;c<a.length;)if(h<l.length&&(l[h]===a[c]||l[h]==="*"))l[h]==="*"?(u=h,d=c,h++):(c++,h++);else{if(u===-1)return!1;h=u+1,d++,c=d}for(;h<l.length&&l[h]==="*";)h++;return h===l.length}return r.debug=r,r.default=r,r.coerce=function(a){return a instanceof Error?a.stack||a.message:a},r.disable=function(){const a=[...r.names,...r.skips.map(l=>"-"+l)].join(",");return r.enable(""),a},r.enable=function(a){r.save(a),r.namespaces=a,r.names=[],r.skips=[];const l=(typeof a=="string"?a:"").trim().replace(" ",",").split(",").filter(Boolean);for(const c of l)c[0]==="-"?r.skips.push(c.slice(1)):r.names.push(c)},r.enabled=function(a){for(const l of r.skips)if(o(a,l))return!1;for(const l of r.names)if(o(a,l))return!0;return!1},r.humanize=t(9192),r.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(i).forEach(a=>{r[a]=i[a]}),r.names=[],r.skips=[],r.formatters={},r.selectColor=function(a){let l=0;for(let c=0;c<a.length;c++)l=(l<<5)-l+a.charCodeAt(c),l|=0;return r.colors[Math.abs(l)%r.colors.length]},r.enable(r.load()),r}},1124:(n,e,t)=>{var i=t(6240),r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;function o(l,c,h){var u=c[h];if(u!=null){if(r.call(l,h)&&(l[h]===void 0||l[h]===null))throw new TypeError("Cannot convert undefined or null to object ("+h+")");r.call(l,h)&&i(u)?l[h]=a(Object(l[h]),c[h]):l[h]=u}}function a(l,c){if(l===c)return l;for(var h in c=Object(c))r.call(c,h)&&o(l,c,h);if(Object.getOwnPropertySymbols)for(var u=Object.getOwnPropertySymbols(c),d=0;d<u.length;d++)s.call(c,u[d])&&o(l,c,u[d]);return l}n.exports=function(l){l=function(h){if(h==null)throw new TypeError("Sources cannot be null or undefined");return Object(h)}(l);for(var c=1;c<arguments.length;c++)a(l,arguments[c]);return l}},8480:n=>{n.exports=function(e){switch(e){case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"uint8":return Uint8Array;case"uint16":return Uint16Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;case"array":return Array;case"uint8_clamped":return Uint8ClampedArray}}},919:(n,e,t)=>{var i;i=typeof window<"u"?window:t.g!==void 0?t.g:typeof self<"u"?self:{},n.exports=i},1024:(n,e)=>{e.read=function(t,i,r,s,o){var a,l,c=8*o-s-1,h=(1<<c)-1,u=h>>1,d=-7,f=r?o-1:0,A=r?-1:1,g=t[i+f];for(f+=A,a=g&(1<<-d)-1,g>>=-d,d+=c;d>0;a=256*a+t[i+f],f+=A,d-=8);for(l=a&(1<<-d)-1,a>>=-d,d+=s;d>0;l=256*l+t[i+f],f+=A,d-=8);if(a===0)a=1-u;else{if(a===h)return l?NaN:1/0*(g?-1:1);l+=Math.pow(2,s),a-=u}return(g?-1:1)*l*Math.pow(2,a-s)},e.write=function(t,i,r,s,o,a){var l,c,h,u=8*a-o-1,d=(1<<u)-1,f=d>>1,A=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,g=s?0:a-1,m=s?1:-1,p=i<0||i===0&&1/i<0?1:0;for(i=Math.abs(i),isNaN(i)||i===1/0?(c=isNaN(i)?1:0,l=d):(l=Math.floor(Math.log(i)/Math.LN2),i*(h=Math.pow(2,-l))<1&&(l--,h*=2),(i+=l+f>=1?A/h:A*Math.pow(2,1-f))*h>=2&&(l++,h/=2),l+f>=d?(c=0,l=d):l+f>=1?(c=(i*h-1)*Math.pow(2,o),l+=f):(c=i*Math.pow(2,f-1)*Math.pow(2,o),l=0));o>=8;t[r+g]=255&c,g+=m,c/=256,o-=8);for(l=l<<o|c,u+=o;u>0;t[r+g]=255&l,g+=m,l/=256,u-=8);t[r+g-m]|=128*p}},2225:n=>{function e(t){return!!t.constructor&&typeof t.constructor.isBuffer=="function"&&t.constructor.isBuffer(t)}n.exports=function(t){return t!=null&&(e(t)||function(i){return typeof i.readFloatLE=="function"&&typeof i.slice=="function"&&e(i.slice(0,0))}(t)||!!t._isBuffer)}},8847:n=>{n.exports=function(t){if(!t)return!1;var i=e.call(t);return i==="[object Function]"||typeof t=="function"&&i!=="[object RegExp]"||typeof window<"u"&&(t===window.setTimeout||t===window.alert||t===window.confirm||t===window.prompt)};var e=Object.prototype.toString},6240:n=>{n.exports=function(e){var t=typeof e;return e!==null&&(t==="object"||t==="function")}},5651:(n,e,t)=>{var i=t(5406),r=t(4597),s=t(5734),o=["x","e","a","o","n","s","r","c","u","m","v","w","z"],a=["m","w"],l=["H","I","N","E","F","K","L","T","U","V","W","X","Y","Z"],c=9,h=32;function u(m){this.glyphs=[],this._measure=this.computeMetrics.bind(this),this.update(m)}function d(m){return new Function(["return function "+m+"() {","  return this._"+m,"}"].join(`
`))()}function f(m,p){if(!m.chars||m.chars.length===0)return null;var v=g(m.chars,p);return v>=0?m.chars[v]:null}function A(m,p,v){if(!m.kernings||m.kernings.length===0)return 0;for(var E=m.kernings,x=0;x<E.length;x++){var M=E[x];if(M.first===p&&M.second===v)return M.amount}return 0}function g(m,p,v){for(var E=v=v||0;E<m.length;E++)if(m[E].id===p)return E;return-1}n.exports=function(m){return new u(m)},u.prototype.update=function(m){if(m=r({measure:this._measure},m),this._opt=m,this._opt.tabSize=s(this._opt.tabSize,4),!m.font)throw new Error("must provide a valid bitmap font");var p=this.glyphs,v=m.text||"",E=m.font;this._setupSpaceGlyphs(E);var x=i.lines(v,m),M=m.width||0;p.length=0;var w=x.reduce(function(W,Z){return Math.max(W,Z.width,M)},0),S=0,B=0,y=s(m.lineHeight,E.common.lineHeight),_=E.common.base,L=y-_,Q=m.letterSpacing||0,O=y*x.length-L,X=function(W){return W==="center"?1:W==="right"?2:0}(this._opt.align);B-=O,this._width=w,this._height=O,this._descender=y-_,this._baseline=_,this._xHeight=function(W){for(var Z=0;Z<o.length;Z++){var q=o[Z].charCodeAt(0),re=g(W.chars,q);if(re>=0)return W.chars[re].height}return 0}(E),this._capHeight=function(W){for(var Z=0;Z<l.length;Z++){var q=l[Z].charCodeAt(0),re=g(W.chars,q);if(re>=0)return W.chars[re].height}return 0}(E),this._lineHeight=y,this._ascender=y-L-this._xHeight;var te=this;x.forEach(function(W,Z){for(var q,re=W.start,ue=W.end,_e=W.width,Be=re;Be<ue;Be++){var ze=v.charCodeAt(Be),le=te.getGlyph(E,ze);if(le){q&&(S+=A(E,q.id,le.id));var Ee=S;X===1?Ee+=(w-_e)/2:X===2&&(Ee+=w-_e),p.push({position:[Ee,B],data:le,index:Be,line:Z}),S+=le.xadvance+Q,q=le}}B+=y,S=0}),this._linesTotal=x.length},u.prototype._setupSpaceGlyphs=function(m){if(this._fallbackSpaceGlyph=null,this._fallbackTabGlyph=null,m.chars&&m.chars.length!==0){var p=f(m,h)||function(E){for(var x=0;x<a.length;x++){var M=a[x].charCodeAt(0),w=g(E.chars,M);if(w>=0)return E.chars[w]}return 0}(m)||m.chars[0],v=this._opt.tabSize*p.xadvance;this._fallbackSpaceGlyph=p,this._fallbackTabGlyph=r(p,{x:0,y:0,xadvance:v,id:c,xoffset:0,yoffset:0,width:0,height:0})}},u.prototype.getGlyph=function(m,p){return f(m,p)||(p===c?this._fallbackTabGlyph:p===h?this._fallbackSpaceGlyph:null)},u.prototype.computeMetrics=function(m,p,v,E){var x,M=this._opt.letterSpacing||0,w=this._opt.font,S=0,B=0,y=0;if(!w.chars||w.chars.length===0)return{start:p,end:p,width:0};v=Math.min(m.length,v);for(var _=p;_<v;_++){var L,Q=m.charCodeAt(_);if(L=this.getGlyph(w,Q)){L.xoffset;var O=(S+=x?A(w,x.id,L.id):0)+L.xadvance+M,X=S+L.width;if(X>=E||O>=E)break;S=O,B=X,x=L}y++}return x&&(B+=x.xoffset),{start:p,end:p+y,width:B}},["width","height","descender","ascender","xHeight","baseline","capHeight","lineHeight"].forEach(function(m){Object.defineProperty(u.prototype,m,{get:d(m),configurable:!0})})},5751:(n,e,t)=>{var i=t(9922).hp,r=t(3558),s=function(){},o=t(1476),a=t(7034),l=t(7480),c=t(573),h=t(4597),u=self.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest;n.exports=function(d,f){f=typeof f=="function"?f:s,typeof d=="string"?d={uri:d}:d||(d={}),d.binary&&(d=function(A){if(u)return h(A,{responseType:"arraybuffer"});if(self.XMLHttpRequest===void 0)throw new Error("your browser does not support XHR loading");var g=new self.XMLHttpRequest;return g.overrideMimeType("text/plain; charset=x-user-defined"),h({xhr:g},A)}(d)),r(d,function(A,g,m){if(A)return f(A);if(!/^2/.test(g.statusCode))return f(new Error("http status code: "+g.statusCode));if(!m)return f(new Error("no body result"));var p,v,E=!1;if(p=m,Object.prototype.toString.call(p)==="[object ArrayBuffer]"){var x=new Uint8Array(m);m=i.from(x,"binary")}c(m)&&(E=!0,typeof m=="string"&&(m=i.from(m,"binary"))),E||(i.isBuffer(m)&&(m=m.toString(d.encoding)),m=m.trim());try{var M=g.headers["content-type"];v=E?l(m):/json/.test(M)||m.charAt(0)==="{"?JSON.parse(m):/xml/.test(M)||m.charAt(0)==="<"?a(m):o(m)}catch(w){f(new Error("error parsing font "+w.message)),f=s}f(null,v)})}},573:(n,e,t)=>{var i=t(9922).hp,r=t(911),s=i.from([66,77,70,3]);n.exports=function(o){return typeof o=="string"?o.substring(0,3)==="BMF":o.length>4&&r(o.slice(0,4),s)}},9192:n=>{var e=1e3,t=60*e,i=60*t,r=24*i,s=7*r;function o(a,l,c,h){var u=l>=1.5*c;return Math.round(a/c)+" "+h+(u?"s":"")}n.exports=function(a,l){l=l||{};var c,h,u=typeof a;if(u==="string"&&a.length>0)return function(d){if(!((d=String(d)).length>100)){var f=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(d);if(f){var A=parseFloat(f[1]);switch((f[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*A;case"weeks":case"week":case"w":return A*s;case"days":case"day":case"d":return A*r;case"hours":case"hour":case"hrs":case"hr":case"h":return A*i;case"minutes":case"minute":case"mins":case"min":case"m":return A*t;case"seconds":case"second":case"secs":case"sec":case"s":return A*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return A;default:return}}}}(a);if(u==="number"&&isFinite(a))return l.long?(c=a,(h=Math.abs(c))>=r?o(c,h,r,"day"):h>=i?o(c,h,i,"hour"):h>=t?o(c,h,t,"minute"):h>=e?o(c,h,e,"second"):c+" ms"):function(d){var f=Math.abs(d);return f>=r?Math.round(d/r)+"d":f>=i?Math.round(d/i)+"h":f>=t?Math.round(d/t)+"m":f>=e?Math.round(d/e)+"s":d+"ms"}(a);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(a))}},1476:n=>{function e(i,r){if(!(i=i.replace(/\t+/g," ").trim()))return null;var s=i.indexOf(" ");if(s===-1)throw new Error("no named row at line "+r);var o=i.substring(0,s);i=(i=(i=(i=i.substring(s+1)).replace(/letter=[\'\"]\S+[\'\"]/gi,"")).split("=")).map(function(u){return u.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)});for(var a=[],l=0;l<i.length;l++){var c=i[l];l===0?a.push({key:c[0],data:""}):l===i.length-1?a[a.length-1].data=t(c[0]):(a[a.length-1].data=t(c[0]),a.push({key:c[1],data:""}))}var h={key:o,data:{}};return a.forEach(function(u){h.data[u.key]=u.data}),h}function t(i){return i&&i.length!==0?i.indexOf('"')===0||i.indexOf("'")===0?i.substring(1,i.length-1):i.indexOf(",")!==-1?function(r){return r.split(",").map(function(s){return parseInt(s,10)})}(i):parseInt(i,10):""}n.exports=function(i){if(!i)throw new Error("no data provided");var r={pages:[],chars:[],kernings:[]},s=(i=i.toString().trim()).split(/\r\n?|\n/g);if(s.length===0)throw new Error("no data in BMFont file");for(var o=0;o<s.length;o++){var a=e(s[o],o);if(a)if(a.key==="page"){if(typeof a.data.id!="number")throw new Error("malformed file at line "+o+" -- needs page id=N");if(typeof a.data.file!="string")throw new Error("malformed file at line "+o+' -- needs page file="path"');r.pages[a.data.id]=a.data.file}else a.key==="chars"||a.key==="kernings"||(a.key==="char"?r.chars.push(a.data):a.key==="kerning"?r.kernings.push(a.data):r[a.key]=a.data)}return r}},7480:n=>{var e=[66,77,70];function t(r,s,o){if(o>s.length-1)return 0;var a=s.readUInt8(o++),l=s.readInt32LE(o);switch(o+=4,a){case 1:r.info=function(c,h){var u={};u.size=c.readInt16LE(h);var d=c.readUInt8(h+2);return u.smooth=d>>7&1,u.unicode=d>>6&1,u.italic=d>>5&1,u.bold=d>>4&1,d>>3&1&&(u.fixedHeight=1),u.charset=c.readUInt8(h+3)||"",u.stretchH=c.readUInt16LE(h+4),u.aa=c.readUInt8(h+6),u.padding=[c.readInt8(h+7),c.readInt8(h+8),c.readInt8(h+9),c.readInt8(h+10)],u.spacing=[c.readInt8(h+11),c.readInt8(h+12)],u.outline=c.readUInt8(h+13),u.face=function(f,A){return i(f,A).toString("utf8")}(c,h+14),u}(s,o);break;case 2:r.common=function(c,h){var u={};return u.lineHeight=c.readUInt16LE(h),u.base=c.readUInt16LE(h+2),u.scaleW=c.readUInt16LE(h+4),u.scaleH=c.readUInt16LE(h+6),u.pages=c.readUInt16LE(h+8),c.readUInt8(h+10),u.packed=0,u.alphaChnl=c.readUInt8(h+11),u.redChnl=c.readUInt8(h+12),u.greenChnl=c.readUInt8(h+13),u.blueChnl=c.readUInt8(h+14),u}(s,o);break;case 3:r.pages=function(c,h,u){for(var d=[],f=i(c,h),A=f.length+1,g=u/A,m=0;m<g;m++)d[m]=c.slice(h,h+f.length).toString("utf8"),h+=A;return d}(s,o,l);break;case 4:r.chars=function(c,h,u){for(var d=[],f=u/20,A=0;A<f;A++){var g={},m=20*A;g.id=c.readUInt32LE(h+0+m),g.x=c.readUInt16LE(h+4+m),g.y=c.readUInt16LE(h+6+m),g.width=c.readUInt16LE(h+8+m),g.height=c.readUInt16LE(h+10+m),g.xoffset=c.readInt16LE(h+12+m),g.yoffset=c.readInt16LE(h+14+m),g.xadvance=c.readInt16LE(h+16+m),g.page=c.readUInt8(h+18+m),g.chnl=c.readUInt8(h+19+m),d[A]=g}return d}(s,o,l);break;case 5:r.kernings=function(c,h,u){for(var d=[],f=u/10,A=0;A<f;A++){var g={},m=10*A;g.first=c.readUInt32LE(h+0+m),g.second=c.readUInt32LE(h+4+m),g.amount=c.readInt16LE(h+8+m),d[A]=g}return d}(s,o,l)}return 5+l}function i(r,s){for(var o=s;o<r.length&&r[o]!==0;o++);return r.slice(s,o)}n.exports=function(r){if(r.length<6)throw new Error("invalid buffer length for BMFont");var s=e.every(function(c,h){return r.readUInt8(h)===c});if(!s)throw new Error("BMFont missing BMF byte header");var o=3;if(r.readUInt8(o++)>3)throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");for(var a={kernings:[],chars:[]},l=0;l<5;l++)o+=t(a,r,o);return a}},7034:(n,e,t)=>{var i=t(7829),r=t(1896),s={scaleh:"scaleH",scalew:"scaleW",stretchh:"stretchH",lineheight:"lineHeight",alphachnl:"alphaChnl",redchnl:"redChnl",greenchnl:"greenChnl",bluechnl:"blueChnl"};function o(a){var l=function(c){for(var h=[],u=0;u<c.attributes.length;u++)h.push(c.attributes[u]);return h}(a);return l.reduce(function(c,h){var u;return c[u=h.nodeName,s[u.toLowerCase()]||u]=h.nodeValue,c},{})}n.exports=function(a){a=a.toString();var l=r(a),c={pages:[],chars:[],kernings:[]};["info","common"].forEach(function(m){var p=l.getElementsByTagName(m)[0];p&&(c[m]=i(o(p)))});var h=l.getElementsByTagName("pages")[0];if(!h)throw new Error("malformed file -- no <pages> element");for(var u=h.getElementsByTagName("page"),d=0;d<u.length;d++){var f=u[d],A=parseInt(f.getAttribute("id"),10),g=f.getAttribute("file");if(isNaN(A))throw new Error('malformed file -- page "id" attribute is NaN');if(!g)throw new Error('malformed file -- needs page "file" attribute');c.pages[parseInt(A,10)]=g}return["chars","kernings"].forEach(function(m){var p=l.getElementsByTagName(m)[0];if(p)for(var v=m.substring(0,m.length-1),E=p.getElementsByTagName(v),x=0;x<E.length;x++){var M=E[x];c[m].push(i(o(M)))}}),c}},7829:n=>{var e="chasrset";n.exports=function(t){for(var i in t=Object.assign({},t),e in t&&(t.charset=t[e],delete t[e]),t)i!=="face"&&i!=="charset"&&(t[i]=i==="padding"||i==="spacing"?t[i].split(",").map(function(r){return parseInt(r,10)}):parseInt(t[i],10));return t}},3216:n=>{var e=function(t){return t.replace(/^\s+|\s+$/g,"")};n.exports=function(t){if(!t)return{};for(var i,r={},s=e(t).split(`
`),o=0;o<s.length;o++){var a=s[o],l=a.indexOf(":"),c=e(a.slice(0,l)).toLowerCase(),h=e(a.slice(l+1));r[c]===void 0?r[c]=h:(i=r[c],Object.prototype.toString.call(i)==="[object Array]"?r[c].push(h):r[c]=[r[c],h])}return r}},9035:(n,e,t)=>{var i=t(8480),r=t(8167),s=t(2225),o=[0,2,3],a=[2,1,3];n.exports=function(l,c){l&&(r(l)||s(l))||(c=l||{},l=null);for(var h=typeof(c=typeof c=="number"?{count:c}:c||{}).type=="string"?c.type:"uint16",u=typeof c.count=="number"?c.count:1,d=c.start||0,f=c.clockwise!==!1?o:a,A=f[0],g=f[1],m=f[2],p=6*u,v=l||new(i(h))(p),E=0,x=0;E<p;E+=6,x+=4){var M=E+d;v[M+0]=x+0,v[M+1]=x+1,v[M+2]=x+2,v[M+3]=x+A,v[M+4]=x+g,v[M+5]=x+m}return v}},4433:(n,e,t)=>{var i=t(5651),r=t(9035),s=t(7106),o=t(1684);n.exports=function(l){return new a(l)};class a extends THREE.BufferGeometry{constructor(c){super(),typeof c=="string"&&(c={text:c}),this._opt=Object.assign({},c),c&&this.update(c)}update(c){if(typeof c=="string"&&(c={text:c}),!(c=Object.assign({},this._opt,c)).font)throw new TypeError("must specify a { font } in options");this.layout=i(c);var h=c.flipY!==!1,u=c.font,d=u.common.scaleW,f=u.common.scaleH,A=this.layout.glyphs.filter(function(E){var x=E.data;return x.width*x.height>0});this.visibleGlyphs=A;var g=s.positions(A),m=s.uvs(A,d,f,h),p=r([],{clockwise:!0,type:"uint16",count:A.length});if(this.setIndex(p),this.setAttribute("position",new THREE.BufferAttribute(g,2)),this.setAttribute("uv",new THREE.BufferAttribute(m,2)),!c.multipage&&"page"in this.attributes)this.removeAttribute("page");else if(c.multipage){var v=s.pages(A);this.setAttribute("page",new THREE.BufferAttribute(v,1))}this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere()}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array,h=this.attributes.position.itemSize;if(!c||!h||c.length<2)return this.boundingSphere.radius=0,void this.boundingSphere.center.set(0,0,0);o.computeSphere(c,this.boundingSphere),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new THREE.Box3);var c=this.boundingBox,h=this.attributes.position.array,u=this.attributes.position.itemSize;!h||!u||h.length<2?c.makeEmpty():o.computeBox(h,c)}}},1684:n=>{var e={min:[0,0],max:[0,0]};function t(i){var r=i.length/2;e.min[0]=i[0],e.min[1]=i[1],e.max[0]=i[0],e.max[1]=i[1];for(var s=0;s<r;s++){var o=i[2*s+0],a=i[2*s+1];e.min[0]=Math.min(o,e.min[0]),e.min[1]=Math.min(a,e.min[1]),e.max[0]=Math.max(o,e.max[0]),e.max[1]=Math.max(a,e.max[1])}}n.exports.computeBox=function(i,r){t(i),r.min.set(e.min[0],e.min[1],0),r.max.set(e.max[0],e.max[1],0)},n.exports.computeSphere=function(i,r){t(i);var s=e.min[0],o=e.min[1],a=e.max[0]-s,l=e.max[1]-o,c=Math.sqrt(a*a+l*l);r.center.set(s+a/2,o+l/2,0),r.radius=c/2}},7106:n=>{n.exports.pages=function(e){var t=new Float32Array(4*e.length*1),i=0;return e.forEach(function(r){var s=r.data.page||0;t[i++]=s,t[i++]=s,t[i++]=s,t[i++]=s}),t},n.exports.uvs=function(e,t,i,r){var s=new Float32Array(4*e.length*2),o=0;return e.forEach(function(a){var l=a.data,c=l.x+l.width,h=l.y+l.height,u=l.x/t,d=l.y/i,f=c/t,A=h/i;r&&(d=(i-l.y)/i,A=(i-h)/i),s[o++]=u,s[o++]=d,s[o++]=u,s[o++]=A,s[o++]=f,s[o++]=A,s[o++]=f,s[o++]=d}),s},n.exports.positions=function(e){var t=new Float32Array(4*e.length*2),i=0;return e.forEach(function(r){var s=r.data,o=r.position[0]+s.xoffset,a=r.position[1]+s.yoffset,l=s.width,c=s.height;t[i++]=o,t[i++]=a,t[i++]=o,t[i++]=a+c,t[i++]=o+l,t[i++]=a+c,t[i++]=o+l,t[i++]=a}),t}},5406:n=>{var e=/\n/,t=/\s/;function i(o,a,l,c){var h=o.indexOf(a,l);return h===-1||h>c?c:h}function r(o){return t.test(o)}function s(o,a,l,c){return{start:a,end:a+Math.min(c,l-a)}}n.exports=function(o,a){return n.exports.lines(o,a).map(function(l){return o.substring(l.start,l.end)}).join(`
`)},n.exports.lines=function(o,a){if((a=a||{}).width===0&&a.mode!=="nowrap")return[];o=o||"";var l=typeof a.width=="number"?a.width:Number.MAX_VALUE,c=Math.max(0,a.start||0),h=typeof a.end=="number"?a.end:o.length,u=a.mode,d=a.measure||s;return u==="pre"?function(f,A,g,m,p){for(var v=[],E=g,x=g;x<m&&x<A.length;x++){var M=A.charAt(x),w=e.test(M);if(w||x===m-1){var S=f(A,E,w?x:x+1,p);v.push(S),E=x+1}}return v}(d,o,c,h,l):function(f,A,g,m,p,v){var E=[],x=p;for(v==="nowrap"&&(x=Number.MAX_VALUE);g<m&&g<A.length;){for(var M=i(A,`
`,g,m);g<M&&r(A.charAt(g));)g++;var w=f(A,g,M,x),S=g+(w.end-w.start),B=S+1;if(S<M){for(;S>g&&!r(A.charAt(S));)S--;if(S===g)B>g+1&&B--,S=B;else for(B=S;S>g&&r(A.charAt(S-1));)S--}if(S>=g){var y=f(A,g,S,x);E.push(y)}g=B}return E}(d,o,c,h,l,u)}},3558:(n,e,t)=>{var i=t(919),r=t(8847),s=t(3216),o=t(4597);function a(h,u,d){var f=h;return r(u)?(d=u,typeof h=="string"&&(f={uri:h})):f=o(u,{uri:h}),f.callback=d,f}function l(h,u,d){return c(u=a(h,u,d))}function c(h){if(h.callback===void 0)throw new Error("callback argument missing");var u=!1,d=function(L,Q,O){u||(u=!0,h.callback(L,Q,O))};function f(){var L=void 0;if(L=v.response?v.response:v.responseText||function(Q){try{if(Q.responseType==="document")return Q.responseXML;var O=Q.responseXML&&Q.responseXML.documentElement.nodeName==="parsererror";if(Q.responseType===""&&!O)return Q.responseXML}catch{}return null}(v),y)try{L=JSON.parse(L)}catch{}return L}function A(L){return clearTimeout(E),L instanceof Error||(L=new Error(""+(L||"Unknown XMLHttpRequest Error"))),L.statusCode=0,d(L,_)}function g(){if(!p){var L;clearTimeout(E),L=h.useXDR&&v.status===void 0?200:v.status===1223?204:v.status;var Q=_,O=null;return L!==0?(Q={body:f(),statusCode:L,method:M,headers:{},url:x,rawRequest:v},v.getAllResponseHeaders&&(Q.headers=s(v.getAllResponseHeaders()))):O=new Error("Internal XMLHttpRequest Error"),d(O,Q,Q.body)}}var m,p,v=h.xhr||null;v||(v=h.cors||h.useXDR?new l.XDomainRequest:new l.XMLHttpRequest);var E,x=v.url=h.uri||h.url,M=v.method=h.method||"GET",w=h.body||h.data,S=v.headers=h.headers||{},B=!!h.sync,y=!1,_={body:void 0,headers:{},statusCode:0,method:M,url:x,rawRequest:v};if("json"in h&&h.json!==!1&&(y=!0,S.accept||S.Accept||(S.Accept="application/json"),M!=="GET"&&M!=="HEAD"&&(S["content-type"]||S["Content-Type"]||(S["Content-Type"]="application/json"),w=JSON.stringify(h.json===!0?w:h.json))),v.onreadystatechange=function(){v.readyState===4&&setTimeout(g,0)},v.onload=g,v.onerror=A,v.onprogress=function(){},v.onabort=function(){p=!0},v.ontimeout=A,v.open(M,x,!B,h.username,h.password),B||(v.withCredentials=!!h.withCredentials),!B&&h.timeout>0&&(E=setTimeout(function(){if(!p){p=!0,v.abort("timeout");var L=new Error("XMLHttpRequest timeout");L.code="ETIMEDOUT",A(L)}},h.timeout)),v.setRequestHeader)for(m in S)S.hasOwnProperty(m)&&v.setRequestHeader(m,S[m]);else if(h.headers&&!function(L){for(var Q in L)if(L.hasOwnProperty(Q))return!1;return!0}(h.headers))throw new Error("Headers cannot be set on an XDomainRequest object");return"responseType"in h&&(v.responseType=h.responseType),"beforeSend"in h&&typeof h.beforeSend=="function"&&h.beforeSend(v),v.send(w||null),v}n.exports=l,n.exports.default=l,l.XMLHttpRequest=i.XMLHttpRequest||function(){},l.XDomainRequest="withCredentials"in new l.XMLHttpRequest?l.XMLHttpRequest:i.XDomainRequest,function(h,u){for(var d=0;d<h.length;d++)u(h[d])}(["get","put","post","patch","head","delete"],function(h){l[h==="delete"?"del":h]=function(u,d,f){return(d=a(u,d,f)).method=h.toUpperCase(),c(d)}})},1896:n=>{n.exports=self.DOMParser!==void 0?function(e){return new self.DOMParser().parseFromString(e,"application/xml")}:self.ActiveXObject!==void 0&&new self.ActiveXObject("Microsoft.XMLDOM")?function(e){var t=new self.ActiveXObject("Microsoft.XMLDOM");return t.async="false",t.loadXML(e),t}:function(e){var t=document.createElement("div");return t.innerHTML=e,t}},4597:n=>{n.exports=function(){for(var t={},i=0;i<arguments.length;i++){var r=arguments[i];for(var s in r)e.call(r,s)&&(t[s]=r[s])}return t};var e=Object.prototype.hasOwnProperty},8132:()=>{window.aframeStats=function(n){var e=null,t=n;return{update:function(){var i;e("te").set((i=t.querySelectorAll("*"),Array.prototype.slice.call(i).filter(function(r){return r.isEntity}),i.length)),window.performance.getEntriesByName&&e("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0))},start:function(){},end:function(){},attach:function(i){e=i},values:{te:{caption:"Entities"},lt:{caption:"Load Time"}},groups:[{caption:"A-Frame",values:["te","lt"]}],fractions:[]}}},3729:n=>{window.glStats=function(){var e=null,t=0,i=0,r=0,s=0,o=0,a=0,l=0;function c(h,u){return function(){u.apply(this,arguments),h.apply(this,arguments)}}return WebGLRenderingContext.prototype.drawArrays=c(WebGLRenderingContext.prototype.drawArrays,function(){t++,arguments[0]==this.POINTS?a+=arguments[2]:o+=arguments[2]}),WebGLRenderingContext.prototype.drawElements=c(WebGLRenderingContext.prototype.drawElements,function(){i++,s+=arguments[1]/3,o+=arguments[1]}),WebGLRenderingContext.prototype.useProgram=c(WebGLRenderingContext.prototype.useProgram,function(){r++}),WebGLRenderingContext.prototype.bindTexture=c(WebGLRenderingContext.prototype.bindTexture,function(){l++}),{update:function(){e("allcalls").set(t+i),e("drawElements").set(i),e("drawArrays").set(t),e("bindTexture").set(l),e("useProgram").set(r),e("glfaces").set(s),e("glvertices").set(o),e("glpoints").set(a)},start:function(){t=0,i=0,r=0,s=0,o=0,a=0,l=0},end:function(){},attach:function(h){e=h},values:{allcalls:{over:3e3,caption:"Calls (hook)"},drawelements:{caption:"drawElements (hook)"},drawarrays:{caption:"drawArrays (hook)"}},groups:[{caption:"WebGL",values:["allcalls","drawelements","drawarrays","useprogram","bindtexture","glfaces","glvertices","glpoints"]}],fractions:[{base:"allcalls",steps:["drawelements","drawarrays"]}]}},window.threeStats=function(e){var t=null;return{update:function(){var i;t("renderer.info.memory.geometries").set(e.info.memory.geometries),t("renderer.info.programs").set(((i=e.info.programs)==null?void 0:i.length)??NaN),t("renderer.info.memory.textures").set(e.info.memory.textures),t("renderer.info.render.calls").set(e.info.render.calls),t("renderer.info.render.triangles").set(e.info.render.triangles),t("renderer.info.render.points").set(e.info.render.points)},start:function(){},end:function(){},attach:function(i){t=i},values:{"renderer.info.memory.geometries":{caption:"Geometries"},"renderer.info.memory.textures":{caption:"Textures"},"renderer.info.programs":{caption:"Programs"},"renderer.info.render.calls":{caption:"Calls"},"renderer.info.render.triangles":{caption:"Triangles",over:1e3},"renderer.info.render.points":{caption:"Points"}},groups:[{caption:"Three.js - Memory",values:["renderer.info.memory.geometries","renderer.info.programs","renderer.info.memory.textures"]},{caption:"Three.js - Render",values:["renderer.info.render.calls","renderer.info.render.triangles","renderer.info.render.points"]}],fractions:[]}},window.BrowserStats=function(){var e=null,t=0,i=0;window.performance&&!performance.memory&&(performance.memory={usedJSHeapSize:0,totalJSHeapSize:0}),performance.memory.totalJSHeapSize===0&&console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");var r=Math.log(1024);function s(o){var a=Math.floor(Math.log(o)/r);return Math.round(100*o/Math.pow(1024,a))/100}return{update:function(){t=s(performance.memory.usedJSHeapSize),i=s(performance.memory.totalJSHeapSize),e("memory").set(t),e("total").set(i)},start:function(){t=0},end:function(){},attach:function(o){e=o},values:{memory:{caption:"Used Memory",average:!0,avgMs:1e3,over:22},total:{caption:"Total Memory"}},groups:[{caption:"Browser",values:["memory","total"]}],fractions:[{base:"total",steps:["memory"]}]}},n.exports={glStats:window.glStats,threeStats:window.threeStats,BrowserStats:window.BrowserStats}},282:n=>{(function(){"performance"in window==0&&(window.performance={});var e=window.performance;if("now"in e==0){var t=Date.now();e.timing&&e.timing.navigationStart&&(t=e.timing.navigationStart),e.now=function(){return Date.now()-t}}e.mark||(e.mark=function(){}),e.measure||(e.measure=function(){})})(),window.rStats=function(e){function t(g,m){for(var p=Object.keys(g),v=0,E=p.length;v<E;v++)m(p[v])}var i=e||{},r=i.colours||["#850700","#c74900","#fcb300","#284280","#4c7c0c"],s=(i.CSSPath?i.CSSPath:"")+"rStats.css";(i.css||["https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300",s]).forEach(function(g){var m,p;m=g,(p=document.createElement("link")).href=m,p.rel="stylesheet",p.type="text/css",document.getElementsByTagName("head")[0].appendChild(p)}),i.values||(i.values={});var o,a,l=10,c={};function h(g,m,p){var v=p||{},E=document.createElement("canvas"),x=E.getContext("2d"),M=0,w=0,S=v.color?v.color:"#666666",B=document.createElement("canvas"),y=B.getContext("2d");B.width=1,B.height=20,y.fillStyle="#444444",y.fillRect(0,0,1,20),y.fillStyle=S,y.fillRect(0,l,1,l),y.fillStyle="#ffffff",y.globalAlpha=.5,y.fillRect(0,l,1,1),y.globalAlpha=1;var _=document.createElement("canvas"),L=_.getContext("2d");return _.width=1,_.height=20,L.fillStyle="#444444",L.fillRect(0,0,1,20),L.fillStyle="#b70000",L.fillRect(0,l,1,l),L.globalAlpha=.5,L.fillStyle="#ffffff",L.fillRect(0,l,1,1),L.globalAlpha=1,E.width=200,E.height=l,E.style.width=E.width+"px",E.style.height=E.height+"px",E.className="rs-canvas",g.appendChild(E),x.fillStyle="#444444",x.fillRect(0,0,E.width,E.height),{draw:function(Q,O){(w+=.1*(Q-w))>(M*=.99)&&(M=w),x.drawImage(E,1,0,E.width-1,E.height,0,0,E.width-1,E.height),O?x.drawImage(_,E.width-1,E.height-w*E.height/M-l):x.drawImage(B,E.width-1,E.height-w*E.height/M-l)}}}function u(g,m){var p=document.createElement("canvas"),v=p.getContext("2d");return p.width=200,p.height=l*m,p.style.width=p.width+"px",p.style.height=p.height+"px",p.className="rs-canvas",g.appendChild(p),v.fillStyle="#444444",v.fillRect(0,0,p.width,p.height),{draw:function(E){v.drawImage(p,1,0,p.width-1,p.height,0,0,p.width-1,p.height);var x=0;t(E,function(M){var w=E[M]*p.height;v.fillStyle=r[M],v.fillRect(p.width-1,x,1,w),x+=w})}}}function d(g,m){var p,v=g,E=0,x=0,M=0,w=0,S=performance.now(),B=0,y=document.createElement("div"),_=document.createElement("span"),L=document.createElement("div"),Q=document.createTextNode(""),O=i.values[v.toLowerCase()],X=new h(y,v,O),te=!1;function W(re){if(O&&O.average){w+=re,B++;var ue=performance.now();ue-S>=(O.avgMs||1e3)&&(M=w/B,w=0,S=ue,B=0)}}function Z(){p=performance.now(),i.userTimingAPI&&performance.mark(v+"-start"),te=!0}function q(){E=performance.now()-p,i.userTimingAPI&&(performance.mark(v+"-end"),te&&performance.measure(v,v+"-start",v+"-end")),W(E)}return _.className="rs-counter-id",_.textContent=O&&O.caption?O.caption:v,L.className="rs-counter-value",L.appendChild(Q),y.appendChild(_),y.appendChild(L),m?m.div.appendChild(y):a.appendChild(y),p=performance.now(),{set:function(re){W(E=re)},start:Z,tick:function(){q(),Z()},end:q,frame:function(){var re=performance.now(),ue=re-p;x++,ue>1e3&&(E=O&&O.interpolate===!1?x:1e3*x/ue,x=0,p=re,W(E))},value:function(){return E},draw:function(){var re=O&&O.average?M:E;Q.nodeValue=Math.round(100*re)/100;var ue=O&&(O.below&&E<O.below||O.over&&E>O.over);X.draw(E,ue),y.className=ue?"rs-counter-base alarm":"rs-counter-base"}}}function f(g){var m=g.toLowerCase();if(m===void 0&&(m="default"),c[m])return c[m];var p=null;i.groups&&t(i.groups,function(E){var x=i.groups[parseInt(E,10)];p||x.values.indexOf(m.toLowerCase())===-1||(p=x)});var v=new d(m,p);return c[m]=v,v}function A(){t(i.plugins,function(g){i.plugins[g].update()}),t(c,function(g){c[g].draw()}),i.fractions&&t(i.fractions,function(g){var m=i.fractions[parseInt(g,10)],p=[],v=c[m.base.toLowerCase()];v&&(v=v.value(),t(i.fractions[g].steps,function(E){var x=i.fractions[g].steps[parseInt(E,10)].toLowerCase(),M=c[x];M&&p.push(M.value()/v)})),m.graph.draw(p)})}return function(){if(i.plugins){i.values||(i.values={}),i.groups||(i.groups=[]),i.fractions||(i.fractions=[]);for(var g=0;g<i.plugins.length;g++)i.plugins[g].attach(f),t(i.plugins[g].values,function(m){i.values[m]=i.plugins[g].values[m]}),i.groups=i.groups.concat(i.plugins[g].groups),i.fractions=i.fractions.concat(i.plugins[g].fractions)}else i.plugins={};(o=document.createElement("div")).className="rs-base",(a=document.createElement("div")).className="rs-container",a.style.height="auto",o.appendChild(a),document.body.appendChild(o),i.groups&&t(i.groups,function(m){var p=i.groups[parseInt(m,10)],v=document.createElement("div");v.className="rs-group",p.div=v;var E=document.createElement("h1");E.textContent=p.caption,E.addEventListener("click",(function(x){this.classList.toggle("hidden"),x.preventDefault()}).bind(v)),a.appendChild(E),a.appendChild(v)}),i.fractions&&t(i.fractions,function(m){var p=i.fractions[parseInt(m,10)],v=document.createElement("div");v.className="rs-fraction";var E=document.createElement("div");E.className="rs-legend";var x=0;t(i.fractions[m].steps,function(w){var S=document.createElement("p");S.textContent=i.fractions[m].steps[w],S.style.color=r[x],E.appendChild(S),x++}),v.appendChild(E),v.style.height=x*l+"px",p.div=v;var M=new u(v,x);p.graph=M,a.appendChild(v)})}(),function(g){return g?f(g):{element:o,update:A}}},n.exports=window.rStats},2535:n=>{var e={base64:function(t,i){return"data:"+t+";base64,"+i},isMobile:function(){var t,i=!1;return t=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)))&&(i=!0),i},isIOS:function(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)},isIFrame:function(){try{return window.self!==window.top}catch{return!0}},appendQueryParameter:function(t,i,r){var s=t.indexOf("?")<0?"?":"&";return t+(s+i+"=")+r},getQueryParameter:function(t){t=t.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var i=new RegExp("[\\?&]"+t+"=([^&#]*)").exec(location.search);return i===null?"":decodeURIComponent(i[1].replace(/\+/g," "))},isLandscapeMode:function(){return window.orientation==90||window.orientation==-90}};n.exports=e},5928:(n,e,t)=>{var i,r=t(2535);n.exports=(i=navigator.userAgent||navigator.vendor||window.opera).match(/iPhone/i)||i.match(/iPod/i)?function(){var s=null;this.request=function(){s||(s=setInterval(function(){window.location.href="/",setTimeout(window.stop,0)},15e3))},this.release=function(){s&&(clearInterval(s),s=null)}}:function(){var s=document.createElement("video");s.addEventListener("ended",function(){s.play()}),this.request=function(){s.paused&&(s.src=r.base64("video/webm","GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="),s.play())},this.release=function(){s.pause(),s.src=""}}},8217:(n,e,t)=>{t.d(e,{A:()=>x});var i=t(963),r=t.n(i),s=t(9089),o=t.n(s),a=t(6492),l=t.n(a),c=new URL(t(9169),t.b),h=new URL(t(6085),t.b),u=new URL(t(3931),t.b),d=new URL(t(7889),t.b),f=new URL(t(6517),t.b),A=o()(r()),g=l()(c),m=l()(h),p=l()(u),v=l()(d),E=l()(f);A.push([n.id,`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url(${g}) 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url(${m}) 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url(${p});
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(${v}) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(${E}) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`,"",{version:3,sources:["webpack://./src/style/aframe.css"],names:[],mappings:"AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB",sourcesContent:[`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E");
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`],sourceRoot:""}]);const x=A},2470:(n,e,t)=>{t.d(e,{A:()=>a});var i=t(963),r=t.n(i),s=t(9089),o=t.n(s)()(r());o.push([n.id,`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`,"",{version:3,sources:["webpack://./src/style/rStats.css"],names:[],mappings:"AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF",sourcesContent:[`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`],sourceRoot:""}]);const a=o},7180:(n,e,t)=>{t.r(e),t.d(e,{default:()=>p});var i=t(5072),r=t.n(i),s=t(7825),o=t.n(s),a=t(7659),l=t.n(a),c=t(5056),h=t.n(c),u=t(540),d=t.n(u),f=t(1113),A=t.n(f),g=t(8217),m={};m.styleTagTransform=A(),m.setAttributes=h(),m.insert=l().bind(null,"head"),m.domAPI=o(),m.insertStyleElement=d(),r()(g.A,m);const p=g.A&&g.A.locals?g.A.locals:void 0},9379:(n,e,t)=>{t.r(e),t.d(e,{default:()=>p});var i=t(5072),r=t.n(i),s=t(7825),o=t.n(s),a=t(7659),l=t.n(a),c=t(5056),h=t.n(c),u=t(540),d=t.n(u),f=t(1113),A=t.n(f),g=t(2470),m={};m.styleTagTransform=A(),m.setAttributes=h(),m.insert=l().bind(null,"head"),m.domAPI=o(),m.insertStyleElement=d(),r()(g.A,m);const p=g.A&&g.A.locals?g.A.locals:void 0},5072:n=>{var e=[];function t(s){for(var o=-1,a=0;a<e.length;a++)if(e[a].identifier===s){o=a;break}return o}function i(s,o){for(var a={},l=[],c=0;c<s.length;c++){var h=s[c],u=o.base?h[0]+o.base:h[0],d=a[u]||0,f="".concat(u," ").concat(d);a[u]=d+1;var A=t(f),g={css:h[1],media:h[2],sourceMap:h[3],supports:h[4],layer:h[5]};if(A!==-1)e[A].references++,e[A].updater(g);else{var m=r(g,o);o.byIndex=c,e.splice(c,0,{identifier:f,updater:m,references:1})}l.push(f)}return l}function r(s,o){var a=o.domAPI(o);return a.update(s),function(l){if(l){if(l.css===s.css&&l.media===s.media&&l.sourceMap===s.sourceMap&&l.supports===s.supports&&l.layer===s.layer)return;a.update(s=l)}else a.remove()}}n.exports=function(s,o){var a=i(s=s||[],o=o||{});return function(l){l=l||[];for(var c=0;c<a.length;c++){var h=t(a[c]);e[h].references--}for(var u=i(l,o),d=0;d<a.length;d++){var f=t(a[d]);e[f].references===0&&(e[f].updater(),e.splice(f,1))}a=u}}},7659:n=>{var e={};n.exports=function(t,i){var r=function(s){if(e[s]===void 0){var o=document.querySelector(s);if(window.HTMLIFrameElement&&o instanceof window.HTMLIFrameElement)try{o=o.contentDocument.head}catch{o=null}e[s]=o}return e[s]}(t);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(i)}},540:n=>{n.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},5056:(n,e,t)=>{n.exports=function(i){var r=t.nc;r&&i.setAttribute("nonce",r)}},7825:n=>{n.exports=function(e){if(typeof document>"u")return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(i){(function(r,s,o){var a="";o.supports&&(a+="@supports (".concat(o.supports,") {")),o.media&&(a+="@media ".concat(o.media," {"));var l=o.layer!==void 0;l&&(a+="@layer".concat(o.layer.length>0?" ".concat(o.layer):""," {")),a+=o.css,l&&(a+="}"),o.media&&(a+="}"),o.supports&&(a+="}");var c=o.sourceMap;c&&typeof btoa<"u"&&(a+=`
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(c))))," */")),s.styleTagTransform(a,r,s.options)})(t,e,i)},remove:function(){(function(i){if(i.parentNode===null)return!1;i.parentNode.removeChild(i)})(t)}}}},1113:n=>{n.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},3931:n=>{n.exports="data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"},6085:n=>{n.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},9169:n=>{n.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},6517:n=>{n.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"},7889:n=>{n.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"}},nx={};function nt(n){var e=nx[n];if(e!==void 0)return e.exports;var t=nx[n]={id:n,exports:{}};return AM[n](t,t.exports,nt),t.exports}nt.m=AM,nt.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return nt.d(e,{a:e}),e},nt.d=(n,e)=>{for(var t in e)nt.o(e,t)&&!nt.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},nt.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),nt.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),nt.r=n=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},nt.b=document.baseURI||self.location.href,nt.nc=void 0;var gM={};nt.d(gM,{A:()=>a3});var IA={};nt.r(IA),nt.d(IA,{computeMikkTSpaceTangents:()=>iP,computeMorphedAttributes:()=>hP,deepCloneAttribute:()=>sP,deinterleaveAttribute:()=>Hd,deinterleaveGeometry:()=>aP,estimateBytesUsed:()=>lP,interleaveAttributes:()=>oP,mergeAttributes:()=>VA,mergeGeometries:()=>rP,mergeGroups:()=>uP,mergeVertices:()=>cP,toCreasedNormals:()=>dP,toTrianglesDrawMode:()=>QA});var RA={};nt.r(RA),nt.d(RA,{checkARSupport:()=>V0,checkHeadsetConnected:()=>H0,checkVRSupport:()=>YA,isAppleVisionPro:()=>nS,isBrowserEnvironment:()=>Y0,isFirefoxReality:()=>iS,isIOS:()=>Hc,isIpad:()=>tS,isLandscape:()=>rS,isMobile:()=>Ms,isMobileDeviceRequestingDesktopSite:()=>Q0,isMobileVR:()=>X0,isNodeEnvironment:()=>oU,isOculusBrowser:()=>W0,isR7:()=>q0,isTablet:()=>eS,isWebXRAvailable:()=>Hf});var BA={};nt.r(BA),nt.d(BA,{clearObject:()=>$0,createPool:()=>j0,removeUnusedKeys:()=>_c});var LA={};nt.r(LA),nt.d(LA,{equals:()=>Vu,isCoordinate:()=>uU,isCoordinates:()=>oS,parse:()=>Xd,regex:()=>sS,stringify:()=>Hu,toVector3:()=>dU});var DA={};nt.r(DA),nt.d(DA,{getComponentProperty:()=>aS,getComponentPropertyPath:()=>Vf,setComponentProperty:()=>K0});var PA={};nt.r(PA),nt.d(PA,{parseUrl:()=>jA,validateCubemapSrc:()=>cS,validateEnvMapSrc:()=>J0,validateSrc:()=>qd});var UA={};nt.r(UA),nt.d(UA,{createCompatibleTexture:()=>ev,handleTextureEvents:()=>Z0,isCompatibleTexture:()=>hS,setTextureProperties:()=>Yd,updateDistortionMap:()=>Vi,updateEnvMap:()=>$A,updateMap:()=>Wu,updateMapMaterialFromData:()=>Qf});var $a={};nt.r($a),nt.d($a,{parse:()=>bc,stringify:()=>AU,toCamelCase:()=>uS});var FA={};nt.r(FA),nt.d(FA,{checkControllerPresentAndSetup:()=>si,emitIfAxesChanged:()=>vi,findMatchingControllerWebXR:()=>tv,isControllerPresentWebXR:()=>dS,onButtonEvent:()=>dt});var NA={};nt.r(NA),nt.d(NA,{bind:()=>xU,checkHeadsetConnected:()=>yU,clone:()=>iv,coordinates:()=>LA,debounce:()=>pS,debug:()=>Bt,deepEqual:()=>rv,device:()=>RA,diff:()=>mS,entity:()=>DA,extend:()=>qn,extendDeep:()=>ti,findAllScenes:()=>gS,forceCanvasResizeSafariMobile:()=>lS,getElData:()=>wU,getUrlParameter:()=>Cc,isIOS:()=>_U,isIframed:()=>AS,isMobile:()=>bU,material:()=>UA,objectPool:()=>BA,shouldCaptureKeyEvent:()=>sv,split:()=>Fr,splitString:()=>SU,srcLoader:()=>PA,styleParser:()=>$a,throttle:()=>CU,throttleLeadingAndTrailing:()=>fS,throttleTick:()=>MU,trackedControls:()=>FA});var OA={};nt.r(OA),nt.d(OA,{isSingleProperty:()=>Wf,parseProperties:()=>yS,parseProperty:()=>Xf,process:()=>Vc,processPropertyDefinition:()=>JA,stringifyProperties:()=>_S,stringifyProperty:()=>ov});var ix={};nt.r(ix),nt.d(ix,{Component:()=>Mc,components:()=>Yt,registerComponent:()=>tt,registrationOrderWarnings:()=>MS});var rx={};nt.r(rx),nt.d(rx,{System:()=>Jd,registerSystem:()=>gi,systems:()=>wr});var vM={update:null,begin:null,loopBegin:null,changeBegin:null,change:null,changeComplete:null,loopComplete:null,complete:null,loop:1,direction:"normal",autoplay:!0,timelineOffset:0},D0={duration:1e3,delay:0,endDelay:0,easing:"easeOutElastic(1, .5)",round:0},FD=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective"],kd={CSS:{},springs:{}};function Sr(n,e,t){return Math.min(Math.max(n,e),t)}function zl(n,e){return n.indexOf(e)>-1}function zh(n,e){return n.apply(null,e)}var ND=/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,OD=/^rgb/,kD=/^hsl/,ot={arr:function(n){return Array.isArray(n)},obj:function(n){return zl(Object.prototype.toString.call(n),"Object")},pth:function(n){return ot.obj(n)&&n.hasOwnProperty("totalLength")},svg:function(n){return n instanceof SVGElement},inp:function(n){return n instanceof HTMLInputElement},dom:function(n){return n.nodeType||ot.svg(n)},str:function(n){return typeof n=="string"},fnc:function(n){return typeof n=="function"},und:function(n){return n===void 0},hex:function(n){return ND.test(n)},rgb:function(n){return OD.test(n)},hsl:function(n){return kD.test(n)},col:function(n){return ot.hex(n)||ot.rgb(n)||ot.hsl(n)},key:function(n){return!vM.hasOwnProperty(n)&&!D0.hasOwnProperty(n)&&n!=="targets"&&n!=="keyframes"}},GD=/\(([^)]+)\)/;function EM(n){var e=GD.exec(n);return e?e[1].split(",").map(function(t){return parseFloat(t)}):[]}function xM(n,e){var t=EM(n),i=Sr(ot.und(t[0])?1:t[0],.1,100),r=Sr(ot.und(t[1])?100:t[1],.1,100),s=Sr(ot.und(t[2])?10:t[2],.1,100),o=Sr(ot.und(t[3])?0:t[3],.1,100),a=Math.sqrt(r/i),l=s/(2*Math.sqrt(r*i)),c=l<1?a*Math.sqrt(1-l*l):0,h=l<1?(l*a-o)/c:-o+a;function u(d){var f=e?e*d/1e3:d;return f=l<1?Math.exp(-f*l*a)*(1*Math.cos(c*f)+h*Math.sin(c*f)):(1+h*f)*Math.exp(-f*a),d===0||d===1?d:1-f}return e?u:function(){var d=kd.springs[n];if(d)return d;for(var f=1/6,A=0,g=0;;)if(u(A+=f)===1){if(++g>=16)break}else g=0;var m=A*f*1e3;return kd.springs[n]=m,m}}function Hh(n,e){n===void 0&&(n=1),e===void 0&&(e=.5);var t=Sr(n,1,10),i=Sr(e,.1,2);return function(r){return r===0||r===1?r:-t*Math.pow(2,10*(r-1))*Math.sin((r-1-i/(2*Math.PI)*Math.asin(1/t))*(2*Math.PI)/i)}}function zD(n){return n===void 0&&(n=10),function(e){return Math.round(e*n)*(1/n)}}var sx=function(){var n=.1;function e(o,a){return 1-3*a+3*o}function t(o,a){return 3*a-6*o}function i(o){return 3*o}function r(o,a,l){return((e(a,l)*o+t(a,l))*o+i(a))*o}function s(o,a,l){return 3*e(a,l)*o*o+2*t(a,l)*o+i(a)}return function(o,a,l,c){if(0<=o&&o<=1&&0<=l&&l<=1){var h=new Float32Array(11);if(o!==a||l!==c)for(var u=0;u<11;++u)h[u]=r(u*n,o,l);return function(d){return o===a&&l===c||d===0||d===1?d:r(function(f){for(var A=0,g=1;g!==10&&h[g]<=f;++g)A+=n;--g;var m=A+(f-h[g])/(h[g+1]-h[g])*n,p=s(m,o,l);return p>=.001?function(v,E,x,M){for(var w=0;w<4;++w){var S=s(E,x,M);if(S===0)return E;E-=(r(E,x,M)-v)/S}return E}(f,m,o,l):p===0?m:function(v,E,x,M,w){var S,B,y=0;do(S=r(B=E+(x-E)/2,M,w)-v)>0?x=B:E=B;while(Math.abs(S)>1e-7&&++y<10);return B}(f,A,A+n,o,l)}(d),a,c)}}}}(),yM=function(){var n=["Quad","Cubic","Quart","Quint","Sine","Expo","Circ","Back","Elastic"],e={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],Hh],Out:[[.25,.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(o,a){return function(l){return 1-Hh(o,a)(1-l)}}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(o,a){return function(l){return l<.5?Hh(o,a)(2*l)/2:1-Hh(o,a)(-2*l+2)/2}}]},t={linear:[.25,.25,.75,.75]};for(var i in e)for(var r=0,s=e[i].length;r<s;r++)t["ease"+i+n[r]]=e[i][r];return t}();function kA(n,e){if(ot.fnc(n))return n;var t=n.split("(")[0],i=yM[t],r=EM(n);switch(t){case"spring":return xM(n,e);case"cubicBezier":return zh(sx,r);case"steps":return zh(zD,r);default:return ot.fnc(i)?zh(i,r):zh(sx,i)}}function _M(n){try{return document.querySelectorAll(n)}catch{return}}var ox=[];function Gd(n,e){for(var t=ox,i=n.length,r=arguments.length>=2?arguments[1]:void 0,s=0;s<i;s++)if(s in n){var o=n[s];e.call(r,o,s,n)&&t.push(o)}return(ox=n).length=0,t}function zf(n,e){e||(e=[]);for(var t=0,i=n.length;t<i;t++){var r=n[t];Array.isArray(r)?zf(r,e):e.push(r)}return e}function ax(n){return ot.arr(n)?n:(ot.str(n)&&(n=_M(n)||n),n instanceof NodeList||n instanceof HTMLCollection?[].slice.call(n):[n])}function P0(n,e){return n.some(function(t){return t===e})}function U0(n){var e={};for(var t in n)e[t]=n[t];return e}function GA(n,e){var t=U0(n);for(var i in n)t[i]=e.hasOwnProperty(i)?e[i]:n[i];return t}function zd(n,e){var t=U0(n);for(var i in e)t[i]=ot.und(n[i])?e[i]:n[i];return t}var HD=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g,VD=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,QD=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,WD=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g,XD=/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g,qD=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;function Ur(n){var e=qD.exec(n);if(e)return e[2]}function zA(n,e){return ot.fnc(n)?n(e.target,e.id,e.total):n}function Wi(n,e){return n.getAttribute(e)}function F0(n,e,t){if(P0([t,"deg","rad","turn"],Ur(e)))return e;var i=kd.CSS[e+t];if(!ot.und(i))return i;var r=document.createElement(n.tagName),s=n.parentNode&&n.parentNode!==document?n.parentNode:document.body;s.appendChild(r),r.style.position="absolute",r.style.width=100+t;var o=100/r.offsetWidth;s.removeChild(r);var a=o*parseFloat(e);return kd.CSS[e+t]=a,a}function bM(n,e,t){if(e in n.style){var i=e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),r=n.style[e]||getComputedStyle(n).getPropertyValue(i)||"0";return t?F0(n,r,t):r}}function N0(n,e){return ot.dom(n)&&!ot.inp(n)&&(Wi(n,e)||ot.svg(n)&&n[e])?"attribute":ot.dom(n)&&P0(FD,e)?"transform":ot.dom(n)&&e!=="transform"&&bM(n,e)?"css":n[e]!=null?"object":void 0}var YD=/(\w+)\(([^)]*)\)/g;function CM(n){if(ot.dom(n)){for(var e,t=n.style.transform||"",i=new Map;e=YD.exec(t);)i.set(e[1],e[2]);return i}}function O0(n,e,t,i){switch(N0(n,e)){case"transform":return function(r,s,o,a){var l=zl(s,"scale")?1:0+function(h){return zl(h,"translate")||h==="perspective"?"px":zl(h,"rotate")||zl(h,"skew")?"deg":void 0}(s),c=CM(r).get(s)||l;return o&&(o.transforms.list.set(s,c),o.transforms.last=s),a?F0(r,c,a):c}(n,e,i,t);case"css":return bM(n,e,t);case"attribute":return Wi(n,e);default:return n[e]||0}}var jD=/^(\*=|\+=|-=)/;function k0(n,e){var t=jD.exec(n);if(!t)return n;var i=Ur(n)||0,r=parseFloat(e),s=parseFloat(n.replace(t[0],""));switch(t[0][0]){case"+":return r+s+i;case"-":return r-s+i;case"*":return r*s+i}}var $D=/\s/g;function MM(n,e){if(ot.col(n))return function(r){return ot.rgb(r)?(s=r,(o=HD.exec(s))?"rgba("+o[1]+",1)":s):ot.hex(r)?function(a){var l=a.replace(VD,function(h,u,d,f){return u+u+d+d+f+f}),c=QD.exec(l);return"rgba("+parseInt(c[1],16)+","+parseInt(c[2],16)+","+parseInt(c[3],16)+",1)"}(r):ot.hsl(r)?function(a){var l,c,h,u=WD.exec(a)||XD.exec(a),d=parseInt(u[1],10)/360,f=parseInt(u[2],10)/100,A=parseInt(u[3],10)/100,g=u[4]||1;function m(E,x,M){return M<0&&(M+=1),M>1&&(M-=1),M<1/6?E+6*(x-E)*M:M<.5?x:M<2/3?E+(x-E)*(2/3-M)*6:E}if(f==0)l=c=h=A;else{var p=A<.5?A*(1+f):A+f-A*f,v=2*A-p;l=m(v,p,d+1/3),c=m(v,p,d),h=m(v,p,d-1/3)}return"rgba("+255*l+","+255*c+","+255*h+","+g+")"}(r):void 0;var s,o}(n);var t=Ur(n),i=t?n.substr(0,n.length-t.length):n;return e&&!$D.test(n)?i+e:i}function HA(n,e){return Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2))}function lx(n){for(var e,t=n.points,i=0,r=0;r<t.numberOfItems;r++){var s=t.getItem(r);r>0&&(i+=HA(e,s)),e=s}return i}function cx(n){if(n.getTotalLength)return n.getTotalLength();switch(n.tagName.toLowerCase()){case"circle":return function(e){return 2*Math.PI*Wi(e,"r")}(n);case"rect":return function(e){return 2*Wi(e,"width")+2*Wi(e,"height")}(n);case"line":return function(e){return HA({x:Wi(e,"x1"),y:Wi(e,"y1")},{x:Wi(e,"x2"),y:Wi(e,"y2")})}(n);case"polyline":return lx(n);case"polygon":return function(e){var t=e.points;return lx(e)+HA(t.getItem(t.numberOfItems-1),t.getItem(0))}(n)}}function SM(n,e){var t=e||{},i=t.el||function(c){for(var h=c.parentNode;ot.svg(h)&&(h=h.parentNode,ot.svg(h.parentNode)););return h}(n),r=i.getBoundingClientRect(),s=Wi(i,"viewBox"),o=r.width,a=r.height,l=t.viewBox||(s?s.split(" "):[0,0,o,a]);return{el:i,viewBox:l,x:l[0]/1,y:l[1]/1,w:o/l[2],h:a/l[3]}}function KD(n,e){function t(a){a===void 0&&(a=0);var l=e+a>=1?e+a:0;return n.el.getPointAtLength(l)}var i=SM(n.el,n.svg),r=t(),s=t(-1),o=t(1);switch(n.property){case"x":return(r.x-i.x)*i.w;case"y":return(r.y-i.y)*i.h;case"angle":return 180*Math.atan2(o.y-s.y,o.x-s.x)/Math.PI}}var Hp=/-?\d*\.?\d+/g;function hx(n,e){var t=MM(ot.pth(n)?n.totalLength:n,e)+"";return{original:t,numbers:t.match(Hp)?t.match(Hp).map(Number):[0],strings:ot.str(n)||e?t.split(Hp):[]}}function wM(n){return Gd(n?zf(ot.arr(n)?n.map(ax):ax(n)):[],function(e,t,i){return i.indexOf(e)===t})}function TM(n){var e=wM(n);return e.map(function(t,i){return{target:t,id:i,total:e.length,transforms:{list:CM(t)}}})}var JD=/^spring/;function ZD(n,e){var t=U0(e);if(JD.test(t.easing)&&(t.duration=xM(t.easing)),ot.arr(n)){var i=n.length;i!==2||ot.obj(n[0])?ot.fnc(e.duration)||(t.duration=e.duration/i):n={value:n}}var r=ot.arr(n)?n:[n];return r.map(function(s,o){var a=ot.obj(s)&&!ot.pth(s)?s:{value:s};return ot.und(a.delay)&&(a.delay=o?0:e.delay),ot.und(a.endDelay)&&(a.endDelay=o===r.length-1?e.endDelay:0),a}).map(function(s){return zd(s,t)})}var IM={css:function(n,e,t){return n.style[e]=t},attribute:function(n,e,t){return n.setAttribute(e,t)},object:function(n,e,t){return n[e]=t},transform:function(n,e,t,i,r){if(i.list.set(e,t),e===i.last||r){var s="";i.list.forEach(function(o,a){s+=a+"("+o+") "}),n.style.transform=s}}};function RM(n,e){for(var t=TM(n),i=0,r=t.length;i<r;i++){var s=t[i];for(var o in e){var a=zA(e[o],s),l=s.target,c=Ur(a),h=O0(l,o,c,s),u=k0(MM(a,c||Ur(h)),h),d=N0(l,o);IM[d](l,o,u,s.transforms,!0)}}}function eP(n,e){return Gd(zf(n.map(function(t){return e.map(function(i){return function(r,s){var o=N0(r.target,s.name);if(o){var a=function(c,h){var u;return c.tweens.map(function(d){var f=function(w,S){var B={};for(var y in w){var _=zA(w[y],S);ot.arr(_)&&(_=_.map(function(L){return zA(L,S)})).length===1&&(_=_[0]),B[y]=_}return B.duration=parseFloat(B.duration),B.delay=parseFloat(B.delay),B}(d,h),A=f.value,g=ot.arr(A)?A[1]:A,m=Ur(g),p=O0(h.target,c.name,m,h),v=u?u.to.original:p,E=ot.arr(A)?A[0]:v,x=Ur(E)||Ur(p),M=m||x;return ot.und(g)&&(g=v),f.from=hx(E,M),f.to=hx(k0(g,E),M),f.start=u?u.end:0,f.end=f.start+f.delay+f.duration+f.endDelay,f.easing=kA(f.easing,f.duration),f.isPath=ot.pth(A),f.isColor=ot.col(f.from.original),f.isColor&&(f.round=1),u=f,f})}(s,r),l=a[a.length-1];return{type:o,property:s.name,animatable:r,tweens:a,duration:l.end,delay:a[0].delay,endDelay:l.endDelay}}}(t,i)})})),function(t){return!ot.und(t)})}function BM(n,e){var t=n.length,i=function(s){return s.timelineOffset?s.timelineOffset:0},r={};return r.duration=t?Math.max.apply(Math,n.map(function(s){return i(s)+s.duration})):e.duration,r.delay=t?Math.min.apply(Math,n.map(function(s){return i(s)+s.delay})):e.delay,r.endDelay=t?r.duration-Math.max.apply(Math,n.map(function(s){return i(s)+s.duration-s.endDelay})):e.endDelay,r}var Gu,ux=0,Wn=[],Vp=[],tP=function(){function n(){Gu=requestAnimationFrame(e)}function e(t){var i=Wn.length;if(i){for(var r=0;r<i;){var s=Wn[r];if(s.paused){var o=Wn.indexOf(s);o>-1&&(Wn.splice(o,1),i=Wn.length)}else s.tick(t);r++}n()}else Gu=cancelAnimationFrame(Gu)}return n}();function sn(n){n===void 0&&(n={});var e,t=0,i=0,r=0,s=0,o=null;function a(){return window.Promise&&new Promise(function(p){return o=p})}var l=a(),c=function(p){var v=GA(vM,p),E=GA(D0,p),x=function(y,_){var L=[],Q=_.keyframes;for(var O in Q&&(_=zd(function(X){for(var te=Gd(zf(X.map(function(re){return Object.keys(re)})),function(re){return ot.key(re)}).reduce(function(re,ue){return re.indexOf(ue)<0&&re.push(ue),re},[]),W={},Z=function(re){var ue=te[re];W[ue]=X.map(function(_e){var Be={};for(var ze in _e)ot.key(ze)?ze==ue&&(Be.value=_e[ze]):Be[ze]=_e[ze];return Be})},q=0;q<te.length;q++)Z(q);return W}(Q),_)),_)ot.key(O)&&L.push({name:O,tweens:ZD(_[O],y)});return L}(E,p),M=TM(p.targets),w=eP(M,x),S=BM(w,E),B=ux;return ux++,zd(v,{id:B,children:[],animatables:M,animations:w,duration:S.duration,delay:S.delay,endDelay:S.endDelay})}(n);function h(){c.reversed=!c.reversed;for(var p=0,v=e.length;p<v;p++)e[p].reversed=c.reversed}function u(p){return c.reversed?c.duration-p:p}function d(){t=0,i=u(c.currentTime)*(1/sn.speed)}function f(p,v){v&&v.seek(p-v.timelineOffset)}function A(p){for(var v=0,E=c.animations,x=E.length;v<x;){var M=E[v],w=M.animatable,S=M.tweens,B=S.length-1,y=S[B];B&&(y=Gd(S,function(Ee){return p<Ee.end})[0]||y);for(var _=Sr(p-y.start-y.delay,0,y.duration)/y.duration,L=isNaN(_)?1:y.easing(_),Q=y.to.strings,O=y.round,X=[],te=y.to.numbers.length,W=void 0,Z=0;Z<te;Z++){var q=void 0,re=y.to.numbers[Z],ue=y.from.numbers[Z]||0;q=y.isPath?KD(y.value,L*re):ue+L*(re-ue),O&&(y.isColor&&Z>2||(q=Math.round(q*O)/O)),X.push(q)}var _e=Q.length;if(_e){W=Q[0];for(var Be=0;Be<_e;Be++){Q[Be];var ze=Q[Be+1],le=X[Be];isNaN(le)||(W+=ze?le+ze:le+" ")}}else W=X[0];IM[M.type](w.target,M.property,W,w.transforms),M.currentValue=W,v++}}function g(p){c[p]&&!c.passThrough&&c[p](c)}function m(p){var v=c.duration,E=c.delay,x=v-c.endDelay,M=u(p);c.progress=Sr(M/v*100,0,100),c.reversePlayback=M<c.currentTime,e&&function(w){if(c.reversePlayback)for(var S=s;S--;)f(w,e[S]);else for(var B=0;B<s;B++)f(w,e[B])}(M),!c.began&&c.currentTime>0&&(c.began=!0,g("begin"),g("loopBegin")),M<=E&&c.currentTime!==0&&A(0),(M>=x&&c.currentTime!==v||!v)&&A(v),M>E&&M<x?(c.changeBegan||(c.changeBegan=!0,c.changeCompleted=!1,g("changeBegin")),g("change"),A(M)):c.changeBegan&&(c.changeCompleted=!0,c.changeBegan=!1,g("changeComplete")),c.currentTime=Sr(M,0,v),c.began&&g("update"),p>=v&&(i=0,c.remaining&&c.remaining!==!0&&c.remaining--,c.remaining?(t=r,g("loopComplete"),g("loopBegin"),c.direction==="alternate"&&h()):(c.paused=!0,c.completed||(c.completed=!0,g("loopComplete"),g("complete"),"Promise"in window&&(o(),l=a()))))}return c.reset=function(){var p=c.direction;c.passThrough=!1,c.currentTime=0,c.progress=0,c.paused=!0,c.began=!1,c.changeBegan=!1,c.completed=!1,c.changeCompleted=!1,c.reversePlayback=!1,c.reversed=p==="reverse",c.remaining=c.loop,e=c.children;for(var v=s=e.length;v--;)c.children[v].reset();(c.reversed&&c.loop!==!0||p==="alternate"&&c.loop===1)&&c.remaining++,A(0)},c.set=function(p,v){return RM(p,v),c},c.tick=function(p){r=p,t||(t=r),m((r+(i-t))*sn.speed)},c.seek=function(p){m(u(p))},c.pause=function(){c.paused=!0,d()},c.play=function(){c.paused&&(c.paused=!1,Wn.push(c),d(),Gu||tP())},c.reverse=function(){h(),d()},c.restart=function(){c.reset(),c.play()},c.finished=l,c.reset(),c.autoplay&&c.play(),c}function dx(n,e){for(var t=e.length;t--;)P0(n,e[t].animatable.target)&&e.splice(t,1)}document.addEventListener("visibilitychange",function(){if(document.hidden){for(var n=0,e=Wn.length;n<e;n++)activeInstance[n].pause();Vp=Wn.slice(0),Wn=[]}else for(var t=0,i=Vp.length;t<i;t++)Vp[t].play()}),sn.version="3.0.0",sn.speed=1,sn.running=Wn,sn.remove=function(n){for(var e=wM(n),t=Wn.length;t--;){var i=Wn[t],r=i.animations,s=i.children;dx(e,r);for(var o=s.length;o--;){var a=s[o],l=a.animations;dx(e,l),l.length||a.children.length||s.splice(o,1)}r.length||s.length||i.pause()}},sn.get=O0,sn.set=RM,sn.convertPx=F0,sn.path=function(n,e){var t=ot.str(n)?_M(n)[0]:n,i=e||100;return function(r){return{property:r,el:t,svg:SM(t),totalLength:cx(t)*(i/100)}}},sn.setDashoffset=function(n){var e=cx(n);return n.setAttribute("stroke-dasharray",e),e},sn.stagger=function(n,e){e===void 0&&(e={});var t=e.direction||"normal",i=e.easing?kA(e.easing):null,r=e.grid,s=e.axis,o=e.from||0,a=o==="first",l=o==="center",c=o==="last",h=ot.arr(n),u=parseFloat(h?n[0]:n),d=h?parseFloat(n[1]):0,f=Ur(h?n[1]:n)||0,A=e.start||0+(h?u:0),g=[],m=0;return function(p,v,E){if(a&&(o=0),l&&(o=(E-1)/2),c&&(o=E-1),!g.length){for(var x=0;x<E;x++){if(r){var M=l?(r[0]-1)/2:o%r[0],w=l?(r[1]-1)/2:Math.floor(o/r[0]),S=M-x%r[0],B=w-Math.floor(x/r[0]),y=Math.sqrt(S*S+B*B);s==="x"&&(y=-S),s==="y"&&(y=-B),g.push(y)}else g.push(Math.abs(o-x));m=Math.max.apply(Math,g)}i&&(g=g.map(function(_){return i(_/m)*m})),t==="reverse"&&(g=g.map(function(_){return s?_<0?-1*_:-_:Math.abs(m-_)}))}return A+(h?(d-u)/m:u)*(Math.round(100*g[v])/100)+f}},sn.timeline=function(n){n===void 0&&(n={});var e=sn(n);return e.duration=0,e.add=function(t,i){var r=Wn.indexOf(e),s=e.children;function o(d){d.passThrough=!0}r>-1&&Wn.splice(r,1);for(var a=0;a<s.length;a++)o(s[a]);var l=zd(t,GA(D0,n));l.targets=l.targets||n.targets;var c=e.duration;l.autoplay=!1,l.direction=e.direction,l.timelineOffset=ot.und(i)?c:k0(i,c),o(e),e.seek(l.timelineOffset);var h=sn(l);o(h),s.push(h);var u=BM(s,n);return e.delay=u.delay,e.endDelay=u.endDelay,e.duration=u.duration,e.seek(0),e.reset(),e.autoplay&&e.play(),e},e},sn.easing=kA,sn.penner=yM,sn.random=function(n,e){return Math.floor(Math.random()*(e-n+1))+n};const zu=sn,C=PD,Qp=new WeakMap;class LM extends C.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,i,r){const s=new C.FileLoader(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,o=>{this.parse(o,t,r)},i,r)}parse(e,t,i=()=>{}){this.decodeDracoFile(e,t,null,null,C.SRGBColorSpace,i).catch(i)}decodeDracoFile(e,t,i,r,s=C.LinearSRGBColorSpace,o=()=>{}){const a={attributeIDs:i||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!i,vertexColorSpace:s};return this.decodeGeometry(e,a).then(t).catch(o)}decodeGeometry(e,t){const i=JSON.stringify(t);if(Qp.has(e)){const l=Qp.get(e);if(l.key===i)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const s=this.workerNextTaskID++,o=e.byteLength,a=this._getWorker(s,o).then(l=>(r=l,new Promise((c,h)=>{r._callbacks[s]={resolve:c,reject:h},r.postMessage({type:"decode",id:s,taskConfig:t,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return a.catch(()=>!0).then(()=>{r&&s&&this._releaseTask(r,s)}),Qp.set(e,{key:i,promise:a}),a}_createGeometry(e){const t=new C.BufferGeometry;e.index&&t.setIndex(new C.BufferAttribute(e.index.array,1));for(let i=0;i<e.attributes.length;i++){const r=e.attributes[i],s=r.name,o=r.array,a=r.itemSize,l=new C.BufferAttribute(o,a);s==="color"&&(this._assignVertexColorSpace(l,r.vertexColorSpace),l.normalized=o instanceof Float32Array==0),t.setAttribute(s,l)}return t}_assignVertexColorSpace(e,t){if(t!==C.SRGBColorSpace)return;const i=new C.Color;for(let r=0,s=e.count;r<s;r++)i.fromBufferAttribute(e,r),C.ColorManagement.toWorkingColorSpace(i,C.SRGBColorSpace),e.setXYZ(r,i.r,i.g,i.b)}_loadLibrary(e,t){const i=new C.FileLoader(this.manager);return i.setPath(this.decoderPath),i.setResponseType(t),i.setWithCredentials(this.withCredentials),new Promise((r,s)=>{i.load(e,r,void 0,s)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(i=>{const r=i[0];e||(this.decoderConfig.wasmBinary=i[1]);const s=nP.toString(),o=["/* draco decoder */",r,"","/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([o]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const r=new Worker(this.workerSourceURL);r._callbacks={},r._taskCosts={},r._taskLoad=0,r.postMessage({type:"init",decoderConfig:this.decoderConfig}),r.onmessage=function(s){const o=s.data;switch(o.type){case"decode":r._callbacks[o.id].resolve(o);break;case"error":r._callbacks[o.id].reject(o);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+o.type+'"')}},this.workerPool.push(r)}else this.workerPool.sort(function(r,s){return r._taskLoad>s._taskLoad?-1:1});const i=this.workerPool[this.workerPool.length-1];return i._taskCosts[e]=t,i._taskLoad+=t,i})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function nP(){let n,e;function t(i,r,s,o,a,l){const c=l.num_components(),h=s.num_points()*c,u=h*a.BYTES_PER_ELEMENT,d=function(g,m){switch(m){case Float32Array:return g.DT_FLOAT32;case Int8Array:return g.DT_INT8;case Int16Array:return g.DT_INT16;case Int32Array:return g.DT_INT32;case Uint8Array:return g.DT_UINT8;case Uint16Array:return g.DT_UINT16;case Uint32Array:return g.DT_UINT32}}(i,a),f=i._malloc(u);r.GetAttributeDataArrayForAllPoints(s,l,d,u,f);const A=new a(i.HEAPF32.buffer,f,h).slice();return i._free(f),{name:o,array:A,itemSize:c}}onmessage=function(i){const r=i.data;switch(r.type){case"init":n=r.decoderConfig,e=new Promise(function(a){n.onModuleLoaded=function(l){a({draco:l})},DracoDecoderModule(n)});break;case"decode":const s=r.buffer,o=r.taskConfig;e.then(a=>{const l=a.draco,c=new l.Decoder;try{const h=function(d,f,A,g){const m=g.attributeIDs,p=g.attributeTypes;let v,E;const x=f.GetEncodedGeometryType(A);if(x===d.TRIANGULAR_MESH)v=new d.Mesh,E=f.DecodeArrayToMesh(A,A.byteLength,v);else{if(x!==d.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");v=new d.PointCloud,E=f.DecodeArrayToPointCloud(A,A.byteLength,v)}if(!E.ok()||v.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+E.error_msg());const M={index:null,attributes:[]};for(const w in m){const S=self[p[w]];let B,y;if(g.useUniqueIDs)y=m[w],B=f.GetAttributeByUniqueId(v,y);else{if(y=f.GetAttributeId(v,d[m[w]]),y===-1)continue;B=f.GetAttribute(v,y)}const _=t(d,f,v,w,S,B);w==="color"&&(_.vertexColorSpace=g.vertexColorSpace),M.attributes.push(_)}return x===d.TRIANGULAR_MESH&&(M.index=function(w,S,B){const y=3*B.num_faces(),_=4*y,L=w._malloc(_);S.GetTrianglesUInt32Array(B,_,L);const Q=new Uint32Array(w.HEAPF32.buffer,L,y).slice();return w._free(L),{array:Q,itemSize:1}}(d,f,v)),d.destroy(v),M}(l,c,new Int8Array(s),o),u=h.attributes.map(d=>d.array.buffer);h.index&&u.push(h.index.array.buffer),self.postMessage({type:"decode",id:r.id,geometry:h},u)}catch(h){console.error(h),self.postMessage({type:"error",id:r.id,error:h.message})}finally{l.destroy(c)}})}}}function iP(n,e,t=!0){if(!e||!e.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!n.hasAttribute("position")||!n.hasAttribute("normal")||!n.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function i(o){if(o.normalized||o.isInterleavedBufferAttribute){const a=new Float32Array(o.count*o.itemSize);for(let l=0,c=0;l<o.count;l++)a[c++]=o.getX(l),a[c++]=o.getY(l),o.itemSize>2&&(a[c++]=o.getZ(l));return a}return o.array instanceof Float32Array?o.array:new Float32Array(o.array)}const r=n.index?n.toNonIndexed():n,s=e.generateTangents(i(r.attributes.position),i(r.attributes.normal),i(r.attributes.uv));if(t)for(let o=3;o<s.length;o+=4)s[o]*=-1;return r.setAttribute("tangent",new C.BufferAttribute(s,4)),n!==r&&n.copy(r),n}function rP(n,e=!1){const t=n[0].index!==null,i=new Set(Object.keys(n[0].attributes)),r=new Set(Object.keys(n[0].morphAttributes)),s={},o={},a=n[0].morphTargetsRelative,l=new C.BufferGeometry;let c=0;for(let h=0;h<n.length;++h){const u=n[h];let d=0;if(t!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const f in u.attributes){if(!i.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+f+'" attribute exists among all geometries, or in none of them.'),null;s[f]===void 0&&(s[f]=[]),s[f].push(u.attributes[f]),d++}if(d!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(a!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const f in u.morphAttributes){if(!r.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;o[f]===void 0&&(o[f]=[]),o[f].push(u.morphAttributes[f])}if(e){let f;if(t)f=u.index.count;else{if(u.attributes.position===void 0)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;f=u.attributes.position.count}l.addGroup(c,f,h),c+=f}}if(t){let h=0;const u=[];for(let d=0;d<n.length;++d){const f=n[d].index;for(let A=0;A<f.count;++A)u.push(f.getX(A)+h);h+=n[d].attributes.position.count}l.setIndex(u)}for(const h in s){const u=VA(s[h]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" attribute."),null;l.setAttribute(h,u)}for(const h in o){const u=o[h][0].length;if(u===0)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[h]=[];for(let d=0;d<u;++d){const f=[];for(let g=0;g<o[h].length;++g)f.push(o[h][g][d]);const A=VA(f);if(!A)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+h+" morphAttribute."),null;l.morphAttributes[h].push(A)}}return l}function VA(n){let e,t,i,r=-1,s=0;for(let c=0;c<n.length;++c){const h=n[c];if(e===void 0&&(e=h.array.constructor),e!==h.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=h.itemSize),t!==h.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(i===void 0&&(i=h.normalized),i!==h.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(r===-1&&(r=h.gpuType),r!==h.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;s+=h.count*t}const o=new e(s),a=new C.BufferAttribute(o,t,i);let l=0;for(let c=0;c<n.length;++c){const h=n[c];if(h.isInterleavedBufferAttribute){const u=l/t;for(let d=0,f=h.count;d<f;d++)for(let A=0;A<t;A++){const g=h.getComponent(d,A);a.setComponent(d+u,A,g)}}else o.set(h.array,l);l+=h.count*t}return r!==void 0&&(a.gpuType=r),a}function sP(n){return n.isInstancedInterleavedBufferAttribute||n.isInterleavedBufferAttribute?Hd(n):n.isInstancedBufferAttribute?new C.InstancedBufferAttribute().copy(n):new C.BufferAttribute().copy(n)}function oP(n){let e,t=0,i=0;for(let c=0,h=n.length;c<h;++c){const u=n[c];if(e===void 0&&(e=u.array.constructor),e!==u.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;t+=u.array.length,i+=u.itemSize}const r=new C.InterleavedBuffer(new e(t),i);let s=0;const o=[],a=["getX","getY","getZ","getW"],l=["setX","setY","setZ","setW"];for(let c=0,h=n.length;c<h;c++){const u=n[c],d=u.itemSize,f=u.count,A=new C.InterleavedBufferAttribute(r,d,s,u.normalized);o.push(A),s+=d;for(let g=0;g<f;g++)for(let m=0;m<d;m++)A[l[m]](g,u[a[m]](g))}return o}function Hd(n){const e=n.data.array.constructor,t=n.count,i=n.itemSize,r=n.normalized,s=new e(t*i);let o;o=n.isInstancedInterleavedBufferAttribute?new C.InstancedBufferAttribute(s,i,r,n.meshPerAttribute):new C.BufferAttribute(s,i,r);for(let a=0;a<t;a++)o.setX(a,n.getX(a)),i>=2&&o.setY(a,n.getY(a)),i>=3&&o.setZ(a,n.getZ(a)),i>=4&&o.setW(a,n.getW(a));return o}function aP(n){const e=n.attributes,t=n.morphTargets,i=new Map;for(const r in e){const s=e[r];s.isInterleavedBufferAttribute&&(i.has(s)||i.set(s,Hd(s)),e[r]=i.get(s))}for(const r in t){const s=t[r];s.isInterleavedBufferAttribute&&(i.has(s)||i.set(s,Hd(s)),t[r]=i.get(s))}}function lP(n){let e=0;for(const i in n.attributes){const r=n.getAttribute(i);e+=r.count*r.itemSize*r.array.BYTES_PER_ELEMENT}const t=n.getIndex();return e+=t?t.count*t.itemSize*t.array.BYTES_PER_ELEMENT:0,e}function cP(n,e=1e-4){e=Math.max(e,Number.EPSILON);const t={},i=n.getIndex(),r=n.getAttribute("position"),s=i?i.count:r.count;let o=0;const a=Object.keys(n.attributes),l={},c={},h=[],u=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let v=0,E=a.length;v<E;v++){const x=a[v],M=n.attributes[x];l[x]=new M.constructor(new M.array.constructor(M.count*M.itemSize),M.itemSize,M.normalized);const w=n.morphAttributes[x];w&&(c[x]||(c[x]=[]),w.forEach((S,B)=>{const y=new S.array.constructor(S.count*S.itemSize);c[x][B]=new S.constructor(y,S.itemSize,S.normalized)}))}const f=.5*e,A=Math.log10(1/e),g=Math.pow(10,A),m=f*g;for(let v=0;v<s;v++){const E=i?i.getX(v):v;let x="";for(let M=0,w=a.length;M<w;M++){const S=a[M],B=n.getAttribute(S),y=B.itemSize;for(let _=0;_<y;_++)x+=~~(B[u[_]](E)*g+m)+","}if(x in t)h.push(t[x]);else{for(let M=0,w=a.length;M<w;M++){const S=a[M],B=n.getAttribute(S),y=n.morphAttributes[S],_=B.itemSize,L=l[S],Q=c[S];for(let O=0;O<_;O++){const X=u[O],te=d[O];if(L[te](o,B[X](E)),y)for(let W=0,Z=y.length;W<Z;W++)Q[W][te](o,y[W][X](E))}}t[x]=o,h.push(o),o++}}const p=n.clone();for(const v in n.attributes){const E=l[v];if(p.setAttribute(v,new E.constructor(E.array.slice(0,o*E.itemSize),E.itemSize,E.normalized)),v in c)for(let x=0;x<c[v].length;x++){const M=c[v][x];p.morphAttributes[v][x]=new M.constructor(M.array.slice(0,o*M.itemSize),M.itemSize,M.normalized)}}return p.setIndex(h),p}function QA(n,e){if(e===C.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===C.TriangleFanDrawMode||e===C.TriangleStripDrawMode){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a===void 0)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n;for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}const i=t.count-2,r=[];if(e===C.TriangleFanDrawMode)for(let o=1;o<=i;o++)r.push(t.getX(0)),r.push(t.getX(o)),r.push(t.getX(o+1));else for(let o=0;o<i;o++)o%2==0?(r.push(t.getX(o)),r.push(t.getX(o+1)),r.push(t.getX(o+2))):(r.push(t.getX(o+2)),r.push(t.getX(o+1)),r.push(t.getX(o)));r.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=n.clone();return s.setIndex(r),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}function hP(n){const e=new C.Vector3,t=new C.Vector3,i=new C.Vector3,r=new C.Vector3,s=new C.Vector3,o=new C.Vector3,a=new C.Vector3,l=new C.Vector3,c=new C.Vector3;function h(Z,q,re,ue,_e,Be,ze,le){e.fromBufferAttribute(q,_e),t.fromBufferAttribute(q,Be),i.fromBufferAttribute(q,ze);const Ee=Z.morphTargetInfluences;if(re&&Ee){a.set(0,0,0),l.set(0,0,0),c.set(0,0,0);for(let Ue=0,pe=re.length;Ue<pe;Ue++){const oe=Ee[Ue],we=re[Ue];oe!==0&&(r.fromBufferAttribute(we,_e),s.fromBufferAttribute(we,Be),o.fromBufferAttribute(we,ze),ue?(a.addScaledVector(r,oe),l.addScaledVector(s,oe),c.addScaledVector(o,oe)):(a.addScaledVector(r.sub(e),oe),l.addScaledVector(s.sub(t),oe),c.addScaledVector(o.sub(i),oe)))}e.add(a),t.add(l),i.add(c)}Z.isSkinnedMesh&&(Z.applyBoneTransform(_e,e),Z.applyBoneTransform(Be,t),Z.applyBoneTransform(ze,i)),le[3*_e+0]=e.x,le[3*_e+1]=e.y,le[3*_e+2]=e.z,le[3*Be+0]=t.x,le[3*Be+1]=t.y,le[3*Be+2]=t.z,le[3*ze+0]=i.x,le[3*ze+1]=i.y,le[3*ze+2]=i.z}const u=n.geometry,d=n.material;let f,A,g;const m=u.index,p=u.attributes.position,v=u.morphAttributes.position,E=u.morphTargetsRelative,x=u.attributes.normal,M=u.morphAttributes.position,w=u.groups,S=u.drawRange;let B,y,_,L,Q,O,X;const te=new Float32Array(p.count*p.itemSize),W=new Float32Array(x.count*x.itemSize);if(m!==null)if(Array.isArray(d))for(B=0,_=w.length;B<_;B++)for(Q=w[B],O=Math.max(Q.start,S.start),X=Math.min(Q.start+Q.count,S.start+S.count),y=O,L=X;y<L;y+=3)f=m.getX(y),A=m.getX(y+1),g=m.getX(y+2),h(n,p,v,E,f,A,g,te),h(n,x,M,E,f,A,g,W);else for(O=Math.max(0,S.start),X=Math.min(m.count,S.start+S.count),B=O,_=X;B<_;B+=3)f=m.getX(B),A=m.getX(B+1),g=m.getX(B+2),h(n,p,v,E,f,A,g,te),h(n,x,M,E,f,A,g,W);else if(Array.isArray(d))for(B=0,_=w.length;B<_;B++)for(Q=w[B],O=Math.max(Q.start,S.start),X=Math.min(Q.start+Q.count,S.start+S.count),y=O,L=X;y<L;y+=3)f=y,A=y+1,g=y+2,h(n,p,v,E,f,A,g,te),h(n,x,M,E,f,A,g,W);else for(O=Math.max(0,S.start),X=Math.min(p.count,S.start+S.count),B=O,_=X;B<_;B+=3)f=B,A=B+1,g=B+2,h(n,p,v,E,f,A,g,te),h(n,x,M,E,f,A,g,W);return{positionAttribute:p,normalAttribute:x,morphedPositionAttribute:new C.Float32BufferAttribute(te,3),morphedNormalAttribute:new C.Float32BufferAttribute(W,3)}}function uP(n){if(n.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),n;let e=n.groups;if(e=e.sort((o,a)=>o.materialIndex!==a.materialIndex?o.materialIndex-a.materialIndex:o.start-a.start),n.getIndex()===null){const o=n.getAttribute("position"),a=[];for(let l=0;l<o.count;l+=3)a.push(l,l+1,l+2);n.setIndex(a)}const t=n.getIndex(),i=[];for(let o=0;o<e.length;o++){const a=e[o],l=a.start,c=l+a.count;for(let h=l;h<c;h++)i.push(t.getX(h))}n.dispose(),n.setIndex(i);let r=0;for(let o=0;o<e.length;o++){const a=e[o];a.start=r,r+=a.count}let s=e[0];n.groups=[s];for(let o=1;o<e.length;o++){const a=e[o];s.materialIndex===a.materialIndex?s.count+=a.count:(s=a,n.groups.push(s))}return n}function dP(n,e=Math.PI/3){const t=Math.cos(e),i=100*(1+1e-10),r=[new C.Vector3,new C.Vector3,new C.Vector3],s=new C.Vector3,o=new C.Vector3,a=new C.Vector3,l=new C.Vector3;function c(g){return`${~~(g.x*i)},${~~(g.y*i)},${~~(g.z*i)}`}const h=n.index?n.toNonIndexed():n,u=h.attributes.position,d={};for(let g=0,m=u.count/3;g<m;g++){const p=3*g,v=r[0].fromBufferAttribute(u,p+0),E=r[1].fromBufferAttribute(u,p+1),x=r[2].fromBufferAttribute(u,p+2);s.subVectors(x,E),o.subVectors(v,E);const M=new C.Vector3().crossVectors(s,o).normalize();for(let w=0;w<3;w++){const S=c(r[w]);S in d||(d[S]=[]),d[S].push(M)}}const f=new Float32Array(3*u.count),A=new C.BufferAttribute(f,3,!1);for(let g=0,m=u.count/3;g<m;g++){const p=3*g,v=r[0].fromBufferAttribute(u,p+0),E=r[1].fromBufferAttribute(u,p+1),x=r[2].fromBufferAttribute(u,p+2);s.subVectors(x,E),o.subVectors(v,E),a.crossVectors(s,o).normalize();for(let M=0;M<3;M++){const w=d[c(r[M])];l.set(0,0,0);for(let S=0,B=w.length;S<B;S++){const y=w[S];a.dot(y)>t&&l.add(y)}l.normalize(),A.setXYZ(p+M,l.x,l.y,l.z)}}return h.setAttribute("normal",A),h}class G0 extends C.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new gP(t)}),this.register(function(t){return new vP(t)}),this.register(function(t){return new wP(t)}),this.register(function(t){return new TP(t)}),this.register(function(t){return new IP(t)}),this.register(function(t){return new xP(t)}),this.register(function(t){return new yP(t)}),this.register(function(t){return new _P(t)}),this.register(function(t){return new bP(t)}),this.register(function(t){return new AP(t)}),this.register(function(t){return new CP(t)}),this.register(function(t){return new EP(t)}),this.register(function(t){return new SP(t)}),this.register(function(t){return new MP(t)}),this.register(function(t){return new pP(t)}),this.register(function(t){return new RP(t)}),this.register(function(t){return new BP(t)})}load(e,t,i,r){const s=this;let o;if(this.resourcePath!=="")o=this.resourcePath;else if(this.path!==""){const c=C.LoaderUtils.extractUrlBase(e);o=C.LoaderUtils.resolveURL(c,this.path)}else o=C.LoaderUtils.extractUrlBase(e);this.manager.itemStart(e);const a=function(c){r?r(c):console.error(c),s.manager.itemError(e),s.manager.itemEnd(e)},l=new C.FileLoader(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{s.parse(c,o,function(h){t(h),s.manager.itemEnd(e)},a)}catch(h){a(h)}},i,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,r){let s;const o={},a={},l=new TextDecoder;if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===DM){try{o[bt.KHR_BINARY_GLTF]=new LP(e)}catch(h){return void(r&&r(h))}s=JSON.parse(o[bt.KHR_BINARY_GLTF].content)}else s=JSON.parse(l.decode(e));else s=e;if(s.asset===void 0||s.asset.version[0]<2)return void(r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new VP(s,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const u=this.pluginCallbacks[h](c);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[u.name]=u,o[u.name]=!0}if(s.extensionsUsed)for(let h=0;h<s.extensionsUsed.length;++h){const u=s.extensionsUsed[h],d=s.extensionsRequired||[];switch(u){case bt.KHR_MATERIALS_UNLIT:o[u]=new mP;break;case bt.KHR_DRACO_MESH_COMPRESSION:o[u]=new DP(s,this.dracoLoader);break;case bt.KHR_TEXTURE_TRANSFORM:o[u]=new PP;break;case bt.KHR_MESH_QUANTIZATION:o[u]=new UP;break;default:d.indexOf(u)>=0&&a[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}c.setExtensions(o),c.setPlugins(a),c.parse(i,r)}parseAsync(e,t){const i=this;return new Promise(function(r,s){i.parse(e,t,r,s)})}}function fP(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const bt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};let pP=class{constructor(e){this.parser=e,this.name=bt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,r=t.length;i<r;i++){const s=t[i];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let r=t.cache.get(i);if(r)return r;const s=t.json,o=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let a;const l=new C.Color(16777215);o.color!==void 0&&l.setRGB(o.color[0],o.color[1],o.color[2],C.LinearSRGBColorSpace);const c=o.range!==void 0?o.range:0;switch(o.type){case"directional":a=new C.DirectionalLight(l),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new C.PointLight(l),a.distance=c;break;case"spot":a=new C.SpotLight(l),a.distance=c,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,a.angle=o.spot.outerConeAngle,a.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return a.position.set(0,0,0),Er(a,o),o.intensity!==void 0&&(a.intensity=o.intensity),a.name=t.createUniqueName(o.name||"light_"+e),r=Promise.resolve(a),t.cache.add(i,r),r}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,r=i.json.nodes[e],s=(r.extensions&&r.extensions[this.name]||{}).light;return s===void 0?null:this._loadLight(s).then(function(o){return i._getNodeRef(t.cache,s,o)})}},mP=class{constructor(){this.name=bt.KHR_MATERIALS_UNLIT}getMaterialType(){return C.MeshBasicMaterial}extendParams(e,t,i){const r=[];e.color=new C.Color(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.setRGB(o[0],o[1],o[2],C.LinearSRGBColorSpace),e.opacity=o[3]}s.baseColorTexture!==void 0&&r.push(i.assignTexture(e,"map",s.baseColorTexture,C.SRGBColorSpace))}return Promise.all(r)}},AP=class{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}},gP=class{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(i.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new C.Vector2(a,a)}return Promise.all(s)}},vP=class{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_DISPERSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}};class EP{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(i.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(i.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}let xP=class{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new C.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=r.extensions[this.name];if(o.sheenColorFactor!==void 0){const a=o.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],C.LinearSRGBColorSpace)}return o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(i.assignTexture(t,"sheenColorMap",o.sheenColorTexture,C.SRGBColorSpace)),o.sheenRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}};class yP{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(i.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class _P{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(i.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new C.Color().setRGB(a[0],a[1],a[2],C.LinearSRGBColorSpace),Promise.all(s)}}class bP{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class CP{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(i.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new C.Color().setRGB(a[0],a[1],a[2],C.LinearSRGBColorSpace),o.specularColorTexture!==void 0&&s.push(i.assignTexture(t,"specularColorMap",o.specularColorTexture,C.SRGBColorSpace)),Promise.all(s)}}class MP{constructor(e){this.parser=e,this.name=bt.EXT_MATERIALS_BUMP}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return t.bumpScale=o.bumpFactor!==void 0?o.bumpFactor:1,o.bumpTexture!==void 0&&s.push(i.assignTexture(t,"bumpMap",o.bumpTexture)),Promise.all(s)}}class SP{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?C.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&s.push(i.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}}class wP{constructor(e){this.parser=e,this.name=bt.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,r=i.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const s=r.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,o)}}class TP{constructor(e){this.parser=e,this.name=bt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const c=i.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class IP{constructor(e){this.parser=e,this.name=bt.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const c=i.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class RP{constructor(e){this.name=bt.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const r=i.extensions[this.name],s=this.parser.getDependency("buffer",r.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(a){const l=r.byteOffset||0,c=r.byteLength||0,h=r.count,u=r.byteStride,d=new Uint8Array(a,l,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(h,u,d,r.mode,r.filter).then(function(f){return f.buffer}):o.ready.then(function(){const f=new ArrayBuffer(h*u);return o.decodeGltfBuffer(new Uint8Array(f),h,u,d,r.mode,r.filter),f})})}return null}}class BP{constructor(e){this.name=bt.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||i.mesh===void 0)return null;const r=t.meshes[i.mesh];for(const l of r.primitives)if(l.mode!==di.TRIANGLES&&l.mode!==di.TRIANGLE_STRIP&&l.mode!==di.TRIANGLE_FAN&&l.mode!==void 0)return null;const s=i.extensions[this.name].attributes,o=[],a={};for(const l in s)o.push(this.parser.getDependency("accessor",s[l]).then(c=>(a[l]=c,a[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const c=l.pop(),h=c.isGroup?c.children:[c],u=l[0].count,d=[];for(const f of h){const A=new C.Matrix4,g=new C.Vector3,m=new C.Quaternion,p=new C.Vector3(1,1,1),v=new C.InstancedMesh(f.geometry,f.material,u);for(let E=0;E<u;E++)a.TRANSLATION&&g.fromBufferAttribute(a.TRANSLATION,E),a.ROTATION&&m.fromBufferAttribute(a.ROTATION,E),a.SCALE&&p.fromBufferAttribute(a.SCALE,E),v.setMatrixAt(E,A.compose(g,m,p));for(const E in a)if(E==="_COLOR_0"){const x=a[E];v.instanceColor=new C.InstancedBufferAttribute(x.array,x.itemSize,x.normalized)}else E!=="TRANSLATION"&&E!=="ROTATION"&&E!=="SCALE"&&f.geometry.setAttribute(E,a[E]);C.Object3D.prototype.copy.call(v,f),this.parser.assignFinalMaterial(v),d.push(v)}return c.isGroup?(c.clear(),c.add(...d),c):d[0]}))}}const DM="glTF";class LP{constructor(e){this.name=bt.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12),i=new TextDecoder;if(this.header={magic:i.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==DM)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-12,s=new DataView(e,12);let o=0;for(;o<r;){const a=s.getUint32(o,!0);o+=4;const l=s.getUint32(o,!0);if(o+=4,l===1313821514){const c=new Uint8Array(e,12+o,a);this.content=i.decode(c)}else if(l===5130562){const c=12+o;this.body=e.slice(c,c+a)}o+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class DP{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=bt.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,r=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const h in o){const u=WA[h]||h.toLowerCase();a[u]=o[h]}for(const h in e.attributes){const u=WA[h]||h.toLowerCase();if(o[h]!==void 0){const d=i.accessors[e.attributes[h]],f=Va[d.componentType];c[u]=f.name,l[u]=d.normalized===!0}}return t.getDependency("bufferView",s).then(function(h){return new Promise(function(u,d){r.decodeDracoFile(h,function(f){for(const A in f.attributes){const g=f.attributes[A],m=l[A];m!==void 0&&(g.normalized=m)}u(f)},a,c,C.LinearSRGBColorSpace,d)})})}}class PP{constructor(){this.name=bt.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord!==void 0&&t.texCoord!==e.channel||t.offset!==void 0||t.rotation!==void 0||t.scale!==void 0)&&(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class UP{constructor(){this.name=bt.KHR_MESH_QUANTIZATION}}class PM extends C.Interpolant{constructor(e,t,i,r){super(e,t,i,r)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r*3+r;for(let o=0;o!==r;o++)t[o]=i[s+o];return t}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=2*a,c=3*a,h=r-t,u=(i-t)/h,d=u*u,f=d*u,A=e*c,g=A-c,m=-2*f+3*d,p=f-d,v=1-m,E=p-d+u;for(let x=0;x!==a;x++){const M=o[g+x+a],w=o[g+x+l]*h,S=o[A+x+a],B=o[A+x]*h;s[x]=v*M+E*w+m*S+p*B}return s}}const FP=new C.Quaternion;class NP extends PM{interpolate_(e,t,i,r){const s=super.interpolate_(e,t,i,r);return FP.fromArray(s).normalize().toArray(s),s}}const di={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Va={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},fx={9728:C.NearestFilter,9729:C.LinearFilter,9984:C.NearestMipmapNearestFilter,9985:C.LinearMipmapNearestFilter,9986:C.NearestMipmapLinearFilter,9987:C.LinearMipmapLinearFilter},px={33071:C.ClampToEdgeWrapping,33648:C.MirroredRepeatWrapping,10497:C.RepeatWrapping},Wp={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},WA={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Jr={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},OP={CUBICSPLINE:void 0,LINEAR:C.InterpolateLinear,STEP:C.InterpolateDiscrete};function kP(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new C.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:C.FrontSide})),n.DefaultMaterial}function qs(n,e,t){for(const i in t.extensions)n[i]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=t.extensions[i])}function Er(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function GP(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,i=e.weights.length;t<i;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let i=0,r=t.length;i<r;i++)n.morphTargetDictionary[t[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function zP(n){let e;const t=n.extensions&&n.extensions[bt.KHR_DRACO_MESH_COMPRESSION];if(e=t?"draco:"+t.bufferView+":"+t.indices+":"+Xp(t.attributes):n.indices+":"+Xp(n.attributes)+":"+n.mode,n.targets!==void 0)for(let i=0,r=n.targets.length;i<r;i++)e+=":"+Xp(n.targets[i]);return e}function Xp(n){let e="";const t=Object.keys(n).sort();for(let i=0,r=t.length;i<r;i++)e+=t[i]+":"+n[t[i]]+";";return e}function XA(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const HP=new C.Matrix4;class VP{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new fP,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,r=-1,s=!1,o=-1;if(typeof navigator<"u"){const a=navigator.userAgent;i=/^((?!chrome|android).)*safari/i.test(a)===!0;const l=a.match(/Version\/(\d+)/);r=i&&l?parseInt(l[1],10):-1,s=a.indexOf("Firefox")>-1,o=s?a.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||i&&r<17||s&&o<98?this.textureLoader=new C.TextureLoader(this.options.manager):this.textureLoader=new C.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new C.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,r=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(o){const a={scene:o[0][r.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:r.asset,parser:i,userData:{}};return qs(s,a,r),Er(a,r),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){for(const l of a.scenes)l.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let r=0,s=t.length;r<s;r++){const o=t[r].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let r=0,s=e.length;r<s;r++){const o=e[r];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(i[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const r=i.clone(),s=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,h]of o.children.entries())s(h,a.children[c])};return s(i,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let r=0;r<t.length;r++){const s=e(t[r]);s&&i.push(s)}return i}getDependency(e,t){const i=e+":"+t;let r=this.cache.get(i);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this._invokeOne(function(s){return s.loadNode&&s.loadNode(t)});break;case"mesh":r=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":r=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":r=this.loadSkin(t);break;case"animation":r=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":r=this.loadCamera(t);break;default:if(r=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!r)throw new Error("Unknown type: "+e)}this.cache.add(i,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,r=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(r.map(function(s,o){return i.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[bt.KHR_BINARY_GLTF].body);const r=this.options;return new Promise(function(s,o){i.load(C.LoaderUtils.resolveURL(t.uri,r.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(i){const r=t.byteLength||0,s=t.byteOffset||0;return i.slice(s,s+r)})}loadAccessor(e){const t=this,i=this.json,r=this.json.accessors[e];if(r.bufferView===void 0&&r.sparse===void 0){const o=Wp[r.type],a=Va[r.componentType],l=r.normalized===!0,c=new a(r.count*o);return Promise.resolve(new C.BufferAttribute(c,o,l))}const s=[];return r.bufferView!==void 0?s.push(this.getDependency("bufferView",r.bufferView)):s.push(null),r.sparse!==void 0&&(s.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(s).then(function(o){const a=o[0],l=Wp[r.type],c=Va[r.componentType],h=c.BYTES_PER_ELEMENT,u=h*l,d=r.byteOffset||0,f=r.bufferView!==void 0?i.bufferViews[r.bufferView].byteStride:void 0,A=r.normalized===!0;let g,m;if(f&&f!==u){const p=Math.floor(d/f),v="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+p+":"+r.count;let E=t.cache.get(v);E||(g=new c(a,p*f,r.count*f/h),E=new C.InterleavedBuffer(g,f/h),t.cache.add(v,E)),m=new C.InterleavedBufferAttribute(E,l,d%f/h,A)}else g=a===null?new c(r.count*l):new c(a,d,r.count*l),m=new C.BufferAttribute(g,l,A);if(r.sparse!==void 0){const p=Wp.SCALAR,v=Va[r.sparse.indices.componentType],E=r.sparse.indices.byteOffset||0,x=r.sparse.values.byteOffset||0,M=new v(o[1],E,r.sparse.count*p),w=new c(o[2],x,r.sparse.count*l);a!==null&&(m=new C.BufferAttribute(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let S=0,B=M.length;S<B;S++){const y=M[S];if(m.setX(y,w[S*l]),l>=2&&m.setY(y,w[S*l+1]),l>=3&&m.setZ(y,w[S*l+2]),l>=4&&m.setW(y,w[S*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=A}return m})}loadTexture(e){const t=this.json,i=this.options,r=t.textures[e].source,s=t.images[r];let o=this.textureLoader;if(s.uri){const a=i.manager.getHandler(s.uri);a!==null&&(o=a)}return this.loadTextureImage(e,r,o)}loadTextureImage(e,t,i){const r=this,s=this.json,o=s.textures[e],a=s.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,i).then(function(h){h.flipY=!1,h.name=o.name||a.name||"",h.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(h.name=a.uri);const u=(s.samplers||{})[o.sampler]||{};return h.magFilter=fx[u.magFilter]||C.LinearFilter,h.minFilter=fx[u.minFilter]||C.LinearMipmapLinearFilter,h.wrapS=px[u.wrapS]||C.RepeatWrapping,h.wrapT=px[u.wrapT]||C.RepeatWrapping,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==C.NearestFilter&&h.minFilter!==C.LinearFilter,r.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const i=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const s=i.images[e],o=self.URL||self.webkitURL;let a=s.uri||"",l=!1;if(s.bufferView!==void 0)a=this.getDependency("bufferView",s.bufferView).then(function(h){l=!0;const u=new Blob([h],{type:s.mimeType});return a=o.createObjectURL(u),a});else if(s.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(a).then(function(h){return new Promise(function(u,d){let f=u;t.isImageBitmapLoader===!0&&(f=function(A){const g=new C.Texture(A);g.needsUpdate=!0,u(g)}),t.load(C.LoaderUtils.resolveURL(h,r.path),f,void 0,d)})}).then(function(h){var u;return l===!0&&o.revokeObjectURL(a),Er(h,s),h.userData.mimeType=s.mimeType||((u=s.uri).search(/\.jpe?g($|\?)/i)>0||u.search(/^data\:image\/jpeg/)===0?"image/jpeg":u.search(/\.webp($|\?)/i)>0||u.search(/^data\:image\/webp/)===0?"image/webp":u.search(/\.ktx2($|\?)/i)>0||u.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),h});return this.sourceCache[e]=c,c}assignTexture(e,t,i,r){const s=this;return this.getDependency("texture",i.index).then(function(o){if(!o)return null;if(i.texCoord!==void 0&&i.texCoord>0&&((o=o.clone()).channel=i.texCoord),s.extensions[bt.KHR_TEXTURE_TRANSFORM]){const a=i.extensions!==void 0?i.extensions[bt.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=s.associations.get(o);o=s.extensions[bt.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),s.associations.set(o,l)}}return r!==void 0&&(o.colorSpace=r),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const r=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new C.PointsMaterial,C.Material.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(a,l)),i=l}else if(e.isLine){const a="LineBasicMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new C.LineBasicMaterial,C.Material.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,this.cache.add(a,l)),i=l}if(r||s||o){let a="ClonedMaterial:"+i.uuid+":";r&&(a+="derivative-tangents:"),s&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=i.clone(),s&&(l.vertexColors=!0),o&&(l.flatShading=!0),r&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(i))),i=l}e.material=i}getMaterialType(){return C.MeshStandardMaterial}loadMaterial(e){const t=this,i=this.json,r=this.extensions,s=i.materials[e];let o;const a={},l=[];if((s.extensions||{})[bt.KHR_MATERIALS_UNLIT]){const h=r[bt.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),l.push(h.extendParams(a,s,t))}else{const h=s.pbrMetallicRoughness||{};if(a.color=new C.Color(1,1,1),a.opacity=1,Array.isArray(h.baseColorFactor)){const u=h.baseColorFactor;a.color.setRGB(u[0],u[1],u[2],C.LinearSRGBColorSpace),a.opacity=u[3]}h.baseColorTexture!==void 0&&l.push(t.assignTexture(a,"map",h.baseColorTexture,C.SRGBColorSpace)),a.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,a.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(a,"metalnessMap",h.metallicRoughnessTexture)),l.push(t.assignTexture(a,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(u){return u.getMaterialType&&u.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(u){return u.extendMaterialParams&&u.extendMaterialParams(e,a)})))}s.doubleSided===!0&&(a.side=C.DoubleSide);const c=s.alphaMode||"OPAQUE";if(c==="BLEND"?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,c==="MASK"&&(a.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==C.MeshBasicMaterial&&(l.push(t.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new C.Vector2(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;a.normalScale.set(h,h)}if(s.occlusionTexture!==void 0&&o!==C.MeshBasicMaterial&&(l.push(t.assignTexture(a,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==C.MeshBasicMaterial){const h=s.emissiveFactor;a.emissive=new C.Color().setRGB(h[0],h[1],h[2],C.LinearSRGBColorSpace)}return s.emissiveTexture!==void 0&&o!==C.MeshBasicMaterial&&l.push(t.assignTexture(a,"emissiveMap",s.emissiveTexture,C.SRGBColorSpace)),Promise.all(l).then(function(){const h=new o(a);return s.name&&(h.name=s.name),Er(h,s),t.associations.set(h,{materials:e}),s.extensions&&qs(r,h,s),h})}createUniqueName(e){const t=C.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,r=this.primitiveCache;function s(a){return i[bt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return mx(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],h=zP(c),u=r[h];if(u)o.push(u.promise);else{let d;d=c.extensions&&c.extensions[bt.KHR_DRACO_MESH_COMPRESSION]?s(c):mx(new C.BufferGeometry,c,t),r[h]={primitive:c,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,i=this.json,r=this.extensions,s=i.meshes[e],o=s.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const h=o[l].material===void 0?kP(this.cache):this.getDependency("material",o[l].material);a.push(h)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),h=l[l.length-1],u=[];for(let f=0,A=h.length;f<A;f++){const g=h[f],m=o[f];let p;const v=c[f];if(m.mode===di.TRIANGLES||m.mode===di.TRIANGLE_STRIP||m.mode===di.TRIANGLE_FAN||m.mode===void 0)p=s.isSkinnedMesh===!0?new C.SkinnedMesh(g,v):new C.Mesh(g,v),p.isSkinnedMesh===!0&&p.normalizeSkinWeights(),m.mode===di.TRIANGLE_STRIP?p.geometry=QA(p.geometry,C.TriangleStripDrawMode):m.mode===di.TRIANGLE_FAN&&(p.geometry=QA(p.geometry,C.TriangleFanDrawMode));else if(m.mode===di.LINES)p=new C.LineSegments(g,v);else if(m.mode===di.LINE_STRIP)p=new C.Line(g,v);else if(m.mode===di.LINE_LOOP)p=new C.LineLoop(g,v);else{if(m.mode!==di.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);p=new C.Points(g,v)}Object.keys(p.geometry.morphAttributes).length>0&&GP(p,s),p.name=t.createUniqueName(s.name||"mesh_"+e),Er(p,s),m.extensions&&qs(r,p,m),t.assignFinalMaterial(p),u.push(p)}for(let f=0,A=u.length;f<A;f++)t.associations.set(u[f],{meshes:e,primitives:f});if(u.length===1)return s.extensions&&qs(r,u[0],s),u[0];const d=new C.Group;s.extensions&&qs(r,d,s),t.associations.set(d,{meshes:e});for(let f=0,A=u.length;f<A;f++)d.add(u[f]);return d})}loadCamera(e){let t;const i=this.json.cameras[e],r=i[i.type];if(r)return i.type==="perspective"?t=new C.PerspectiveCamera(C.MathUtils.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):i.type==="orthographic"&&(t=new C.OrthographicCamera(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),Er(t,i),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],i=[];for(let r=0,s=t.joints.length;r<s;r++)i.push(this._loadNodeShallow(t.joints[r]));return t.inverseBindMatrices!==void 0?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(r){const s=r.pop(),o=r,a=[],l=[];for(let c=0,h=o.length;c<h;c++){const u=o[c];if(u){a.push(u);const d=new C.Matrix4;s!==null&&d.fromArray(s.array,16*c),l.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new C.Skeleton(a,l)})}loadAnimation(e){const t=this.json,i=this,r=t.animations[e],s=r.name?r.name:"animation_"+e,o=[],a=[],l=[],c=[],h=[];for(let u=0,d=r.channels.length;u<d;u++){const f=r.channels[u],A=r.samplers[f.sampler],g=f.target,m=g.node,p=r.parameters!==void 0?r.parameters[A.input]:A.input,v=r.parameters!==void 0?r.parameters[A.output]:A.output;g.node!==void 0&&(o.push(this.getDependency("node",m)),a.push(this.getDependency("accessor",p)),l.push(this.getDependency("accessor",v)),c.push(A),h.push(g))}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(c),Promise.all(h)]).then(function(u){const d=u[0],f=u[1],A=u[2],g=u[3],m=u[4],p=[];for(let v=0,E=d.length;v<E;v++){const x=d[v],M=f[v],w=A[v],S=g[v],B=m[v];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const y=i._createAnimationTracks(x,M,w,S,B);if(y)for(let _=0;_<y.length;_++)p.push(y[_])}return new C.AnimationClip(s,void 0,p)})}createNodeMesh(e){const t=this.json,i=this,r=t.nodes[e];return r.mesh===void 0?null:i.getDependency("mesh",r.mesh).then(function(s){const o=i._getNodeRef(i.meshCache,r.mesh,s);return r.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,c=r.weights.length;l<c;l++)a.morphTargetInfluences[l]=r.weights[l]}),o})}loadNode(e){const t=this,i=this.json.nodes[e],r=t._loadNodeShallow(e),s=[],o=i.children||[];for(let l=0,c=o.length;l<c;l++)s.push(t.getDependency("node",o[l]));const a=i.skin===void 0?Promise.resolve(null):t.getDependency("skin",i.skin);return Promise.all([r,Promise.all(s),a]).then(function(l){const c=l[0],h=l[1],u=l[2];u!==null&&c.traverse(function(d){d.isSkinnedMesh&&d.bind(u,HP)});for(let d=0,f=h.length;d<f;d++)c.add(h[d]);return c})}_loadNodeShallow(e){const t=this.json,i=this.extensions,r=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=t.nodes[e],o=s.name?r.createUniqueName(s.name):"",a=[],l=r._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),s.camera!==void 0&&a.push(r.getDependency("camera",s.camera).then(function(c){return r._getNodeRef(r.cameraCache,s.camera,c)})),r._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),this.nodeCache[e]=Promise.all(a).then(function(c){let h;if(h=s.isBone===!0?new C.Bone:c.length>1?new C.Group:c.length===1?c[0]:new C.Object3D,h!==c[0])for(let u=0,d=c.length;u<d;u++)h.add(c[u]);if(s.name&&(h.userData.name=s.name,h.name=o),Er(h,s),s.extensions&&qs(i,h,s),s.matrix!==void 0){const u=new C.Matrix4;u.fromArray(s.matrix),h.applyMatrix4(u)}else s.translation!==void 0&&h.position.fromArray(s.translation),s.rotation!==void 0&&h.quaternion.fromArray(s.rotation),s.scale!==void 0&&h.scale.fromArray(s.scale);return r.associations.has(h)||r.associations.set(h,{}),r.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],r=this,s=new C.Group;i.name&&(s.name=r.createUniqueName(i.name)),Er(s,i),i.extensions&&qs(t,s,i);const o=i.nodes||[],a=[];for(let l=0,c=o.length;l<c;l++)a.push(r.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let c=0,h=l.length;c<h;c++)s.add(l[c]);return r.associations=(c=>{const h=new Map;for(const[u,d]of r.associations)(u instanceof C.Material||u instanceof C.Texture)&&h.set(u,d);return c.traverse(u=>{const d=r.associations.get(u);d!=null&&h.set(u,d)}),h})(s),s})}_createAnimationTracks(e,t,i,r,s){const o=[],a=e.name?e.name:e.uuid,l=[];let c;switch(Jr[s.path]===Jr.weights?e.traverse(function(d){d.morphTargetInfluences&&l.push(d.name?d.name:d.uuid)}):l.push(a),Jr[s.path]){case Jr.weights:c=C.NumberKeyframeTrack;break;case Jr.rotation:c=C.QuaternionKeyframeTrack;break;case Jr.position:case Jr.scale:c=C.VectorKeyframeTrack;break;default:c=i.itemSize===1?C.NumberKeyframeTrack:C.VectorKeyframeTrack}const h=r.interpolation!==void 0?OP[r.interpolation]:C.InterpolateLinear,u=this._getArrayFromAccessor(i);for(let d=0,f=l.length;d<f;d++){const A=new c(l[d]+"."+Jr[s.path],t.array,u,h);r.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(A),o.push(A)}return o}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const i=XA(t.constructor),r=new Float32Array(t.length);for(let s=0,o=t.length;s<o;s++)r[s]=t[s]*i;t=r}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(t){return new(this instanceof C.QuaternionKeyframeTrack?NP:PM)(this.times,this.values,this.getValueSize()/3,t)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function mx(n,e,t){const i=e.attributes,r=[];function s(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}for(const o in i){const a=WA[o]||o.toLowerCase();a in n.attributes||r.push(s(i[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});r.push(o)}return C.ColorManagement.workingColorSpace!==C.LinearSRGBColorSpace&&"COLOR_0"in i&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${C.ColorManagement.workingColorSpace}" not supported.`),Er(n,e),function(o,a,l){const c=a.attributes,h=new C.Box3;if(c.POSITION===void 0)return;{const f=l.json.accessors[c.POSITION],A=f.min,g=f.max;if(A===void 0||g===void 0)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(h.set(new C.Vector3(A[0],A[1],A[2]),new C.Vector3(g[0],g[1],g[2])),f.normalized){const m=XA(Va[f.componentType]);h.min.multiplyScalar(m),h.max.multiplyScalar(m)}}const u=a.targets;if(u!==void 0){const f=new C.Vector3,A=new C.Vector3;for(let g=0,m=u.length;g<m;g++){const p=u[g];if(p.POSITION!==void 0){const v=l.json.accessors[p.POSITION],E=v.min,x=v.max;if(E!==void 0&&x!==void 0){if(A.setX(Math.max(Math.abs(E[0]),Math.abs(x[0]))),A.setY(Math.max(Math.abs(E[1]),Math.abs(x[1]))),A.setZ(Math.max(Math.abs(E[2]),Math.abs(x[2]))),v.normalized){const M=XA(Va[v.componentType]);A.multiplyScalar(M)}f.max(A)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}h.expandByVector(f)}o.boundingBox=h;const d=new C.Sphere;h.getCenter(d.center),d.radius=h.min.distanceTo(h.max)/2,o.boundingSphere=d}(n,e,t),Promise.all(r).then(function(){return e.targets!==void 0?function(o,a,l){let c=!1,h=!1,u=!1;for(let g=0,m=a.length;g<m;g++){const p=a[g];if(p.POSITION!==void 0&&(c=!0),p.NORMAL!==void 0&&(h=!0),p.COLOR_0!==void 0&&(u=!0),c&&h&&u)break}if(!c&&!h&&!u)return Promise.resolve(o);const d=[],f=[],A=[];for(let g=0,m=a.length;g<m;g++){const p=a[g];if(c){const v=p.POSITION!==void 0?l.getDependency("accessor",p.POSITION):o.attributes.position;d.push(v)}if(h){const v=p.NORMAL!==void 0?l.getDependency("accessor",p.NORMAL):o.attributes.normal;f.push(v)}if(u){const v=p.COLOR_0!==void 0?l.getDependency("accessor",p.COLOR_0):o.attributes.color;A.push(v)}}return Promise.all([Promise.all(d),Promise.all(f),Promise.all(A)]).then(function(g){const m=g[0],p=g[1],v=g[2];return c&&(o.morphAttributes.position=m),h&&(o.morphAttributes.normal=p),u&&(o.morphAttributes.color=v),o.morphTargetsRelative=!0,o})}(n,e.targets,t):n})}class QP{constructor(e=4){this.pool=e,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}_initWorker(e){if(!this.workers[e]){const t=this.workerCreator();t.addEventListener("message",this._onMessage.bind(this,e)),this.workers[e]=t}}_getIdleWorker(){for(let e=0;e<this.pool;e++)if(!(this.workerStatus&1<<e))return e;return-1}_onMessage(e,t){const i=this.workersResolve[e];if(i&&i(t),this.queue.length){const{resolve:r,msg:s,transfer:o}=this.queue.shift();this.workersResolve[e]=r,this.workers[e].postMessage(s,o)}else this.workerStatus^=1<<e}setWorkerCreator(e){this.workerCreator=e}setWorkerLimit(e){this.pool=e}postMessage(e,t){return new Promise(i=>{const r=this._getIdleWorker();r!==-1?(this._initWorker(r),this.workerStatus|=1<<r,this.workersResolve[r]=i,this.workers[r].postMessage(e,t)):this.queue.push({resolve:i,msg:e,transfer:t})})}dispose(){this.workers.forEach(e=>e.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const UM=9,FM=15,NM=16,OM=22,kM=37,GM=43,zM=76,HM=83,VM=97,QM=100,WM=103,XM=109,qM=165,YM=166,z0=1000066e3;class WP{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class bl{constructor(e,t,i,r){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(e.buffer,e.byteOffset+t,i),this._littleEndian=r,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_nextInt32(){const e=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint8Array(e){const t=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,e);return this._offset+=e,t}_skip(e){return this._offset+=e,this}_scan(e,t){t===void 0&&(t=0);const i=this._offset;let r=0;for(;this._dataView.getUint8(this._offset)!==t&&r<e;)r++,this._offset++;return r<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+i,r)}}const Rn=[171,75,84,88,32,50,48,187,13,10,26,10];function Ax(n){return new TextDecoder().decode(n)}var XP=nt(9922).hp;let qp,gr,qA;const Yp={env:{emscripten_notify_memory_growth:function(n){qA=new Uint8Array(gr.exports.memory.buffer)}}};class qP{init(){return qp||(qp=typeof fetch<"u"?fetch("data:application/wasm;base64,"+gx).then(e=>e.arrayBuffer()).then(e=>WebAssembly.instantiate(e,Yp)).then(this._init):WebAssembly.instantiate(XP.from(gx,"base64"),Yp).then(this._init),qp)}_init(e){gr=e.instance,Yp.env.emscripten_notify_memory_growth(0)}decode(e,t=0){if(!gr)throw new Error("ZSTDDecoder: Await .init() before decoding.");const i=e.byteLength,r=gr.exports.malloc(i);qA.set(e,r),t=t||Number(gr.exports.ZSTD_findDecompressedSize(r,i));const s=gr.exports.malloc(t),o=gr.exports.ZSTD_decompress(s,t,r,i),a=qA.slice(s,s+o);return gr.exports.free(r),gr.exports.free(s),a}}const gx="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",jp=new WeakMap;let $p,Kp=0;class ni extends C.Loader{constructor(e){super(e),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new QP,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(e){return this.transcoderPath=e,this}setWorkerLimit(e){return this.workerPool.setWorkerLimit(e),this}async detectSupportAsync(e){return this.workerConfig={astcSupported:await e.hasFeatureAsync("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:await e.hasFeatureAsync("texture-compression-etc1"),etc2Supported:await e.hasFeatureAsync("texture-compression-etc2"),dxtSupported:await e.hasFeatureAsync("texture-compression-bc"),bptcSupported:await e.hasFeatureAsync("texture-compression-bptc"),pvrtcSupported:await e.hasFeatureAsync("texture-compression-pvrtc")},this}detectSupport(e){return e.isWebGPURenderer===!0?this.workerConfig={astcSupported:e.hasFeature("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:e.hasFeature("texture-compression-etc1"),etc2Supported:e.hasFeature("texture-compression-etc2"),dxtSupported:e.hasFeature("texture-compression-bc"),bptcSupported:e.hasFeature("texture-compression-bptc"),pvrtcSupported:e.hasFeature("texture-compression-pvrtc")}:this.workerConfig={astcSupported:e.extensions.has("WEBGL_compressed_texture_astc"),astcHDRSupported:e.extensions.has("WEBGL_compressed_texture_astc")&&e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),etc1Supported:e.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:e.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:e.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:e.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:e.extensions.has("WEBGL_compressed_texture_pvrtc")||e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}init(){if(!this.transcoderPending){const e=new C.FileLoader(this.manager);e.setPath(this.transcoderPath),e.setWithCredentials(this.withCredentials);const t=e.loadAsync("basis_transcoder.js"),i=new C.FileLoader(this.manager);i.setPath(this.transcoderPath),i.setResponseType("arraybuffer"),i.setWithCredentials(this.withCredentials);const r=i.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([t,r]).then(([s,o])=>{const a=ni.BasisWorker.toString(),l=["/* constants */","let _EngineFormat = "+JSON.stringify(ni.EngineFormat),"let _EngineType = "+JSON.stringify(ni.EngineType),"let _TranscoderFormat = "+JSON.stringify(ni.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(ni.BasisFormat),"/* basis_transcoder.js */",s,"/* worker */",a.substring(a.indexOf("{")+1,a.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([l])),this.transcoderBinary=o,this.workerPool.setWorkerCreator(()=>{const c=new Worker(this.workerSourceURL),h=this.transcoderBinary.slice(0);return c.postMessage({type:"init",config:this.workerConfig,transcoderBinary:h},[h]),c})}),Kp>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),Kp++}return this.transcoderPending}load(e,t,i,r){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const s=new C.FileLoader(this.manager);s.setResponseType("arraybuffer"),s.setWithCredentials(this.withCredentials),s.load(e,o=>{this.parse(o,t,r)},i,r)}parse(e,t,i){if(this.workerConfig===null)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");if(jp.has(e))return jp.get(e).promise.then(t).catch(i);this._createTexture(e).then(r=>t?t(r):null).catch(i)}_createTextureFrom(e,t){const{type:i,error:r,data:{faces:s,width:o,height:a,format:l,type:c,dfdFlags:h}}=e;if(i==="error")return Promise.reject(r);let u;if(t.faceCount===6)u=new C.CompressedCubeTexture(s,l,c);else{const d=s[0].mipmaps;u=t.layerCount>1?new C.CompressedArrayTexture(d,o,a,t.layerCount,l,c):new C.CompressedTexture(d,o,a,l,c)}return u.minFilter=s[0].mipmaps.length===1?C.LinearFilter:C.LinearMipmapLinearFilter,u.magFilter=C.LinearFilter,u.generateMipmaps=!1,u.needsUpdate=!0,u.colorSpace=vx(t),u.premultiplyAlpha=!!(1&h),u}async _createTexture(e,t={}){const i=function(a){const l=new Uint8Array(a.buffer,a.byteOffset,Rn.length);if(l[0]!==Rn[0]||l[1]!==Rn[1]||l[2]!==Rn[2]||l[3]!==Rn[3]||l[4]!==Rn[4]||l[5]!==Rn[5]||l[6]!==Rn[6]||l[7]!==Rn[7]||l[8]!==Rn[8]||l[9]!==Rn[9]||l[10]!==Rn[10]||l[11]!==Rn[11])throw new Error("Missing KTX 2.0 identifier.");const c=new WP,h=17*Uint32Array.BYTES_PER_ELEMENT,u=new bl(a,Rn.length,h,!0);c.vkFormat=u._nextUint32(),c.typeSize=u._nextUint32(),c.pixelWidth=u._nextUint32(),c.pixelHeight=u._nextUint32(),c.pixelDepth=u._nextUint32(),c.layerCount=u._nextUint32(),c.faceCount=u._nextUint32();const d=u._nextUint32();c.supercompressionScheme=u._nextUint32();const f=u._nextUint32(),A=u._nextUint32(),g=u._nextUint32(),m=u._nextUint32(),p=u._nextUint64(),v=u._nextUint64(),E=new bl(a,Rn.length+h,3*d*8,!0);for(let le=0;le<d;le++)c.levels.push({levelData:new Uint8Array(a.buffer,a.byteOffset+E._nextUint64(),E._nextUint64()),uncompressedByteLength:E._nextUint64()});const x=new bl(a,f,A,!0),M={vendorId:x._skip(4)._nextUint16(),descriptorType:x._nextUint16(),versionNumber:x._nextUint16(),descriptorBlockSize:x._nextUint16(),colorModel:x._nextUint8(),colorPrimaries:x._nextUint8(),transferFunction:x._nextUint8(),flags:x._nextUint8(),texelBlockDimension:[x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8()],bytesPlane:[x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8()],samples:[]},w=(M.descriptorBlockSize/4-6)/4;for(let le=0;le<w;le++){const Ee={bitOffset:x._nextUint16(),bitLength:x._nextUint8(),channelType:x._nextUint8(),samplePosition:[x._nextUint8(),x._nextUint8(),x._nextUint8(),x._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};64&Ee.channelType?(Ee.sampleLower=x._nextInt32(),Ee.sampleUpper=x._nextInt32()):(Ee.sampleLower=x._nextUint32(),Ee.sampleUpper=x._nextUint32()),M.samples[le]=Ee}c.dataFormatDescriptor.length=0,c.dataFormatDescriptor.push(M);const S=new bl(a,g,m,!0);for(;S._offset<m;){const le=S._nextUint32(),Ee=S._scan(le),Ue=Ax(Ee);if(c.keyValue[Ue]=S._nextUint8Array(le-Ee.byteLength-1),Ue.match(/^ktx/i)){const pe=Ax(c.keyValue[Ue]);c.keyValue[Ue]=pe.substring(0,pe.lastIndexOf("\0"))}S._skip(le%4?4-le%4:0)}if(v<=0)return c;const B=new bl(a,p,v,!0),y=B._nextUint16(),_=B._nextUint16(),L=B._nextUint32(),Q=B._nextUint32(),O=B._nextUint32(),X=B._nextUint32(),te=[];for(let le=0;le<d;le++)te.push({imageFlags:B._nextUint32(),rgbSliceByteOffset:B._nextUint32(),rgbSliceByteLength:B._nextUint32(),alphaSliceByteOffset:B._nextUint32(),alphaSliceByteLength:B._nextUint32()});const W=p+B._offset,Z=W+L,q=Z+Q,re=q+O,ue=new Uint8Array(a.buffer,a.byteOffset+W,L),_e=new Uint8Array(a.buffer,a.byteOffset+Z,Q),Be=new Uint8Array(a.buffer,a.byteOffset+q,O),ze=new Uint8Array(a.buffer,a.byteOffset+re,X);return c.globalData={endpointCount:y,selectorCount:_,imageDescs:te,endpointsData:ue,selectorsData:_e,tablesData:Be,extendedData:ze},c}(new Uint8Array(e)),r=i.vkFormat===z0&&i.dataFormatDescriptor[0].colorModel===167;if(i.vkFormat!==0&&(!r||this.workerConfig.astcHDRSupported))return async function(a){const{vkFormat:l}=a;if(Jp[l]===void 0)throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");let c;a.supercompressionScheme===2&&($p||($p=new Promise(async d=>{const f=new qP;await f.init(),d(f)})),c=await $p);const h=[];for(let d=0;d<a.levels.length;d++){const f=Math.max(1,a.pixelWidth>>d),A=Math.max(1,a.pixelHeight>>d),g=a.pixelDepth?Math.max(1,a.pixelDepth>>d):0,m=a.levels[d];let p,v;if(a.supercompressionScheme===0)p=m.levelData;else{if(a.supercompressionScheme!==2)throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");p=c.decode(m.levelData,m.uncompressedByteLength)}v=Zp[l]===C.FloatType?new Float32Array(p.buffer,p.byteOffset,p.byteLength/Float32Array.BYTES_PER_ELEMENT):Zp[l]===C.HalfFloatType?new Uint16Array(p.buffer,p.byteOffset,p.byteLength/Uint16Array.BYTES_PER_ELEMENT):p,h.push({data:v,width:f,height:A,depth:g})}let u;if(YP.has(Jp[l]))u=a.pixelDepth===0?new C.DataTexture(h[0].data,a.pixelWidth,a.pixelHeight):new C.Data3DTexture(h[0].data,a.pixelWidth,a.pixelHeight,a.pixelDepth);else{if(a.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");u=new C.CompressedTexture(h,a.pixelWidth,a.pixelHeight),u.minFilter=h.length===1?C.LinearFilter:C.LinearMipmapLinearFilter,u.magFilter=C.LinearFilter}return u.mipmaps=h,u.type=Zp[l],u.format=Jp[l],u.colorSpace=vx(a),u.needsUpdate=!0,Promise.resolve(u)}(i);const s=t,o=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffer:e,taskConfig:s},[e])).then(a=>this._createTextureFrom(a.data,i));return jp.set(e,{promise:o}),o}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),Kp--,this}}ni.BasisFormat={ETC1S:0,UASTC:1,UASTC_HDR:2},ni.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16,BC6H:22,RGB_HALF:24,RGBA_HALF:25},ni.EngineFormat={RGBAFormat:C.RGBAFormat,RGBA_ASTC_4x4_Format:C.RGBA_ASTC_4x4_Format,RGB_BPTC_UNSIGNED_Format:C.RGB_BPTC_UNSIGNED_Format,RGBA_BPTC_Format:C.RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:C.RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format:C.RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format:C.RGBA_S3TC_DXT5_Format,RGB_ETC1_Format:C.RGB_ETC1_Format,RGB_ETC2_Format:C.RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format:C.RGB_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format:C.RGBA_S3TC_DXT1_Format},ni.EngineType={UnsignedByteType:C.UnsignedByteType,HalfFloatType:C.HalfFloatType,FloatType:C.FloatType},ni.BasisWorker=function(){let n,e,t;const i=_EngineFormat,r=_EngineType,s=_TranscoderFormat,o=_BasisFormat;self.addEventListener("message",function(u){const d=u.data;switch(d.type){case"init":n=d.config,f=d.transcoderBinary,e=new Promise(A=>{t={wasmBinary:f,onRuntimeInitialized:A},BASIS(t)}).then(()=>{t.initializeBasis(),t.KTX2File===void 0&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")});break;case"transcode":e.then(()=>{try{const{faces:A,buffers:g,width:m,height:p,hasAlpha:v,format:E,type:x,dfdFlags:M}=function(w){const S=new t.KTX2File(new Uint8Array(w));function B(){S.close(),S.delete()}if(!S.isValid())throw B(),new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");let y;if(S.isUASTC())y=o.UASTC;else if(S.isETC1S())y=o.ETC1S;else{if(!S.isHDR())throw new Error("THREE.KTX2Loader: Unknown Basis encoding");y=o.UASTC_HDR}const _=S.getWidth(),L=S.getHeight(),Q=S.getLayers()||1,O=S.getLevels(),X=S.getFaces(),te=S.getHasAlpha(),W=S.getDFDFlags(),{transcoderFormat:Z,engineFormat:q,engineType:re}=function(Be,ze,le,Ee){const Ue=l[Be];for(let pe=0;pe<Ue.length;pe++){const oe=Ue[pe];if((!oe.if||n[oe.if])&&oe.basisFormat.includes(Be)&&!(Ee&&oe.transcoderFormat.length<2)&&(!oe.needsPowerOfTwo||c(ze)&&c(le)))return{transcoderFormat:oe.transcoderFormat[Ee?1:0],engineFormat:oe.engineFormat[Ee?1:0],engineType:oe.engineType[0]}}throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")}(y,_,L,te);if(!_||!L||!O)throw B(),new Error("THREE.KTX2Loader:	Invalid texture");if(!S.startTranscoding())throw B(),new Error("THREE.KTX2Loader: .startTranscoding failed");const ue=[],_e=[];for(let Be=0;Be<X;Be++){const ze=[];for(let le=0;le<O;le++){const Ee=[];let Ue,pe;for(let we=0;we<Q;we++){const Me=S.getImageLevelInfo(le,we,Be);Be!==0||le!==0||we!==0||Me.origWidth%4==0&&Me.origHeight%4==0||console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),O>1?(Ue=Me.origWidth,pe=Me.origHeight):(Ue=Me.width,pe=Me.height);let Ve=new Uint8Array(S.getImageTranscodedSizeInBytes(le,we,0,Z));const me=S.transcodeImage(Ve,le,we,Be,Z,0,-1,-1);if(re===r.HalfFloatType&&(Ve=new Uint16Array(Ve.buffer,Ve.byteOffset,Ve.byteLength/Uint16Array.BYTES_PER_ELEMENT)),!me)throw B(),new Error("THREE.KTX2Loader: .transcodeImage failed.");Ee.push(Ve)}const oe=h(Ee);ze.push({data:oe,width:Ue,height:pe}),_e.push(oe.buffer)}ue.push({mipmaps:ze,width:_,height:L,format:q,type:re})}return B(),{faces:ue,buffers:_e,width:_,height:L,hasAlpha:te,dfdFlags:W,format:q,type:re}}(d.buffer);self.postMessage({type:"transcode",id:d.id,data:{faces:A,width:m,height:p,hasAlpha:v,format:E,type:x,dfdFlags:M}},g)}catch(A){console.error(A),self.postMessage({type:"error",id:d.id,error:A.message})}})}var f});const a=[{if:"astcSupported",basisFormat:[o.UASTC],transcoderFormat:[s.ASTC_4x4,s.ASTC_4x4],engineFormat:[i.RGBA_ASTC_4x4_Format,i.RGBA_ASTC_4x4_Format],engineType:[r.UnsignedByteType],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[o.ETC1S,o.UASTC],transcoderFormat:[s.BC7_M5,s.BC7_M5],engineFormat:[i.RGBA_BPTC_Format,i.RGBA_BPTC_Format],engineType:[r.UnsignedByteType],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[o.ETC1S,o.UASTC],transcoderFormat:[s.BC1,s.BC3],engineFormat:[i.RGBA_S3TC_DXT1_Format,i.RGBA_S3TC_DXT5_Format],engineType:[r.UnsignedByteType],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[o.ETC1S,o.UASTC],transcoderFormat:[s.ETC1,s.ETC2],engineFormat:[i.RGB_ETC2_Format,i.RGBA_ETC2_EAC_Format],engineType:[r.UnsignedByteType],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[o.ETC1S,o.UASTC],transcoderFormat:[s.ETC1],engineFormat:[i.RGB_ETC1_Format],engineType:[r.UnsignedByteType],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[o.ETC1S,o.UASTC],transcoderFormat:[s.PVRTC1_4_RGB,s.PVRTC1_4_RGBA],engineFormat:[i.RGB_PVRTC_4BPPV1_Format,i.RGBA_PVRTC_4BPPV1_Format],engineType:[r.UnsignedByteType],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0},{if:"bptcSupported",basisFormat:[o.UASTC_HDR],transcoderFormat:[s.BC6H],engineFormat:[i.RGB_BPTC_UNSIGNED_Format],engineType:[r.HalfFloatType],priorityHDR:1,needsPowerOfTwo:!1},{basisFormat:[o.ETC1S,o.UASTC],transcoderFormat:[s.RGBA32,s.RGBA32],engineFormat:[i.RGBAFormat,i.RGBAFormat],engineType:[r.UnsignedByteType,r.UnsignedByteType],priorityETC1S:100,priorityUASTC:100,needsPowerOfTwo:!1},{basisFormat:[o.UASTC_HDR],transcoderFormat:[s.RGBA_HALF],engineFormat:[i.RGBAFormat],engineType:[r.HalfFloatType],priorityHDR:100,needsPowerOfTwo:!1}],l={[o.ETC1S]:a.filter(u=>u.basisFormat.includes(o.ETC1S)).sort((u,d)=>u.priorityUASTC-d.priorityUASTC),[o.UASTC]:a.filter(u=>u.basisFormat.includes(o.UASTC)).sort((u,d)=>u.priorityUASTC-d.priorityUASTC),[o.UASTC_HDR]:a.filter(u=>u.basisFormat.includes(o.UASTC_HDR)).sort((u,d)=>u.priorityHDR-d.priorityHDR)};function c(u){return u<=2||!(u&u-1)&&u!==0}function h(u){if(u.length===1)return u[0];let d=0;for(let g=0;g<u.length;g++)d+=u[g].byteLength;const f=new Uint8Array(d);let A=0;for(let g=0;g<u.length;g++){const m=u[g];f.set(m,A),A+=m.byteLength}return f}};const YP=new Set([C.RGBAFormat,C.RGFormat,C.RedFormat]),Jp={[XM]:C.RGBAFormat,[VM]:C.RGBAFormat,[kM]:C.RGBAFormat,[GM]:C.RGBAFormat,[WM]:C.RGFormat,[HM]:C.RGFormat,[NM]:C.RGFormat,[OM]:C.RGFormat,[QM]:C.RedFormat,[zM]:C.RedFormat,[FM]:C.RedFormat,[UM]:C.RedFormat,[z0]:C.RGBA_ASTC_4x4_Format,[YM]:C.RGBA_ASTC_6x6_Format,[qM]:C.RGBA_ASTC_6x6_Format},Zp={[XM]:C.FloatType,[VM]:C.HalfFloatType,[kM]:C.UnsignedByteType,[GM]:C.UnsignedByteType,[WM]:C.FloatType,[HM]:C.HalfFloatType,[NM]:C.UnsignedByteType,[OM]:C.UnsignedByteType,[QM]:C.FloatType,[zM]:C.HalfFloatType,[FM]:C.UnsignedByteType,[UM]:C.UnsignedByteType,[z0]:C.HalfFloatType,[YM]:C.UnsignedByteType,[qM]:C.UnsignedByteType};function vx(n){const e=n.dataFormatDescriptor[0];return e.colorPrimaries===1?e.transferFunction===2?C.SRGBColorSpace:C.LinearSRGBColorSpace:e.colorPrimaries===10?e.transferFunction===2?"display-p3":"display-p3-linear":(e.colorPrimaries===0||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`),C.NoColorSpace)}const St={c:null,u:[new C.Vector3,new C.Vector3,new C.Vector3],e:[]},Lt={c:null,u:[new C.Vector3,new C.Vector3,new C.Vector3],e:[]},Vt=[[],[],[]],mt=[[],[],[]],Ht=[],Ys=new C.Vector3,js=new C.Vector3,$s=new C.Vector3,rn=new C.Vector3,Ex=new C.Vector3,xx=new C.Vector3,_i=new C.Matrix3,yx=new C.Box3,Vh=new C.Matrix4,_x=new C.Matrix4,bx=new C.Ray;class Vd{constructor(e=new C.Vector3,t=new C.Vector3,i=new C.Matrix3){this.center=e,this.halfSize=t,this.rotation=i}set(e,t,i){return this.center=e,this.halfSize=t,this.rotation=i,this}copy(e){return this.center.copy(e.center),this.halfSize.copy(e.halfSize),this.rotation.copy(e.rotation),this}clone(){return new this.constructor().copy(this)}getSize(e){return e.copy(this.halfSize).multiplyScalar(2)}clampPoint(e,t){const i=this.halfSize;rn.subVectors(e,this.center),this.rotation.extractBasis(Ys,js,$s),t.copy(this.center);const r=C.MathUtils.clamp(rn.dot(Ys),-i.x,i.x);t.add(Ys.multiplyScalar(r));const s=C.MathUtils.clamp(rn.dot(js),-i.y,i.y);t.add(js.multiplyScalar(s));const o=C.MathUtils.clamp(rn.dot($s),-i.z,i.z);return t.add($s.multiplyScalar(o)),t}containsPoint(e){return rn.subVectors(e,this.center),this.rotation.extractBasis(Ys,js,$s),Math.abs(rn.dot(Ys))<=this.halfSize.x&&Math.abs(rn.dot(js))<=this.halfSize.y&&Math.abs(rn.dot($s))<=this.halfSize.z}intersectsBox3(e){return this.intersectsOBB(jP.fromBox3(e))}intersectsSphere(e){return this.clampPoint(e.center,xx),xx.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,t=Number.EPSILON){St.c=this.center,St.e[0]=this.halfSize.x,St.e[1]=this.halfSize.y,St.e[2]=this.halfSize.z,this.rotation.extractBasis(St.u[0],St.u[1],St.u[2]),Lt.c=e.center,Lt.e[0]=e.halfSize.x,Lt.e[1]=e.halfSize.y,Lt.e[2]=e.halfSize.z,e.rotation.extractBasis(Lt.u[0],Lt.u[1],Lt.u[2]);for(let s=0;s<3;s++)for(let o=0;o<3;o++)Vt[s][o]=St.u[s].dot(Lt.u[o]);rn.subVectors(Lt.c,St.c),Ht[0]=rn.dot(St.u[0]),Ht[1]=rn.dot(St.u[1]),Ht[2]=rn.dot(St.u[2]);for(let s=0;s<3;s++)for(let o=0;o<3;o++)mt[s][o]=Math.abs(Vt[s][o])+t;let i,r;for(let s=0;s<3;s++)if(i=St.e[s],r=Lt.e[0]*mt[s][0]+Lt.e[1]*mt[s][1]+Lt.e[2]*mt[s][2],Math.abs(Ht[s])>i+r)return!1;for(let s=0;s<3;s++)if(i=St.e[0]*mt[0][s]+St.e[1]*mt[1][s]+St.e[2]*mt[2][s],r=Lt.e[s],Math.abs(Ht[0]*Vt[0][s]+Ht[1]*Vt[1][s]+Ht[2]*Vt[2][s])>i+r)return!1;return i=St.e[1]*mt[2][0]+St.e[2]*mt[1][0],r=Lt.e[1]*mt[0][2]+Lt.e[2]*mt[0][1],!(Math.abs(Ht[2]*Vt[1][0]-Ht[1]*Vt[2][0])>i+r||(i=St.e[1]*mt[2][1]+St.e[2]*mt[1][1],r=Lt.e[0]*mt[0][2]+Lt.e[2]*mt[0][0],Math.abs(Ht[2]*Vt[1][1]-Ht[1]*Vt[2][1])>i+r||(i=St.e[1]*mt[2][2]+St.e[2]*mt[1][2],r=Lt.e[0]*mt[0][1]+Lt.e[1]*mt[0][0],Math.abs(Ht[2]*Vt[1][2]-Ht[1]*Vt[2][2])>i+r||(i=St.e[0]*mt[2][0]+St.e[2]*mt[0][0],r=Lt.e[1]*mt[1][2]+Lt.e[2]*mt[1][1],Math.abs(Ht[0]*Vt[2][0]-Ht[2]*Vt[0][0])>i+r||(i=St.e[0]*mt[2][1]+St.e[2]*mt[0][1],r=Lt.e[0]*mt[1][2]+Lt.e[2]*mt[1][0],Math.abs(Ht[0]*Vt[2][1]-Ht[2]*Vt[0][1])>i+r||(i=St.e[0]*mt[2][2]+St.e[2]*mt[0][2],r=Lt.e[0]*mt[1][1]+Lt.e[1]*mt[1][0],Math.abs(Ht[0]*Vt[2][2]-Ht[2]*Vt[0][2])>i+r||(i=St.e[0]*mt[1][0]+St.e[1]*mt[0][0],r=Lt.e[1]*mt[2][2]+Lt.e[2]*mt[2][1],Math.abs(Ht[1]*Vt[0][0]-Ht[0]*Vt[1][0])>i+r||(i=St.e[0]*mt[1][1]+St.e[1]*mt[0][1],r=Lt.e[0]*mt[2][2]+Lt.e[2]*mt[2][0],Math.abs(Ht[1]*Vt[0][1]-Ht[0]*Vt[1][1])>i+r||(i=St.e[0]*mt[1][2]+St.e[1]*mt[0][2],r=Lt.e[0]*mt[2][1]+Lt.e[1]*mt[2][0],Math.abs(Ht[1]*Vt[0][2]-Ht[0]*Vt[1][2])>i+r)))))))))}intersectsPlane(e){this.rotation.extractBasis(Ys,js,$s);const t=this.halfSize.x*Math.abs(e.normal.dot(Ys))+this.halfSize.y*Math.abs(e.normal.dot(js))+this.halfSize.z*Math.abs(e.normal.dot($s)),i=e.normal.dot(this.center)-e.constant;return Math.abs(i)<=t}intersectRay(e,t){return this.getSize(Ex),yx.setFromCenterAndSize(rn.set(0,0,0),Ex),Vh.setFromMatrix3(this.rotation),Vh.setPosition(this.center),_x.copy(Vh).invert(),bx.copy(e).applyMatrix4(_x),bx.intersectBox(yx,t)?t.applyMatrix4(Vh):null}intersectsRay(e){return this.intersectRay(e,rn)!==null}fromBox3(e){return e.getCenter(this.center),e.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(e){return e.center.equals(this.center)&&e.halfSize.equals(this.halfSize)&&e.rotation.equals(this.rotation)}applyMatrix4(e){const t=e.elements;let i=rn.set(t[0],t[1],t[2]).length();const r=rn.set(t[4],t[5],t[6]).length(),s=rn.set(t[8],t[9],t[10]).length();e.determinant()<0&&(i=-i),_i.setFromMatrix4(e);const o=1/i,a=1/r,l=1/s;return _i.elements[0]*=o,_i.elements[1]*=o,_i.elements[2]*=o,_i.elements[3]*=a,_i.elements[4]*=a,_i.elements[5]*=a,_i.elements[6]*=l,_i.elements[7]*=l,_i.elements[8]*=l,this.rotation.multiply(_i),this.halfSize.x*=i,this.halfSize.y*=r,this.halfSize.z*=s,rn.setFromMatrixPosition(e),this.center.add(rn),this}}const jP=new Vd,$P=/^[og]\s*(.+)?/,KP=/^mtllib /,JP=/^usemtl /,ZP=/^usemap /,Cx=/\s+/,Mx=new C.Vector3,em=new C.Vector3,Sx=new C.Vector3,wx=new C.Vector3,ci=new C.Vector3,Qh=new C.Color;function eU(){const n={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1)return this.object.name=e,void(this.object.fromDeclaration=t!==!1);const i=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(r,s){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const a={index:this.materials.length,name:r||"",mtllib:Array.isArray(s)&&s.length>0?s[s.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(l){const c={index:typeof l=="number"?l:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(r){const s=this.currentMaterial();if(s&&s.groupEnd===-1&&(s.groupEnd=this.geometry.vertices.length/3,s.groupCount=s.groupEnd-s.groupStart,s.inherited=!1),r&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return r&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),s}},i&&i.name&&typeof i.clone=="function"){const r=i.clone(0);r.inherited=!0,this.object.materials.push(r)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const i=parseInt(e,10);return 3*(i>=0?i-1:i+t/3)},parseNormalIndex:function(e,t){const i=parseInt(e,10);return 3*(i>=0?i-1:i+t/3)},parseUVIndex:function(e,t){const i=parseInt(e,10);return 2*(i>=0?i-1:i+t/2)},addVertex:function(e,t,i){const r=this.vertices,s=this.object.geometry.vertices;s.push(r[e+0],r[e+1],r[e+2]),s.push(r[t+0],r[t+1],r[t+2]),s.push(r[i+0],r[i+1],r[i+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,i){const r=this.normals,s=this.object.geometry.normals;s.push(r[e+0],r[e+1],r[e+2]),s.push(r[t+0],r[t+1],r[t+2]),s.push(r[i+0],r[i+1],r[i+2])},addFaceNormal:function(e,t,i){const r=this.vertices,s=this.object.geometry.normals;Mx.fromArray(r,e),em.fromArray(r,t),Sx.fromArray(r,i),ci.subVectors(Sx,em),wx.subVectors(Mx,em),ci.cross(wx),ci.normalize(),s.push(ci.x,ci.y,ci.z),s.push(ci.x,ci.y,ci.z),s.push(ci.x,ci.y,ci.z)},addColor:function(e,t,i){const r=this.colors,s=this.object.geometry.colors;r[e]!==void 0&&s.push(r[e+0],r[e+1],r[e+2]),r[t]!==void 0&&s.push(r[t+0],r[t+1],r[t+2]),r[i]!==void 0&&s.push(r[i+0],r[i+1],r[i+2])},addUV:function(e,t,i){const r=this.uvs,s=this.object.geometry.uvs;s.push(r[e+0],r[e+1]),s.push(r[t+0],r[t+1]),s.push(r[i+0],r[i+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,i,r,s,o,a,l,c){const h=this.vertices.length;let u=this.parseVertexIndex(e,h),d=this.parseVertexIndex(t,h),f=this.parseVertexIndex(i,h);if(this.addVertex(u,d,f),this.addColor(u,d,f),a!==void 0&&a!==""){const A=this.normals.length;u=this.parseNormalIndex(a,A),d=this.parseNormalIndex(l,A),f=this.parseNormalIndex(c,A),this.addNormal(u,d,f)}else this.addFaceNormal(u,d,f);if(r!==void 0&&r!==""){const A=this.uvs.length;u=this.parseUVIndex(r,A),d=this.parseUVIndex(s,A),f=this.parseUVIndex(o,A),this.addUV(u,d,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let i=0,r=e.length;i<r;i++){const s=this.parseVertexIndex(e[i],t);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const i=this.vertices.length,r=this.uvs.length;for(let s=0,o=e.length;s<o;s++)this.addVertexLine(this.parseVertexIndex(e[s],i));for(let s=0,o=t.length;s<o;s++)this.addUVLine(this.parseUVIndex(t[s],r))}};return n.startObject("",!1),n}class jM extends C.Loader{constructor(e){super(e),this.materials=null}load(e,t,i,r){const s=this,o=new C.FileLoader(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(s.parse(a))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}setMaterials(e){return this.materials=e,this}parse(e){const t=new eU;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const i=e.split(`
`);let r=[];for(let o=0,a=i.length;o<a;o++){const l=i[o].trimStart();if(l.length===0)continue;const c=l.charAt(0);if(c!=="#")if(c==="v"){const h=l.split(Cx);switch(h[0]){case"v":t.vertices.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3])),h.length>=7?(Qh.setRGB(parseFloat(h[4]),parseFloat(h[5]),parseFloat(h[6]),C.SRGBColorSpace),t.colors.push(Qh.r,Qh.g,Qh.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3]));break;case"vt":t.uvs.push(parseFloat(h[1]),parseFloat(h[2]))}}else if(c==="f"){const h=l.slice(1).trim().split(Cx),u=[];for(let f=0,A=h.length;f<A;f++){const g=h[f];if(g.length>0){const m=g.split("/");u.push(m)}}const d=u[0];for(let f=1,A=u.length-1;f<A;f++){const g=u[f],m=u[f+1];t.addFace(d[0],g[0],m[0],d[1],g[1],m[1],d[2],g[2],m[2])}}else if(c==="l"){const h=l.substring(1).trim().split(" ");let u=[];const d=[];if(l.indexOf("/")===-1)u=h;else for(let f=0,A=h.length;f<A;f++){const g=h[f].split("/");g[0]!==""&&u.push(g[0]),g[1]!==""&&d.push(g[1])}t.addLineGeometry(u,d)}else if(c==="p"){const h=l.slice(1).trim().split(" ");t.addPointGeometry(h)}else if((r=$P.exec(l))!==null){const h=(" "+r[0].slice(1).trim()).slice(1);t.startObject(h)}else if(JP.test(l))t.object.startMaterial(l.substring(7).trim(),t.materialLibraries);else if(KP.test(l))t.materialLibraries.push(l.substring(7).trim());else if(ZP.test(l))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(c==="s"){if(r=l.split(" "),r.length>1){const u=r[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const h=t.object.currentMaterial();h&&(h.smooth=t.object.smooth)}else{if(l==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+l+'"')}}t.finalize();const s=new C.Group;if(s.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0))for(let o=0,a=t.objects.length;o<a;o++){const l=t.objects[o],c=l.geometry,h=l.materials,u=c.type==="Line",d=c.type==="Points";let f=!1;if(c.vertices.length===0)continue;const A=new C.BufferGeometry;A.setAttribute("position",new C.Float32BufferAttribute(c.vertices,3)),c.normals.length>0&&A.setAttribute("normal",new C.Float32BufferAttribute(c.normals,3)),c.colors.length>0&&(f=!0,A.setAttribute("color",new C.Float32BufferAttribute(c.colors,3))),c.hasUVIndices===!0&&A.setAttribute("uv",new C.Float32BufferAttribute(c.uvs,2));const g=[];for(let p=0,v=h.length;p<v;p++){const E=h[p],x=E.name+"_"+E.smooth+"_"+f;let M=t.materials[x];if(this.materials!==null)if(M=this.materials.create(E.name),!u||!M||M instanceof C.LineBasicMaterial){if(d&&M&&!(M instanceof C.PointsMaterial)){const w=new C.PointsMaterial({size:10,sizeAttenuation:!1});C.Material.prototype.copy.call(w,M),w.color.copy(M.color),w.map=M.map,M=w}}else{const w=new C.LineBasicMaterial;C.Material.prototype.copy.call(w,M),w.color.copy(M.color),M=w}M===void 0&&(M=u?new C.LineBasicMaterial:d?new C.PointsMaterial({size:1,sizeAttenuation:!1}):new C.MeshPhongMaterial,M.name=E.name,M.flatShading=!E.smooth,M.vertexColors=f,t.materials[x]=M),g.push(M)}let m;if(g.length>1){for(let p=0,v=h.length;p<v;p++){const E=h[p];A.addGroup(E.groupStart,E.groupCount,p)}m=u?new C.LineSegments(A,g):d?new C.Points(A,g):new C.Mesh(A,g)}else m=u?new C.LineSegments(A,g[0]):d?new C.Points(A,g[0]):new C.Mesh(A,g[0]);m.name=l.name,s.add(m)}else if(t.vertices.length>0){const o=new C.PointsMaterial({size:1,sizeAttenuation:!1}),a=new C.BufferGeometry;a.setAttribute("position",new C.Float32BufferAttribute(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(a.setAttribute("color",new C.Float32BufferAttribute(t.colors,3)),o.vertexColors=!0);const l=new C.Points(a,o);s.add(l)}return s}}class $M extends C.Loader{constructor(e){super(e)}load(e,t,i,r){const s=this,o=this.path===""?C.LoaderUtils.extractUrlBase(e):this.path,a=new C.FileLoader(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{t(s.parse(l,o))}catch(c){r?r(c):console.error(c),s.manager.itemError(e)}},i,r)}setMaterialOptions(e){return this.materialOptions=e,this}parse(e,t){const i=e.split(`
`);let r={};const s=/\s+/,o={};for(let l=0;l<i.length;l++){let c=i[l];if(c=c.trim(),c.length===0||c.charAt(0)==="#")continue;const h=c.indexOf(" ");let u=h>=0?c.substring(0,h):c;u=u.toLowerCase();let d=h>=0?c.substring(h+1):"";if(d=d.trim(),u==="newmtl")r={name:d},o[d]=r;else if(u==="ka"||u==="kd"||u==="ks"||u==="ke"){const f=d.split(s,3);r[u]=[parseFloat(f[0]),parseFloat(f[1]),parseFloat(f[2])]}else r[u]=d}const a=new tU(this.resourcePath||t,this.materialOptions);return a.setCrossOrigin(this.crossOrigin),a.setManager(this.manager),a.setMaterials(o),a}}class tU{constructor(e="",t={}){this.baseUrl=e,this.options=t,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=this.options.side!==void 0?this.options.side:C.FrontSide,this.wrap=this.options.wrap!==void 0?this.options.wrap:C.RepeatWrapping}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const t={};for(const i in e){const r=e[i],s={};t[i]=s;for(const o in r){let a=!0,l=r[o];const c=o.toLowerCase();switch(c){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(l=[l[0]/255,l[1]/255,l[2]/255]),this.options&&this.options.ignoreZeroRGBs&&l[0]===0&&l[1]===0&&l[2]===0&&(a=!1)}a&&(s[c]=l)}}return t}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const t in this.materialsInfo)this.materialsArray[e]=this.create(t),this.nameLookup[t]=e,e++;return this.materialsArray}create(e){return this.materials[e]===void 0&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const t=this,i=this.materialsInfo[e],r={name:e,side:this.side};function s(o,a){if(r[o])return;const l=t.getTextureParams(a,r),c=t.loadTexture((h=t.baseUrl,typeof(u=l.url)!="string"||u===""?"":/^https?:\/\//i.test(u)?u:h+u));var h,u;c.repeat.copy(l.scale),c.offset.copy(l.offset),c.wrapS=t.wrap,c.wrapT=t.wrap,o!=="map"&&o!=="emissiveMap"||(c.colorSpace=C.SRGBColorSpace),r[o]=c}for(const o in i){const a=i[o];let l;if(a!=="")switch(o.toLowerCase()){case"kd":r.color=C.ColorManagement.toWorkingColorSpace(new C.Color().fromArray(a),C.SRGBColorSpace);break;case"ks":r.specular=C.ColorManagement.toWorkingColorSpace(new C.Color().fromArray(a),C.SRGBColorSpace);break;case"ke":r.emissive=C.ColorManagement.toWorkingColorSpace(new C.Color().fromArray(a),C.SRGBColorSpace);break;case"map_kd":s("map",a);break;case"map_ks":s("specularMap",a);break;case"map_ke":s("emissiveMap",a);break;case"norm":s("normalMap",a);break;case"map_bump":case"bump":s("bumpMap",a);break;case"map_d":s("alphaMap",a),r.transparent=!0;break;case"ns":r.shininess=parseFloat(a);break;case"d":l=parseFloat(a),l<1&&(r.opacity=l,r.transparent=!0);break;case"tr":l=parseFloat(a),this.options&&this.options.invertTrProperty&&(l=1-l),l>0&&(r.opacity=1-l,r.transparent=!0)}}return this.materials[e]=new C.MeshPhongMaterial(r),this.materials[e]}getTextureParams(e,t){const i={scale:new C.Vector2(1,1),offset:new C.Vector2(0,0)},r=e.split(/\s+/);let s;return s=r.indexOf("-bm"),s>=0&&(t.bumpScale=parseFloat(r[s+1]),r.splice(s,2)),s=r.indexOf("-s"),s>=0&&(i.scale.set(parseFloat(r[s+1]),parseFloat(r[s+2])),r.splice(s,4)),s=r.indexOf("-o"),s>=0&&(i.offset.set(parseFloat(r[s+1]),parseFloat(r[s+2])),r.splice(s,4)),i.url=r.join(" ").trim(),i}loadTexture(e,t,i,r,s){const o=this.manager!==void 0?this.manager:C.DefaultLoadingManager;let a=o.getHandler(e);a===null&&(a=new C.TextureLoader(o)),a.setCrossOrigin&&a.setCrossOrigin(this.crossOrigin);const l=a.load(e,i,r,s);return t!==void 0&&(l.mapping=t),l}}class KM{static fromCubeTexture(e){let t=0;const i=new C.Vector3,r=new C.Vector3,s=new C.Color,o=[0,0,0,0,0,0,0,0,0],a=new C.SphericalHarmonics3,l=a.coefficients;for(let h=0;h<6;h++){const u=e.image[h],d=u.width,f=u.height,A=document.createElement("canvas");A.width=d,A.height=f;const g=A.getContext("2d");g.drawImage(u,0,0,d,f);const m=g.getImageData(0,0,d,f),p=m.data,v=m.width,E=2/v;for(let x=0,M=p.length;x<M;x+=4){s.setRGB(p[x]/255,p[x+1]/255,p[x+2]/255),Tx(s,e.colorSpace);const w=x/4,S=(w%v+.5)*E-1,B=1-(Math.floor(w/v)+.5)*E;switch(h){case 0:i.set(-1,B,-S);break;case 1:i.set(1,B,S);break;case 2:i.set(-S,1,-B);break;case 3:i.set(-S,-1,B);break;case 4:i.set(-S,B,1);break;case 5:i.set(S,B,-1)}const y=i.lengthSq(),_=4/(Math.sqrt(y)*y);t+=_,r.copy(i).normalize(),C.SphericalHarmonics3.getBasisAt(r,o);for(let L=0;L<9;L++)l[L].x+=o[L]*s.r*_,l[L].y+=o[L]*s.g*_,l[L].z+=o[L]*s.b*_}}const c=4*Math.PI/t;for(let h=0;h<9;h++)l[h].x*=c,l[h].y*=c,l[h].z*=c;return new C.LightProbe(a)}static async fromCubeRenderTarget(e,t){const i=e.coordinateSystem===C.WebGLCoordinateSystem?-1:1;let r=0;const s=new C.Vector3,o=new C.Vector3,a=new C.Color,l=[0,0,0,0,0,0,0,0,0],c=new C.SphericalHarmonics3,h=c.coefficients,u=t.texture.type,d=t.width;let f;e.isWebGLRenderer&&(f=u===C.HalfFloatType?new Uint16Array(d*d*4):new Uint8Array(d*d*4));for(let g=0;g<6;g++){e.isWebGLRenderer?await e.readRenderTargetPixelsAsync(t,0,0,d,d,f,g):f=await e.readRenderTargetPixelsAsync(t,0,0,d,d,0,g);const m=2/d;for(let p=0,v=f.length;p<v;p+=4){let E,x,M;u===C.HalfFloatType?(E=C.DataUtils.fromHalfFloat(f[p]),x=C.DataUtils.fromHalfFloat(f[p+1]),M=C.DataUtils.fromHalfFloat(f[p+2])):(E=f[p]/255,x=f[p+1]/255,M=f[p+2]/255),a.setRGB(E,x,M),Tx(a,t.texture.colorSpace);const w=p/4,S=(1-(w%d+.5)*m)*i,B=1-(Math.floor(w/d)+.5)*m;switch(g){case 0:s.set(-1*i,B,S*i);break;case 1:s.set(1*i,B,-S*i);break;case 2:s.set(S,1,-B);break;case 3:s.set(S,-1,B);break;case 4:s.set(S,B,1);break;case 5:s.set(-S,B,-1)}const y=s.lengthSq(),_=4/(Math.sqrt(y)*y);r+=_,o.copy(s).normalize(),C.SphericalHarmonics3.getBasisAt(o,l);for(let L=0;L<9;L++)h[L].x+=l[L]*a.r*_,h[L].y+=l[L]*a.g*_,h[L].z+=l[L]*a.b*_}}const A=4*Math.PI/r;for(let g=0;g<9;g++)h[g].x*=A,h[g].y*=A,h[g].z*=A;return new C.LightProbe(c)}}function Tx(n,e){switch(e){case C.SRGBColorSpace:n.convertSRGBToLinear();break;case C.LinearSRGBColorSpace:case C.NoColorSpace:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.")}return n}var JM=function(n){var e=this;this.object=n,this.object.rotation.reorder("YXZ"),this.enabled=!0,this.deviceOrientation={},this.screenOrientation=0,this.alphaOffset=0;var t,i,r,s,o=function(c){e.deviceOrientation=c},a=function(){e.screenOrientation=window.orientation||0},l=(t=new THREE.Vector3(0,0,1),i=new THREE.Euler,r=new THREE.Quaternion,s=new THREE.Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)),function(c,h,u,d,f){i.set(u,h,-d,"YXZ"),c.setFromEuler(i),c.multiply(s),c.multiply(r.setFromAxisAngle(t,-f))});this.connect=function(){a(),window.addEventListener("orientationchange",a,!1),window.addEventListener("deviceorientation",o,!1),e.enabled=!0},this.disconnect=function(){window.removeEventListener("orientationchange",a,!1),window.removeEventListener("deviceorientation",o,!1),e.enabled=!1},this.update=function(){if(e.enabled!==!1){var c=e.deviceOrientation;if(c){var h=c.alpha?THREE.MathUtils.degToRad(c.alpha)+e.alphaOffset:0,u=c.beta?THREE.MathUtils.degToRad(c.beta):0,d=c.gamma?THREE.MathUtils.degToRad(c.gamma):0,f=e.screenOrientation?THREE.MathUtils.degToRad(e.screenOrientation):0;l(e.object.quaternion,h,u,d,f)}}},this.dispose=function(){e.disconnect()},this.connect()},wi=globalThis.THREE={...C};wi.DRACOLoader=LM,wi.GLTFLoader=G0,wi.KTX2Loader=ni,wi.OBJLoader=jM,wi.MTLLoader=$M,wi.OBB=Vd,wi.BufferGeometryUtils=IA,wi.LightProbeGenerator=KM,wi.DeviceOrientationControls=JM,wi.Cache.enabled=!0;const ZM=wi;var qt=window.AFRAME_CDN_ROOT||"https://cdn.aframe.io/",vn="aframe-injected",nU=nt(8878),yc=nt.n(nU),iU={colors:{debug:"gray",error:"red",info:"gray",warn:"orange"}};yc().formatArgs=function(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" "),this.useColors){var e;this.color=(e=function(s){var o=s.split(":");return o[o.length-1]}(this.namespace),iU.colors[e]||null);var t="color: "+this.color;n.splice(1,0,t,"color: inherit");var i=0,r=0;n[0].replace(/%[a-zA-Z%]/g,function(s){s!=="%%"&&(i++,s==="%c"&&(r=i))}),n.splice(r,0,t)}};var tm=function(){try{return window.localStorage}catch{}}();tm&&(parseInt(tm.logs,10)||tm.logs==="true")?yc().enable("*"):yc().enable("*:error,*:info,*:warn");const Bt=yc();var rU=nt(1124),sU=nt.n(rU),Ix=Bt("device:error"),Qd=!1,Wd=!1,Hf=navigator.xr!==void 0;if(Hf){var aa=function(){var n=document.querySelector("a-scene");n?n.hasLoaded?n.components["xr-mode-ui"].updateEnterInterfaces():n.addEventListener("loaded",aa):window.addEventListener("DOMContentLoaded",aa)},Rx=function(n){Ix("WebXR session support error: "+n.message)};navigator.xr.isSessionSupported?(navigator.xr.isSessionSupported("immersive-vr").then(function(n){Qd=n,aa()}).catch(Rx),navigator.xr.isSessionSupported("immersive-ar").then(function(n){Wd=n,aa()}).catch(function(){})):navigator.xr.supportsSession?(navigator.xr.supportsSession("immersive-vr").then(function(){Qd=!0,aa()}).catch(Rx),navigator.xr.supportsSession("immersive-ar").then(function(){Wd=!0,aa()}).catch(function(){})):Ix("WebXR has neither isSessionSupported or supportsSession?!")}function H0(){return Qd||Wd}function V0(){return Wd}function YA(){return Qd}var Cl,nm,Ms=(Cl=!1,nm=window.navigator.userAgent||window.navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(nm)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(nm.substr(0,4)))&&(Cl=!0),(Hc()||eS()||q0())&&(Cl=!0),X0()&&(Cl=!1),function(){return Cl});function eS(n){var e=n||window.navigator.userAgent;return/Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(e)||tS()}function tS(n,e,t){var i=n||window.navigator.userAgent,r=e||window.navigator.platform,s=t||window.navigator.maxTouchPoints||0;return(r==="iPad"||r==="MacIntel")&&s>0&&/Macintosh|Intel|iPad|ipad/i.test(i)&&!window.MSStream}function nS(){var n=navigator.userAgent.includes("Macintosh"),e=navigator.maxTouchPoints===5;return n&&e&&Hf}function Hc(){return/iPad|iPhone|iPod/.test(window.navigator.platform)}function Q0(){return!Ms()&&!X0()&&window.orientation!==void 0}function W0(){return/(OculusBrowser)/i.test(window.navigator.userAgent)}function iS(){return/(Mobile VR)/i.test(window.navigator.userAgent)}function X0(){return W0()||iS()||nS()}function q0(){return/R7 Build/.test(window.navigator.userAgent)}function rS(){var n=window.orientation;return q0()&&(n+=90),n===90||n===-90}var Y0=typeof process>"u"||process.browser===!0,oU=!Y0,aU=Object.freeze(Object.create(null));function lU(){return{}}function j0(n){var e=[],t=null;function i(r){var s,o;if((r=r===void 0?e.length:r)>0&&t==null&&(t=0),r>0)for(s=e.length,e.length+=Number(r),o=s;o<e.length;o++)e[o]=n();return e.length}return n=n||lU,{grow:i,pool:e,recycle:function(r){r instanceof Object&&(t!==null&&t!==-1?e[--t]=r:e[e.length]=r)},size:function(){return e.length},use:function(){var r;return t!==null&&t!==e.length||i(e.length||5),r=e[t],e[t++]=aU,$0(r),r}}}function $0(n){var e;if(n&&n.constructor===Object)for(e in n)n[e]=void 0}function _c(n,e){var t;if(n&&n.constructor===Object)for(t in n)t in e||delete n[t]}var cU=Bt("utils:coordinates:warn"),Bx=["x","y","z","w"],sS=/^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/,hU=/\s+/g;function Xd(n,e,t){var i,r,s,o,a,l,c,h,u=t&&typeof t=="object"?t:{};if(n&&n instanceof Object)return a=n.x===void 0?e&&e.x:n.x,l=n.y===void 0?e&&e.y:n.y,c=n.z===void 0?e&&e.z:n.z,h=n.w===void 0?e&&e.w:n.w,a!=null&&(u.x=Ml(a)),l!=null&&(u.y=Ml(l)),c!=null&&(u.z=Ml(c)),h!=null&&(u.w=Ml(h)),u;if(n==null)return typeof e=="object"?Object.assign(u,e):e;for(i=n.trim().split(hU),o=0;o<Bx.length;o++)if(s=Bx[o],i[o])u[s]=parseFloat(i[o],10);else{if((r=e&&e[s])===void 0)continue;u[s]=Ml(r)}return u}function Hu(n){var e;return typeof n!="object"?n:(e=n.x+" "+n.y,n.z!=null&&(e+=" "+n.z),n.w!=null&&(e+=" "+n.w),e)}function Vu(n,e){return typeof n!="object"||typeof e!="object"?n===e:n.x===e.x&&n.y===e.y&&n.z===e.z&&n.w===e.w}function oS(n){return sS.test(n)}function uU(n){return cU("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"),oS(n)}function Ml(n){return n!=null&&n.constructor===String?parseFloat(n,10):n}function dU(n){return new C.Vector3(n.x,n.y,n.z)}var Fr=function(){var n={};return function(e,t){return t in n||(n[t]={}),e in n[t]||(n[t][e]=e.split(t)),n[t][e]}}();function Vf(n,e){var t=Fr(n,e=e||".");return t.length===1?t[0]:t}function aS(n,e,t){var i;return t=t||".",e.indexOf(t)!==-1?(i=Vf(e,t)).constructor===String?n.getAttribute(i):n.getAttribute(i[0])[i[1]]:n.getAttribute(e)}function K0(n,e,t,i){var r;i=i||".",e.indexOf(i)===-1?n.setAttribute(e,t):(r=Vf(e,i)).constructor===String?n.setAttribute(r,t):n.setAttribute(r[0],r[1],t)}function lS(n){var e=n.style.width,t=n.style.height;n.style.width=parseInt(e,10)+1+"px",n.style.height=parseInt(t,10)+1+"px",setTimeout(function(){n.style.width=e,n.style.height=t},200)}var Qu=Bt("utils:src-loader:warn");function qd(n,e,t){(function(i,r){var s;i.tagName?r(i.tagName==="IMG"):((s=new XMLHttpRequest).open("HEAD",i),s.addEventListener("load",function(o){var a;s.status>=200&&s.status<300?(a=s.getResponseHeader("Content-Type"))==null?Lx(i,r):a.startsWith("image")?r(!0):r(!1):Lx(i,r),s.abort()}),s.send())})(n,function(i){i?e(n):t(n)})}function J0(n,e,t){var i,r,s,o="",a=[];if(typeof n=="string"){let l=function(c){a.push(c),a.length===6&&e(a)};for(r=0;r<5;r++)o+="(url\\((?:[^\\)]+)\\),\\s*)";if(o+="(url\\((?:[^\\)]+)\\)\\s*)",s=n.match(new RegExp(o))){for(r=1;r<7;r++)qd(jA(s[r]),l);return}if(!n.startsWith("#"))return void qd(jA(n)||n,t)}if(i=n.tagName?n:function(l){try{var c=document.querySelector(l);return c||Qu('No element was found matching the selector: "%s"',l),c}catch{return void Qu('"%s" is not a valid selector',l)}}(n))return i.tagName==="A-CUBEMAP"&&i.srcs?e(i.srcs):i.tagName==="IMG"?t(i):void Qu('Selector "%s" does not point to <a-cubemap> or <img>',n)}function cS(n,e){return J0(n,e,function(){Qu("Expected cubemap but got image")})}function jA(n){var e=n.match(/url\((.+)\)/);if(e)return e[1]}function Lx(n,e){var t=new Image;t.addEventListener("load",function(){e(!0)}),t.addEventListener("error",function(){e(!1)}),t.src=n}var fU=Bt("utils:material:warn"),pU=new Set(["emissiveMap","envMap","map","specularMap"]);function Yd(n,e){var t=e.offset||{x:0,y:0},i=e.repeat||{x:1,y:1},r=e.npot||!1,s=e.anisotropy||C.Texture.DEFAULT_ANISOTROPY,o=n.wrapS,a=n.wrapT,l=n.magFilter,c=n.minFilter;r&&(o=C.ClampToEdgeWrapping,a=C.ClampToEdgeWrapping,l=C.LinearFilter,c=C.LinearFilter),i.x===1&&i.y===1||(o=C.RepeatWrapping,a=C.RepeatWrapping),n.offset.set(t.x,t.y),n.repeat.set(i.x,i.y),n.wrapS===o&&n.wrapT===a&&n.magFilter===l&&n.minFilter===c&&n.anisotropy===s||(n.wrapS=o,n.wrapT=a,n.magFilter=l,n.minFilter=c,n.anisotropy=s,n.needsUpdate=!0)}function Qf(n,e,t,i){var r=t.el,s=t.material,o=r.sceneEl.systems.renderer,a=i[e];if(t.materialSrcs||(t.materialSrcs={}),!a)return delete t.materialSrcs[n],void l(null);function l(c){s[n]!==c&&(s[n]&&s[n].dispose(),s[n]=c,s.needsUpdate=!0,Z0(r,c))}a===t.materialSrcs[n]&&s[n]?Yd(s[n],i):(t.materialSrcs[n]=a,a instanceof C.Texture?l(a):r.sceneEl.systems.material.loadTextureSource(a,function(c){if(t.materialSrcs[n]===a){var h=s[n];!h||c!==null&&hS(h,c)||(h=null),!h&&c&&(h=ev(c)),h&&(h.source!==c&&(h.source=c,h.needsUpdate=!0),pU.has(n)&&o.applyColorCorrection(h),Yd(h,i)),l(h)}}))}function Wu(n,e){return Qf("map","src",n,e)}function Vi(n,e,t){var i=n;n==="ambientOcclusion"&&(i="ao");var r={};return r.src=t[n+"Map"],r.offset=t[n+"TextureOffset"],r.repeat=t[n+"TextureRepeat"],r.wrap=t[n+"TextureWrap"],Qf(i+"Map","src",e,r)}var im={};function $A(n,e){var t=n.material,i=n.el,r="envMap",s=e.envMap,o=e.sphericalEnvMap,a=e.refract;if(o&&(s=o,fU("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")),n.materialSrcs||(n.materialSrcs={}),!s)return delete n.materialSrcs[r],t.envMap=null,void(t.needsUpdate=!0);function l(c){n.materialSrcs[r]===s&&(t.envMap=c,t.needsUpdate=!0,Z0(i,c))}n.materialSrcs[r]=s,im[s]?im[s].then(l):im[s]=new Promise(function(c){J0(s,function(h){i.sceneEl.systems.material.loadCubeMapTexture(h,function(u){u.mapping=a?C.CubeRefractionMapping:C.CubeReflectionMapping,l(u),c(u)})},function(h){i.sceneEl.systems.material.loadTexture(h,{src:h},function(u){u.mapping=a?C.EquirectangularRefractionMapping:C.EquirectangularReflectionMapping,l(u),c(u)})})})}function Z0(n,e){function t(){n.emit("materialvideoloadeddata",{src:e.image,texture:e})}function i(){n.emit("materialvideoended",{src:e.image,texture:e})}e&&(n.emit("materialtextureloaded",{src:e.image,texture:e}),e.image&&e.image.tagName==="VIDEO"&&(e.image.addEventListener("loadeddata",t),e.image.addEventListener("ended",i),e.addEventListener("dispose",function(){e.image.removeEventListener("loadeddata",t),e.image.removeEventListener("ended",i)})))}function hS(n,e){return n.source===e&&(e.data instanceof HTMLCanvasElement?n.isCanvasTexture:e.data instanceof HTMLVideoElement?n.isVideoTexture:n.isTexture&&!n.isCanvasTexture&&!n.isVideoTexture)}function ev(n){var e;return(e=n.data instanceof HTMLCanvasElement?new C.CanvasTexture:n.data instanceof HTMLVideoElement?new C.VideoTexture(n.data):new C.Texture).source=n,e.needsUpdate=!0,e}var mU=/-([a-z])/g;function bc(n,e){var t;return typeof n!="string"?n:(t=function(i,r){var s,o,a,l,c,h;for(r=r||{},s=gU(i),o=0;o<s.length;o++)(a=s[o])&&(l=a.indexOf(":"),c=a.substr(0,l).trim(),h=a.substr(l+1).trim(),r[uS(c)]=h);return r}(n,e),t[""]?n:t)}function AU(n){return typeof n=="string"?n:function(e){var t,i=0,r=0,s="";for(t in e)i++;for(t in e)s+=t+": "+e[t],r<i-1&&(s+="; "),r++;return s}(n)}function uS(n){return n.replace(mU,vU)}var Wh,Dx,gU=(Wh=[],Dx=/url\([^)]+$/,function(n){var e,t="",i=0;for(Wh.length=0;i<n.length;)(e=n.indexOf(";",i))===-1&&(e=n.length),t+=n.substring(i,e),Dx.test(t)?(t+=";",i=e+1):(Wh.push(t.trim()),t="",i=e+1);return Wh});function vU(n){return n[1].toUpperCase()}var EU=["x","y","z","w"];function si(n,e,t){var i,r,s=n.el;if((r=!!(i=dS(n,e,t)))===n.controllerPresent)return r;n.controllerPresent=r,r?(n.addEventListeners(),n.injectTrackedControls(i),s.emit("controllerconnected",{name:n.name,component:n})):(n.removeEventListeners(),s.emit("controllerdisconnected",{name:n.name,component:n}))}function dS(n,e,t){var i,r=n.el.sceneEl,s=r&&r.systems["tracked-controls"];return!!s&&!(!(i=s.controllers)||!i.length)&&tv(i,e,t.hand,t.index,t.iterateControllerProfiles,t.handTracking)}function tv(n,e,t,i,r,s){var o,a,l,c,h=!1;for(o=0;o<n.length;o++){if(c=(l=n[o]).profiles,s)h=l.hand;else if(r)for(a=0;a<c.length&&!(h=c[a].startsWith(e));a++);else h=c.length>0&&c[0].startsWith(e);if(h){if(l.handedness==="right"||l.handedness==="left"){if(l.handedness===t)return n[o]}else if(o===i)return n[o]}}}function vi(n,e,t){var i,r,s,o,a;for(r in e){for(i=e[r],s=!1,a=0;a<i.length;a++)t.detail.changed[i[a]]&&(s=!0);if(s){for(o={},a=0;a<i.length;a++)o[EU[a]]=t.detail.axis[i[a]];n.el.emit(r+"moved",o)}}}function dt(n,e,t,i){var r=(i?t.mapping[i]:t.mapping).buttons[n];t.el.emit(r+e),t.updateModel&&t.updateModel(r,e)}var nv=Bt("utils:warn");function xU(n){return n.bind.apply(n,Array.prototype.slice.call(arguments,1))}function yU(){return nv("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"),H0()}function _U(){return nv("`utils.isIOS` has moved to `utils.device.isIOS`"),Hc()}function bU(){return nv("`utils.isMobile has moved to `utils.device.isMobile`"),Ms(arguments)}function CU(n,e,t){var i;return t&&(n=n.bind(t)),function(){var r=Date.now();(i===void 0||(i===void 0?e:r-i)>=e)&&(i=r,n.apply(null,arguments))}}function fS(n,e,t){var i,r,s;t&&(n=n.bind(t));var o=function(){i=Date.now(),n.apply(this,s),r=void 0};return function(){var a=Date.now(),l=i===void 0?e:a-i;l>=e?(clearTimeout(r),r=void 0,i=a,n.apply(null,arguments)):(r=r||setTimeout(o,e-l),s=arguments)}}function MU(n,e,t){var i;return t&&(n=n.bind(t)),function(r,s){var o=i===void 0?s:r-i;(i===void 0||o>=e)&&(i=r,n(r,o))}}function pS(n,e,t){var i;return function(){var r=this,s=arguments,o=t&&!i;clearTimeout(i),i=setTimeout(function(){i=null,t||n.apply(r,s)},e),o&&n.apply(r,s)}}var qn=Object.assign,ti=sU();function iv(n){return JSON.parse(JSON.stringify(n))}var bi,Ks,rv=(bi=j0(function(){return[]}),function(n,e){var t,i,r,s,o,a;if(n===void 0||e===void 0||n===null||e===null||!(n&&e&&n.constructor===Object&&e.constructor===Object||n.constructor===Array&&e.constructor===Array))return n===e;for(t in i=bi.use(),r=bi.use(),i.length=0,r.length=0,n)i.push(t);for(t in e)r.push(t);if(i.length!==r.length)return bi.recycle(i),bi.recycle(r),!1;for(s=0;s<i.length;++s)if(o=n[i[s]],a=e[i[s]],typeof o=="object"||typeof a=="object"||Array.isArray(o)&&Array.isArray(a)){if(o===a)continue;if(!rv(o,a))return bi.recycle(i),bi.recycle(r),!1}else if(o!==a)return bi.recycle(i),bi.recycle(r),!1;return bi.recycle(i),bi.recycle(r),!0}),mS=(Ks=[],function(n,e,t){var i,r,s,o,a,l,c;for(a in o=t||{},Ks.length=0,n)Ks.push(a);if(!e)return o;for(s in e)Ks.indexOf(s)===-1&&Ks.push(s);for(l=0;l<Ks.length;l++)i=n[a=Ks[l]],r=e[a],((c=i&&r&&i.constructor===Object&&r.constructor===Object)&&!rv(i,r)||!c&&i!==r)&&(o[a]=r);return o});function sv(n){return!n.metaKey&&document.activeElement===document.body}function SU(n,e){e===void 0&&(e=" ");var t=new RegExp(e,"g");return(n=(n||"").replace(t,e)).split(e)}function wU(n,e){e=e||{};var t={};return Object.keys(e).forEach(function(i){n.hasAttribute(i)&&(t[i]=n.getAttribute(i))}),t}function Cc(n){n=n.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var e=new RegExp("[\\?&]"+n+"=([^&#]*)").exec(location.search);return e===null?"":decodeURIComponent(e[1].replace(/\+/g," "))}function AS(){return window.top!==window.self}function gS(n){for(var e=[],t=n.getElementsByTagName("*"),i=0,r=t.length;i<r;i++)t[i].isScene&&e.push(t[i]);return e}var rm,TU=[Zl({name:"viewport",content:"width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"}),Zl({name:"mobile-web-app-capable",content:"yes"}),Zl({name:"theme-color",content:"black"})],IU=[Zl({name:"apple-mobile-web-app-capable",content:"yes"}),Zl({name:"apple-mobile-web-app-status-bar-style",content:"black"}),(rm={rel:"apple-touch-icon",href:"https://aframe.io/images/aframe-logo-152.png"},{tagName:"link",attributes:rm,exists:function(){return document.querySelector('link[rel="'+rm.rel+'"]')}})];function Zl(n){return{tagName:"meta",attributes:n,exists:function(){return document.querySelector('meta[name="'+n.name+'"]')}}}var Ii,Zr,vS,RU=nt(5928),BU=nt.n(RU),LU=$a,Px="loading-screen";function sm(n){var e=Ii.hasAttribute("embedded"),t=vS(Ii.canvas,e,Ii.maxCanvasSize,Ii.is("vr-mode"));n.aspect=t.width/t.height,n.updateProjectionMatrix(),Ii.renderer.setSize(t.width,t.height,!1)}const So=[];var ES=yc()("core:propertyTypes:warn"),KA={},DU=/[,> .[\]:]/,PU=/url\((.+)\)/;function An(n,e,t,i,r,s){if(n in KA)throw new Error("Property type "+n+" is already registered.");KA[n]={default:e,parse:t||UU,stringify:i||jd,equals:r||xS,isCacheable:s!==!1}}function Ux(n,e){if(!Array.isArray(n)||!Array.isArray(e))return n===e;if(n.length!==e.length)return!1;for(var t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Sl(n){var e,t;return typeof n!="string"?n:(t=n.match(PU))?t[1]:n.charAt(0)==="#"?(e=document.getElementById(n.substring(1)))?e.tagName==="CANVAS"||e.tagName==="VIDEO"||e.tagName==="IMG"?e:e.getAttribute("src"):void ES('"'+n+'" asset not found.'):n}function wl(n){return n.getAttribute?n.getAttribute("id")?"#"+n.getAttribute("id"):n.getAttribute("src"):jd(n)}function UU(n){return n}function jd(n){return n===null?"null":n.toString()}function xS(n,e){return n===e}function Fx(n){return parseInt(n,10)}function om(n,e,t){return Xd(n,e,t)}function am(n,e){if(n===null)return!0;if(typeof n!="object"||Object.keys(n).length!==e)return!1;var t=n.x,i=n.y,r=n.z,s=n.w;return!(typeof t!="number"||typeof i!="number"||e>2&&typeof r!="number"||e>3&&typeof s!="number")}An("audio","",Sl,wl),An("array",[],function(n){return Array.isArray(n)?n:n&&typeof n=="string"?n.split(",").map(function(e){return e.trim()}):[]},function(n){return n.join(", ")},Ux),An("asset","",Sl,wl),An("boolean",!1,function(n){return n!=="false"&&n!==!1}),An("color","#FFF"),An("int",0,Fx),An("number",0,function(n){return parseFloat(n,10)}),An("map","",Sl,wl),An("model","",Sl,wl),An("selector",null,function(n){return n?typeof n!="string"?n:n[0]!=="#"||DU.test(n)?document.querySelector(n):document.getElementById(n.substring(1)):null},function(n){return n.getAttribute?"#"+n.getAttribute("id"):jd(n)},xS,!1),An("selectorAll",null,function(n){return n?typeof n!="string"?n:Array.prototype.slice.call(document.querySelectorAll(n),0):null},function(n){return n instanceof Array?n.map(function(e){return"#"+e.getAttribute("id")}).join(", "):jd(n)},Ux,!1),An("src","",function(n){return ES("`src` property type is deprecated. Use `asset` instead."),Sl(n)},wl),An("string",""),An("time",0,Fx),An("vec2",{x:0,y:0},om,Hu,Vu),An("vec3",{x:0,y:0,z:0},om,Hu,Vu),An("vec4",{x:0,y:0,z:0,w:1},om,Hu,Vu);var FU=function(n,e){return(n!=="audio"||typeof e=="string")&&!(n==="array"&&!Array.isArray(e))&&(n!=="asset"||typeof e=="string")&&(n!=="boolean"||typeof e=="boolean")&&(n!=="color"||typeof e=="string")&&(n!=="int"||typeof e=="number")&&(n!=="number"||typeof e=="number")&&(n!=="map"||typeof e=="string")&&(n!=="model"||typeof e=="string")&&(n!=="selector"||typeof e=="string"||e===null)&&(n!=="selectorAll"||typeof e=="string"||e===null)&&(n!=="src"||typeof e=="string")&&(n!=="string"||typeof e=="string")&&(n!=="time"||typeof e=="number")&&(n==="vec2"?am(e,2):n==="vec3"?am(e,3):n!=="vec4"||am(e,4))},NU=KA,$d=Bt("core:schema:warn");function Wf(n){return"type"in n?typeof n.type=="string":"default"in n}function Vc(n,e){var t;if(Wf(n))return JA(n,e);for(t in n)n[t]=JA(n[t],e);return n}function JA(n,e){var t,i,r=n.default,s=n.type;return n.type?n.type==="bool"?s="boolean":n.type==="float"&&(s="number"):s=r===void 0||typeof r!="boolean"&&typeof r!="number"?Array.isArray(r)?"array":"string":typeof r,(i=NU[s])||$d("Unknown property type for component `"+e+"`: "+s),t=!!n.parse,n.parse=n.parse||i.parse,n.stringify=n.stringify||i.stringify,n.equals=n.equals||i.equals,n.isCacheable=n.isCacheable===!0||i.isCacheable,n.type=s,"default"in n?t||FU(s,r)||$d("Default value `"+r+"` does not match type `"+s+"` in component `"+e+"`"):n.default=i.default,n}var Tl,yS=(Tl=[],function(n,e,t,i,r){var s,o,a,l;for(o in Tl.length=0,t?n:e)t&&n[o]===void 0||Tl.push(o);if(n===null||typeof n!="object")return n;for(o in n)n[o]===void 0||e[o]||r||$d("Unknown property `"+o+"` for component/system `"+i+"`.");for(s=0;s<Tl.length;s++){if(a=e[o=Tl[s]],l=n[o],!e[o])return;n[o]=Xf(l,a)}return n});function Xf(n,e,t){return n!=null&&n!==""||(n=e.default,Array.isArray(n)&&(n=n.slice())),e.parse(n,e.default,t)}function _S(n,e){var t,i,r,s,o={};for(t in n)i=e[t],typeof(s=r=n[t])=="object"&&(s=ov(r,i),i||$d("Unknown component property: "+t)),s!==void 0&&(o[t]=s);return o}function ov(n,e){return typeof n!="object"?n:e&&n!==null?e.stringify(n):JSON.stringify(n)}var Yt={},Hl=Xf,bS=Vc,OU=Wf,kU=_S,GU=ov,lm=$a,ec=Bt("core:component:warn"),zU=document.currentScript,HU=new RegExp("[A-Z]+"),CS={},VU=Object.freeze({}),la=[],QU={get:function(n,e){return n.getComputedPropertyValue(e)},set:function(n,e,t){return e in n.schema?n.recomputeProperty(e,t):t!==void 0&&n.handleUnknownProperty(e,t),!0}},Mc=function(n,e,t){var i=this;if(this.sceneOnly&&!n.isScene)throw new Error("Component `"+this.name+"` can only be applied to <a-scene>");if(t&&!this.multiple)throw new Error("Trying to initialize multiple components of type `"+this.name+"`. There can only be one component of this type per entity.");this.el=n,this.id=t,this.attrName=this.name+(t?"__"+t:""),this.evtDetail={id:this.id,name:this.name},this.initialized=!1,this.el.components[this.attrName]=this,this.objectPool=CS[this.name];var r=this.events;this.events={},function(s,o){var a;for(a in o)s.events[a]=o[a].bind(s)}(this,r),this.attrValue=void 0,this.isObjectBased?(this.data=this.objectPool.use(),_c(this.data,this.schema),this.oldData=this.objectPool.use(),_c(this.oldData,this.schema),this.attrValueProxy=new Proxy(this,QU)):(this.data=void 0,this.oldData=void 0,this.attrValueProxy=void 0),this.deferUnknownPropertyWarnings=!!this.updateSchema,this.throttledEmitComponentChanged=fS(function(){n.emit("componentchanged",i.evtDetail,!1)},200),this.updateProperties(e,!0)};Mc.prototype={schema:{},init:function(){},events:{},update:function(n){},updateSchema:void 0,tick:void 0,tock:void 0,play:function(){},pause:function(){},remove:function(){},stringify:function(n){var e=this.schema;return typeof n=="string"?n:this.isSingleProperty?GU(n,e):(n=kU(n,e),lm.stringify(n))},flushToDOM:function(n){var e=n?this.data:this.attrValue;e!=null&&window.HTMLElement.prototype.setAttribute.call(this.el,this.attrName,this.stringify(e))},updateProperties:function(n,e){var t=this.el;this.updateData(n,e),(t.hasLoaded||t.isLoading)&&(this.initialized?this.callUpdateHandler():this.initComponent())},initComponent:function(){var n,e=this.el;e.initializingComponents[this.name]||(e.initializingComponents[this.name]=!0,this.init(),this.initialized=!0,delete e.initializingComponents[this.name],n=this.isObjectBased?VU:void 0,this.dataChanged=!1,this.storeOldData(),this.update(n),e.isPlaying&&this.play(),e.emit("componentinitialized",this.evtDetail,!1))},updateData:function(n,e){this.isSingleProperty?this.recomputeProperty(void 0,n):(e?($0(this.attrValue),this.recomputeData(n),this.schemaChangeRequired=!!this.updateSchema):typeof n=="string"?lm.parse(n,this.attrValueProxy):qn(this.attrValueProxy,n),this.updateSchemaIfNeeded(n))},updateSchemaIfNeeded:function(n){if(this.schemaChangeRequired&&this.updateSchema)for(var e in la.length=0,this.updateSchema(this.data),_c(this.data,this.schema),this.recomputeData(n),this.schemaChangeRequired=!1,this.attrValue)this.attrValue[e]!==void 0&&la.indexOf(e)===-1&&(e in this.schema||ec("Unknown property `"+e+"` for component `"+this.name+"`."));for(var t=0;t<la.length;t++)ec("Unknown property `"+la[t]+"` for component `"+this.name+"`.");la.length=0},callUpdateHandler:function(){if(this.isPositionRotationScale||this.dataChanged){this.dataChanged=!1;var n=this.oldData;this.oldDataInUse=!0,this.update(n),n!==this.oldData&&this.objectPool.recycle(n),this.oldDataInUse=!1,this.storeOldData(),this.throttledEmitComponentChanged()}},handleMixinUpdate:function(){this.recomputeData(),this.updateSchemaIfNeeded(),this.callUpdateHandler()},resetProperty:function(n){(this.isSingleProperty||n in this.schema)&&(n?this.attrValue[n]=void 0:(this.isObjectBased&&this.objectPool.recycle(this.attrValue),this.attrValue=void 0),this.recomputeProperty(n,void 0),this.updateSchemaIfNeeded(),this.callUpdateHandler())},extendSchema:function(n){var e;e=qn({},Yt[this.name].schema),qn(e,n),this.schema=bS(e),this.el.emit("schemachanged",this.evtDetail)},getComputedPropertyValue:function(n){var e=this.el.mixinEls,t=this.attrValue&&n?this.attrValue[n]:this.attrValue;if(t!==void 0)return t;for(var i=e.length-1;i>=0;i--){var r=e[i].getAttribute(this.attrName);if(r!==null&&(!n||n in r))return n?r[n]:r}return n?this.schema[n].default:this.schema.default},recomputeProperty:function(n,e){var t=n?this.schema[n]:this.schema;if(e!=null){this.attrValue===void 0&&this.isObjectBased&&(this.attrValue=this.objectPool.use());var i=n?this.attrValue[n]:this.attrValue;typeof(i=t.isCacheable?Hl(e,t,i):e)=="string"&&(i=e===""?void 0:e),n?this.attrValue[n]=i:this.attrValue=i}this.oldDataInUse&&(this.oldData=this.objectPool.use(),_c(this.oldData,this.schema),this.storeOldData(),this.oldDataInUse=!1);var r=n?this.oldData[n]:this.oldData,s=n?this.data[n]:this.data,o=Hl(this.getComputedPropertyValue(n),t,s);return t.type!=="array"||n||(o=iv(o)),t.equals(o,r)||(this.dataChanged=!0,t.schemaChange&&(this.schemaChangeRequired=!0)),n?this.data[n]=o:this.data=o,o},handleUnknownProperty:function(n,e){this.attrValue===void 0&&(this.attrValue=this.objectPool.use()),this.attrValue[n]=e,this.deferUnknownPropertyWarnings?la.push(n):this.silenceUnknownPropertyWarnings||ec("Unknown property `"+n+"` for component `"+this.name+"`.")},storeOldData:function(){var n;if(this.isObjectBased)if(this.isSingleProperty)this.oldData=Hl(this.data,this.schema,this.oldData);else for(n in this.schema)this.data[n]!==void 0&&(this.data[n]&&typeof this.data[n]=="object"?this.oldData[n]=Hl(this.data[n],this.schema[n],this.oldData[n]):this.oldData[n]=this.data[n]);else this.oldData=this.data},recomputeData:function(n){var e;if(this.isSingleProperty)this.recomputeProperty(void 0,n);else{for(e in this.schema)this.attrValueProxy[e]=void 0;n&&typeof n=="object"?qn(this.attrValueProxy,n):typeof n=="string"&&lm.parse(n,this.attrValueProxy)}},eventsAttach:function(){var n;for(n in this.eventsDetach(),this.events)this.el.addEventListener(n,this.events[n])},eventsDetach:function(){var n;for(n in this.events)this.el.removeEventListener(n,this.events[n])},destroy:function(){this.objectPool.recycle(this.attrValue),this.objectPool.recycle(this.data),this.objectPool.recycle(this.oldData),this.attrValue=this.data=this.oldData=this.attrValueProxy=void 0}};var MS={};function tt(n,e){var t,i,r,s,o,a={};if(document.currentScript&&document.currentScript!==zU&&So.forEach(function(c){c.hasLoaded||document.currentScript.compareDocumentPosition(c)!==Node.DOCUMENT_POSITION_FOLLOWING&&(ec("The component `"+n+"` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."),window.debug&&(MS[n]=!0))}),HU.test(n)===!0&&ec("The component name `"+n+"` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `"+n.toLowerCase()+"`"),n.indexOf("__")!==-1)throw new Error("The component name `"+n+"` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");if(Object.keys(e).forEach(function(c){a[c]={value:e[c],writable:!0}}),Yt[n])throw new Error("The component `"+n+"` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");((t=function(c,h,u){Mc.call(this,c,h,u)}).prototype=Object.create(Mc.prototype,a)).name=n,t.prototype.isPositionRotationScale=n==="position"||n==="rotation"||n==="scale",t.prototype.constructor=t,t.prototype.system=wr[n],t.prototype.play=(s=t.prototype.play,function(){var c=this.el.sceneEl,h=this.el.isPlaying&&!this.isPlaying;this.initialized&&h&&(s.call(this),this.isPlaying=!0,this.eventsAttach(),Nx(this)&&c.addBehavior(this))}),t.prototype.pause=(o=t.prototype.pause,function(){var c=this.el.sceneEl;this.isPlaying&&(o.call(this),this.isPlaying=!1,this.eventsDetach(),Nx(this)&&c.removeBehavior(this))}),i=qn(bS(t.prototype.schema,t.prototype.name)),t.prototype.isSingleProperty=r=OU(t.prototype.schema),t.prototype.isObjectBased=!r||r&&(Ox(i.default)||Ox(Hl(void 0,i))),CS[n]=j0(),Yt[n]={Component:t,dependencies:t.prototype.dependencies,before:t.prototype.before,after:t.prototype.after,isSingleProperty:t.prototype.isSingleProperty,isObjectBased:t.prototype.isObjectBased,multiple:t.prototype.multiple,sceneOnly:t.prototype.sceneOnly,name:n,schema:i,stringify:t.prototype.stringify};for(var l=0;l<So.length;l++)So[l].emit("componentregistered",{name:n},!1);return t}function Nx(n){return n.tick||n.tock}function Ox(n){return n&&n.constructor===Object&&!(n instanceof window.HTMLElement)}var Kd=!1;function ZA(){Kd||(Kd=!0,setTimeout(function(){document.dispatchEvent(new CustomEvent("aframeready"))}))}var WU=$a,wr={},Jd=function(n){var e=Yt[this.name];this.el=n,this.sceneEl=n,e&&(e.Component.prototype.system=this),this.buildData(),this.init(),this.update({})};function gi(n,e){var t,i,r={},s=gS(document);if(Object.keys(e).forEach(function(o){r[o]={value:e[o],writable:!0}}),wr[n])throw new Error("The system `"+n+"` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");if(i=function(o){Jd.call(this,o)},(i.prototype=Object.create(Jd.prototype,r)).name=n,i.prototype.constructor=i,i.prototype.schema=qn(Vc(i.prototype.schema)),wr[n]=i,Kd)for(t=0;t<s.length;t++)s[t].initSystem(n)}Jd.prototype={schema:{},init:function(){},update:function(n){},updateProperties:function(n){var e=this.data;Object.keys(this.schema).length!==0&&(this.buildData(n),this.update(e))},buildData:function(n){var e=this.schema;Object.keys(e).length!==0&&(n=n||window.HTMLElement.prototype.getAttribute.call(this.sceneEl,this.name),Wf(e)?this.data=Xf(n,e):this.data=yS(WU.parse(n)||{},e,!1,this.name))},tick:void 0,tock:void 0,play:function(){},pause:function(){}};var cm=Bt("core:a-node:warn"),eg={"a-scene":!0,"a-assets":!0,"a-assets-items":!0,"a-cubemap":!0,"a-mixin":!0,"a-node":!0,"a-entity":!0};function XU(n){return n.tagName.toLowerCase()in eg||n.isANode}class En extends HTMLElement{constructor(){super(),this.computedMixinStr="",this.hasLoaded=!1,this.isANode=!0,this.mixinEls=[]}connectedCallback(){Kd?this.doConnectedCallback():document.addEventListener("aframeready",this.connectedCallback.bind(this))}doConnectedCallback(){var e;this.sceneEl=this.closestScene(),this.sceneEl||cm("You are attempting to attach <"+this.tagName+"> outside of an A-Frame scene. Append this element to `<a-scene>` instead."),this.hasLoaded=!1,this.emit("nodeready",void 0,!1),this.isMixin||(e=this.getAttribute("mixin"))&&this.updateMixins(e)}attributeChangedCallback(e,t,i){i!==this.computedMixinStr&&(e!=="mixin"||this.isMixin||this.updateMixins(i,t))}closestScene(){for(var e=this;e&&!e.isScene;)e=e.parentElement;return e}closest(e){for(var t=this.matches||this.mozMatchesSelector||this.msMatchesSelector||this.oMatchesSelector||this.webkitMatchesSelector,i=this;i&&!t.call(i,e);)i=i.parentElement;return i}disconnectedCallback(){this.hasLoaded=!1}load(e,t){var i,r=this;this.hasLoaded||(t=t||XU,i=this.getChildren().filter(t).map(function(s){return new Promise(function(o,a){if(s.hasLoaded)return o();s.addEventListener("loaded",o),s.addEventListener("error",a)})}),Promise.allSettled(i).then(function(s){s.forEach(function(o){o.status==="rejected"&&cm("Rendering scene with errors on node: ",o.reason.target)}),r.isLoading=!0,r.setupMutationObserver(),e&&e(),r.isLoading=!1,r.hasLoaded=!0,r.emit("loaded-private",void 0,!1),r.emit("loaded",void 0,!1)}))}setupMutationObserver(){var e=this;new MutationObserver(function(t){var i;for(i=0;i<t.length;i++)if(t[i].type==="attributes"){var r=t[i].attributeName,s=window.HTMLElement.prototype.getAttribute.call(e,r),o=t[i].oldValue;e.attributeChangedCallback(r,o,s)}}).observe(this,{attributes:!0,attributeOldValue:!0})}getChildren(){return Array.prototype.slice.call(this.children,0)}updateMixins(e,t){var i,r,s,o=En.newMixinIdArray,a=En.oldMixinIdArray,l=En.mixinIds;for(o.length=0,a.length=0,r=e?Fr(e.trim(),/\s+/):o,s=t?Fr(t.trim(),/\s+/):a,l.newMixinIds=r,l.oldMixinIds=s,i=0;i<s.length;i++)r.indexOf(s[i])===-1&&this.unregisterMixin(s[i]);for(this.computedMixinStr="",this.mixinEls.length=0,i=0;i<r.length;i++)this.registerMixin(r[i]);return this.computedMixinStr&&(this.computedMixinStr=this.computedMixinStr.trim(),window.HTMLElement.prototype.setAttribute.call(this,"mixin",this.computedMixinStr)),r.length===0&&window.HTMLElement.prototype.removeAttribute.call(this,"mixin"),l}registerMixin(e){var t,i,r,s=document.getElementById(e);if(s){if(r=s.getAttribute("mixin"))for(t=Fr(r.trim(),/\s+/),i=0;i<t.length;i++)this.registerMixin(t[i]);this.computedMixinStr=this.computedMixinStr+" "+s.id,this.mixinEls.push(s)}else cm("No mixin was found with id `%s`",e)}setAttribute(e,t){e==="mixin"&&this.updateMixins(t),window.HTMLElement.prototype.setAttribute.call(this,e,t)}unregisterMixin(e){var t,i=this.mixinEls;for(t=0;t<i.length;++t)if(e===i[t].id){i.splice(t,1);break}}emit(e,t,i,r){var s=En.evtData;i===void 0&&(i=!0),s.bubbles=!!i,s.detail=t,r&&(s=qn({},r,s)),this.dispatchEvent(new CustomEvent(e,s))}}En.evtData={},En.newMixinIdArray=[],En.oldMixinIdArray=[],En.mixinIds={},customElements.define("a-node",En);var qU=Bt("core:a-entity:debug"),hm=Bt("core:a-entity:warn"),Zd="__",um=["position","rotation","scale","visible"],YU={once:!0};class an extends En{constructor(){super(),this.components={},this.initializingComponents={},this.componentsToUpdate={},this.isEntity=!0,this.isPlaying=!1,this.object3D=new C.Group,this.object3D.rotation.order="YXZ",this.object3D.el=this,this.object3DMap={},this.parentEl=null,this.rotationObj={},this.states=[]}attributeChangedCallback(e,t,i){var r=this.components[e];super.attributeChangedCallback(),r&&r.justInitialized&&i===""?delete r.justInitialized:(r||i!==null)&&this.setEntityAttribute(e,t,i)}doConnectedCallback(){var e,t,i=this;super.doConnectedCallback(),t=this.sceneEl,this.addToParent(),this.isScene||(t?!(e=t.querySelector("a-assets"))||e.hasLoaded?this.load():e.addEventListener("loaded",function(){i.load()}):this.load())}disconnectedCallback(){var e;if(this.parentEl){for(e in this.components)this.removeComponent(e,!1);this.isScene||(this.removeFromParent(),super.disconnectedCallback(),this.object3D.el=null)}}getObject3D(e){return this.object3DMap[e]}setObject3D(e,t){var i,r=this;if(!(t instanceof C.Object3D))throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");(i=this.getObject3D(e))&&this.object3D.remove(i),t.el=this,t.children.length&&t.traverse(function(s){s.el=r}),this.object3D.add(t),this.object3DMap[e]=t,this.emit("object3dset",{object:t,type:e})}removeObject3D(e){var t=this.getObject3D(e);t?(this.object3D.remove(t),delete this.object3DMap[e],this.emit("object3dremove",{type:e})):hm("Tried to remove `Object3D` of type:",e,"which was not defined.")}getOrCreateObject3D(e,t){var i=this.getObject3D(e);return!i&&t&&(i=new t,this.setObject3D(e,i)),hm("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."),i}add(e){if(!e.object3D)throw new Error("Trying to add an element that doesn't have an `object3D`");this.object3D.add(e.object3D),this.emit("child-attached",{el:e})}addToParent(){var e=this.parentEl=this.parentNode;e&&e.add&&!this.attachedToParent&&(e.add(this),this.attachedToParent=!0)}removeFromParent(){var e=this.parentEl;this.parentEl.remove(this),this.attachedToParent=!1,this.parentEl=null,e.emit("child-detached",{el:this})}load(){var e=this;!this.hasLoaded&&this.parentEl&&super.load.call(this,function(){e.parentEl&&(e.updateComponents(),(e.isScene||e.parentEl.isPlaying)&&e.play())})}remove(e){e?this.object3D.remove(e.object3D):this.parentNode.removeChild(this)}getChildEntities(){for(var e=this.children,t=[],i=0;i<e.length;i++){var r=e[i];r instanceof an&&t.push(r)}return t}initComponent(e,t,i){var r,s,o,a;a=(o=Fr(e,Zd))[0],s=o.length>2?o.slice(1).join("__"):o[1],Yt[a]&&(kx(this,e)||t!==void 0||i)&&(e in this.components||(this.initComponentDependencies(a),r=new Yt[a].Component(this,t,s),this.isPlaying&&r.play(),this.hasAttribute(e)||(r.justInitialized=!0,window.HTMLElement.prototype.setAttribute.call(this,e,"")),qU("Component initialized: %s",e)))}initComponentDependencies(e){var t,i;if(Yt[e]&&(t=Yt[e].dependencies))for(i=0;i<t.length;i++)this.initComponent(t[i],window.HTMLElement.prototype.getAttribute.call(this,t[i])||void 0,!0)}removeComponent(e,t){var i;(i=this.components[e])&&(i.initialized?(i.pause(),i.remove(),t&&(i.destroy(),delete this.components[e],this.hasAttribute(e)&&window.HTMLElement.prototype.removeAttribute.call(this,e)),this.emit("componentremoved",i.evtDetail,!1)):this.addEventListener("componentinitialized",function r(s){s.detail.name===e&&(this.removeComponent(e,t),this.removeEventListener("componentinitialized",r))}))}updateComponents(){var e,t,i,r,s,o,a=this.componentsToUpdate;if(this.hasLoaded||this.isLoading){for(i=0;i<this.mixinEls.length;i++)for(r in this.mixinEls[i].componentCache)dm(r)&&(a[r]=!0);if(this.getExtraComponents)for(r in t=this.getExtraComponents())dm(r)&&(a[r]=!0);for(i=0;i<this.attributes.length;++i)r=this.attributes[i].name,um.indexOf(r)===-1&&dm(r)&&(a[r]=!0);for(i=0;i<um.length;i++)r=um[i],this.hasAttribute(r)&&this.updateComponent(r,this.getDOMAttribute(r));for(r in a)s=this.getDOMAttribute(r),e=(o=t&&t[r])?o.constructor===Object?qn(o,bc(s||{})):s||o:s,this.updateComponent(r,e),delete a[r]}}updateComponent(e,t,i){var r=this.components[e];if(r)return t!==null||kx(this,e)?void r.updateProperties(t,i):void this.removeComponent(e,!0);this.initComponent(e,t,!1)}removeAttribute(e,t){var i=this.components[e];i&&t===void 0&&this.removeComponent(e,!0),i&&t!==void 0?i.resetProperty(t):(e==="mixin"&&this.mixinUpdate(""),window.HTMLElement.prototype.removeAttribute.call(this,e))}play(){var e,t,i;if(!this.isPlaying&&(this.hasLoaded||this.isLoading)){for(i in this.isPlaying=!0,this.components)this.components[i].play();for(e=this.getChildEntities(),t=0;t<e.length;t++)e[t].play();this.emit("play")}}pause(){var e,t,i;if(this.isPlaying){for(i in this.isPlaying=!1,this.components)this.components[i].pause();for(e=this.getChildEntities(),t=0;t<e.length;t++)e[t].pause();this.emit("pause")}}setEntityAttribute(e,t,i){if(Yt[e]||this.components[e])this.updateComponent(e,i);else if(e==="mixin"){if(i===this.computedMixinStr)return;this.mixinUpdate(i,t)}}mixinUpdate(e,t,i){var r,s,o,a,l=an.componentsUpdated,c=this;if(i||(t=t||this.getAttribute("mixin")),this.hasLoaded){for(o=this.updateMixins(e,t),l.length=0,a=0;a<this.mixinEls.length;a++)for(r in this.mixinEls[a].componentCache)l.indexOf(r)===-1&&(this.components[r]?this.components[r].handleMixinUpdate():this.initComponent(r,null),l.push(r));for(a=0;a<o.oldMixinIds.length;a++)if(s=document.getElementById(o.oldMixinIds[a]))for(r in s.componentCache)l.indexOf(r)===-1&&this.components[r]&&(this.getDOMAttribute(r)?this.components[r].handleMixinUpdate():this.removeComponent(r,!0))}else this.addEventListener("loaded-private",function(){c.mixinUpdate(e,t,!0)},YU)}setAttribute(e,t,i){var r,s,o,a,l,c=an.singlePropUpdate;if(o=(a=e.indexOf(Zd))>0?e.substring(0,a):e,!Yt[o])return e==="mixin"&&this.mixinUpdate(t),void super.setAttribute.call(this,e,t);if(!this.components[e]&&this.hasAttribute(e)&&this.updateComponent(e,window.HTMLElement.prototype.getAttribute.call(this,e)),i!==void 0&&typeof t=="string"&&t.length>0&&typeof bc(t)=="string"){for(l in c)delete c[l];(r=c)[t]=i,s=!1}else r=t,s=i===!0;this.updateComponent(e,r,s),this.sceneEl&&this.sceneEl.getAttribute("debug")&&this.components[e].flushToDOM()}flushToDOM(e){var t,i,r,s=this.components,o=this.children;for(r in s)s[r].flushToDOM();if(e)for(i=0;i<o.length;++i)(t=o[i]).flushToDOM&&t.flushToDOM(e)}getAttribute(e){var t,i,r,s;return e==="position"?this.object3D.position:e==="rotation"?(i=C.MathUtils.radToDeg,r=this.object3D.rotation,(s=this.rotationObj).x=i(r.x),s.y=i(r.y),s.z=i(r.z),s):e==="scale"?this.object3D.scale:e==="visible"?this.object3D.visible:(t=this.components[e])?t.data:window.HTMLElement.prototype.getAttribute.call(this,e)}getDOMAttribute(e){var t=this.components[e];return t?t.attrValue:window.HTMLElement.prototype.getAttribute.call(this,e)}addState(e){this.is(e)||(this.states.push(e),this.emit("stateadded",e))}removeState(e){var t=this.states.indexOf(e);t!==-1&&(this.states.splice(t,1),this.emit("stateremoved",e))}is(e){return this.states.indexOf(e)!==-1}inspect(){this.sceneEl.components.inspector.openInspector(this)}destroy(){var e;if(this.parentNode)hm("Entity can only be destroyed if detached from scenegraph.");else for(e in this.components)this.components[e].destroy()}}function kx(n,e){return!(!n.components[e]||!n.components[e].attrValue)||function(t,i){var r,s=!1;for(r=0;r<i.length&&!(s=i[r].hasAttribute(t));++r);return s}(e,n.mixinEls)}function dm(n){return n.indexOf(Zd)!==-1&&(n=Fr(n,Zd)[0]),!!Yt[n]}function jU(n){if(n.data&&n.data.type==="vr")switch(n.data.data){case"enter":this.enterVR();break;case"exit":this.exitVR()}}an.componentsUpdated=[],an.singlePropUpdate={},customElements.define("a-entity",an),Hc()&&window.addEventListener("orientationchange",function(){document.documentElement.style.height="initial",setTimeout(function(){document.documentElement.style.height="100%",setTimeout(function(){window.scrollTo(0,1)},500)},500)});var fm=Bt("core:a-scene:warn"),$U=Hc(),Gx=Ms(),KU=Hf;class SS extends an{constructor(){var e;super(),(e=this).clock=new C.Clock,e.isIOS=$U,e.isMobile=Gx,e.hasWebXR=KU,e.isAR=!1,e.isScene=!0,e.object3D=new C.Scene,e.resize=e.resize.bind(e),e.render=e.render.bind(e),e.systems={},e.systemNames=[],e.time=e.delta=0,e.usedOfferSession=!1,e.componentOrder=[],e.behaviors={},e.hasLoaded=!1,e.isPlaying=!1,e.originalHTML=e.innerHTML}addFullScreenStyles(){document.documentElement.classList.add("a-fullscreen")}removeFullScreenStyles(){document.documentElement.classList.remove("a-fullscreen")}doConnectedCallback(){var e=this,t=this.hasAttribute("embedded");this.setAttribute("inspector",""),this.setAttribute("keyboard-shortcuts",""),this.setAttribute("screenshot",""),this.setAttribute("xr-mode-ui",""),this.setAttribute("device-orientation-permission-ui",""),super.doConnectedCallback(),function(i){var r;function s(){document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||i.exitVR(),document.activeElement.blur(),document.body.focus()}(r=document.createElement("canvas")).classList.add("a-canvas"),r.dataset.aframeCanvas=!0,i.appendChild(r),document.addEventListener("fullscreenchange",s),document.addEventListener("mozfullscreenchange",s),document.addEventListener("webkitfullscreenchange",s),document.addEventListener("MSFullscreenChange",s),r.addEventListener("touchmove",function(o){o.preventDefault()},{passive:!1}),i.canvas=r,i.emit("render-target-loaded",{target:r}),setTimeout(i.resize.bind(i),0)}(this),this.setupRenderer(),function(i,r){vS=r;var s,o,a,l,c,h,u,d,f,A,g=(Ii=i).hasAttribute(Px)?LU.parse(Ii.getAttribute(Px)):void 0,m=g&&g.dotsColor||"white",p=g&&g.backgroundColor||"#24CAFF";(g===void 0||g.enabled==="true"||g.enabled===void 0)&&(s=new C.Scene,o=new C.SphereGeometry(.2,36,18,0,2*Math.PI,0,Math.PI),a=new C.MeshBasicMaterial({color:m}),l=new C.Mesh(o,a),c=l.clone(),h=l.clone(),u=new C.PerspectiveCamera(80,window.innerWidth/window.innerHeight,5e-4,1e4),d=new C.Clock,f=0,A=function(){Ii.renderer.render(s,u),f=d.getElapsedTime()%4,l.visible=f>=1,c.visible=f>=2,h.visible=f>=3},s.background=new C.Color(p),s.add(u),l.position.set(-1,0,-15),c.position.set(0,0,-15),h.position.set(1,0,-15),u.add(l),u.add(c),u.add(h),(Zr=document.createElement("div")).className="a-loader-title",Zr.innerHTML=document.title,Zr.style.display="none",Zr.setAttribute(vn,""),Ii.appendChild(Zr),setTimeout(function(){Ii.hasLoaded||(sm(u),Zr.style.display="block",window.addEventListener("resize",function(){sm(u)}),Ii.renderer.setAnimationLoop(A))},200))}(this,Vx),this.resize(),t||this.addFullScreenStyles(),AS()&&window.addEventListener("message",jU.bind(this)),function(i){var r,s=document.head,o=s.querySelector("script"),a=[];return TU.forEach(l),i.isIOS&&IU.forEach(l),a;function l(c){c&&!c.exists()&&(r=function(h){if(h&&h.tagName){var u=document.createElement(h.tagName);return u.setAttribute(vn,""),qn(u,h.attributes)}}(c),r&&(o?o.parentNode.insertBefore(r,o):s.appendChild(r),a.push(r)))}}(this),function(i){if(i.isMobile){var r=i.wakelock=new(BU());i.addEventListener("enter-vr",function(){r.request()}),i.addEventListener("exit-vr",function(){r.release()})}}(this),this.enterVRBound=function(){e.enterVR()},this.exitVRBound=function(){e.exitVR()},window.addEventListener("sessionend",this.resize),this.addEventListener("cameraready",function(){e.attachedCallbackPostCamera()}),this.initSystems(),this.componentOrder=zx(Yt,this.componentOrder),this.addEventListener("componentregistered",function(){e.componentOrder=zx(Yt,e.componentOrder)}),this.hasWebXR&&navigator.xr&&navigator.xr.addEventListener&&navigator.xr.addEventListener("sessiongranted",function(){e.enterVR()})}attachedCallbackPostCamera(){var e=this;window.addEventListener("load",void 0),window.addEventListener("resize",function(){e.isIOS?setTimeout(e.resize,100):e.resize()}),this.play(),So.push(this)}initSystems(){var e;for(e in this.initSystem("camera"),wr)e!=="camera"&&this.initSystem(e)}initSystem(e){this.systems[e]||(this.systems[e]=new wr[e](this),this.systemNames.push(e))}disconnectedCallback(){var e=So.indexOf(this);super.disconnectedCallback(),So.splice(e,1),window.removeEventListener("sessionend",this.resize),this.removeFullScreenStyles(),this.renderer.dispose()}addBehavior(e){var t,i,r=this.behaviors[e.name];for(i in r||(r=this.behaviors[e.name]={tick:{inUse:!1,array:[],markedForRemoval:[]},tock:{inUse:!1,array:[],markedForRemoval:[]}}),r)if(e[i]){if((t=r[i]).inUse){var s=t.markedForRemoval.indexOf(e);s!==-1&&t.markedForRemoval.splice(s,1)}t.array.indexOf(e)===-1&&t.array.push(e)}}getPointerLockElement(){return document.pointerLockElement}checkHeadsetConnected(){return H0()}enterAR(){var e;if(!this.hasWebXR)throw e="Failed to enter AR mode, WebXR not supported.",new Error(e);if(!V0())throw e="Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.",new Error(e);return this.enterVR(!0)}enterVR(e,t){var i,r=this,s=r.renderer.xr;if(t&&(!navigator.xr||!navigator.xr.offerSession))return Promise.resolve("OfferSession is not supported.");if(r.usedOfferSession&&t)return Promise.resolve("OfferSession was already called.");if(this.is("vr-mode"))return Promise.resolve("Already in VR.");if(this.checkHeadsetConnected()||this.isMobile){var o=r.getAttribute("renderer");if(s.enabled=!0,this.hasWebXR){this.xrSession&&this.xrSession.removeEventListener("end",this.exitVRBound);var a=this.sceneEl.systems.webxr.sessionReferenceSpaceType;s.setReferenceSpaceType(a);var l=e?"immersive-ar":"immersive-vr";return i=this.sceneEl.systems.webxr.sessionConfiguration,new Promise(function(h,u){var d=t?navigator.xr.offerSession.bind(navigator.xr):navigator.xr.requestSession.bind(navigator.xr);r.usedOfferSession|=t,d(l,i).then(function(f){t&&(r.usedOfferSession=!1),s.layersEnabled=i.requiredFeatures.indexOf("layers")!==-1,s.setSession(f).then(function(){s.setFoveation(o.foveationLevel),r.xrSession=f,r.systems.renderer.setWebXRFrameRate(f),f.addEventListener("end",r.exitVRBound),c(h)})},function(f){u(new Error("Failed to enter "+(l==="immersive-ar"?"AR":"VR")+" mode (`requestSession`)",{cause:f}))})})}throw new Error("Failed to enter "+(e?"AR":"VR")+" no WebXR")}return c(),Promise.resolve();function c(h){var u;e?r.addState("ar-mode"):r.addState("vr-mode"),r.emit("enter-vr",{target:r}),!r.hasWebXR&&r.isMobile&&screen.orientation&&screen.orientation.lock&&screen.orientation.lock("landscape"),r.addFullScreenStyles(),r.isMobile||r.checkHeadsetConnected()||((u=r.canvas).requestFullscreen||u.webkitRequestFullscreen||u.mozRequestFullScreen||u.msRequestFullscreen).apply(u,[{navigationUI:"hide"}]),r.resize(),h&&h()}}exitVR(){var e=this,t=this.renderer.xr;if(!this.is("vr-mode")&&!this.is("ar-mode"))return Promise.resolve("Not in immersive mode.");if(this.checkHeadsetConnected()||this.isMobile){if(t.enabled=!1,!this.hasWebXR)throw Error("Failed to exit VR - no WebXR");this.xrSession.removeEventListener("end",this.exitVRBound),this.xrSession.end().then(function(){},function(){}),this.xrSession=void 0}else(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement)&&(document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen());return e.removeState("vr-mode"),e.removeState("ar-mode"),e.isMobile&&screen.orientation&&screen.orientation.unlock&&screen.orientation.unlock(),e.hasAttribute("embedded")&&e.removeFullScreenStyles(),e.resize(),e.isIOS&&lS(e.canvas),e.renderer.setPixelRatio(window.devicePixelRatio),e.emit("exit-vr",{target:e}),Promise.resolve()}getAttribute(e){var t=this.systems[e];return t?t.data:an.prototype.getAttribute.call(this,e)}getDOMAttribute(e){var t=this.systems[e];return t?t.data:an.prototype.getDOMAttribute.call(this,e)}setAttribute(e,t,i){if(wr[e]){En.prototype.setAttribute.call(this,e,t);var r=this.systems[e];r&&r.updateProperties(t)}else an.prototype.setAttribute.call(this,e,t,i)}removeBehavior(e){var t,i,r,s=this.behaviors[e.name];for(i in s)e[i]&&(r=(t=s[i]).array.indexOf(e))!==-1&&(t.inUse?t.markedForRemoval.indexOf(e)===-1&&t.markedForRemoval.push(e):(t.array[r]=t.array[t.array.length-1],t.array.pop()))}resize(){var e,t,i=this.camera,r=this.canvas,s=this.renderer.xr.isPresenting;e=this.renderer.xr.enabled&&s,!i||!r||this.is("vr-mode")&&(this.isMobile||e)||(t=Vx(r,this.getAttribute("embedded")&&!this.is("vr-mode"),this.maxCanvasSize,this.is("vr-mode")),i.aspect=t.width/t.height,i.updateProjectionMatrix(),this.renderer.setSize(t.width,t.height,!1),this.emit("rendererresize",null,!1))}setupRenderer(){var e,t,i,r=this;i={alpha:!0,antialias:!Gx,canvas:this.canvas,logarithmicDepthBuffer:!1,powerPreference:"high-performance"},this.maxCanvasSize={height:-1,width:-1},this.hasAttribute("renderer")&&((t=bc(this.getAttribute("renderer"))).precision&&(i.precision=t.precision+"p"),t.antialias&&t.antialias!=="auto"&&(i.antialias=t.antialias==="true"),t.logarithmicDepthBuffer&&t.logarithmicDepthBuffer!=="auto"&&(i.logarithmicDepthBuffer=t.logarithmicDepthBuffer==="true"),t.alpha&&(i.alpha=t.alpha==="true"),t.stencil&&(i.stencil=t.stencil==="true"),t.multiviewStereo&&(i.multiviewStereo=t.multiviewStereo==="true"),this.maxCanvasSize={width:t.maxCanvasWidth?parseInt(t.maxCanvasWidth):this.maxCanvasSize.width,height:t.maxCanvasHeight?parseInt(t.maxCanvasHeight):this.maxCanvasSize.height});var s=["WebGLRenderer","WebGPURenderer"].find(function(o){return C[o]});(e=this.renderer=new C[s](i)).xr.setPoseTarget||(e.xr.setPoseTarget=function(){}),e.setPixelRatio(window.devicePixelRatio),this.camera&&e.xr.setPoseTarget(this.camera.el.object3D),this.addEventListener("camera-set-active",function(){e.xr.setPoseTarget(r.camera.el.object3D)})}play(){var e=this,t=this;this.renderStarted?an.prototype.play.call(this):(this.addEventListener("loaded",function(){var i=this.renderer;an.prototype.play.call(this),t.renderStarted||(t.resize(),t.renderer&&(window.performance&&window.performance.mark("render-started"),window.removeEventListener("resize",sm),Zr&&(Zr.style.display="none"),i.setAnimationLoop(this.render),t.renderStarted=!0,t.emit("renderstart")))}),setTimeout(function(){an.prototype.load.call(e)}))}updateComponent(e){e in wr||an.prototype.updateComponent.apply(this,arguments)}tick(e,t){var i,r=this.systems;for(this.callComponentBehaviors("tick",e,t),i=0;i<this.systemNames.length;i++)r[this.systemNames[i]].tick&&r[this.systemNames[i]].tick(e,t)}tock(e,t,i){var r,s=this.systems;for(this.callComponentBehaviors("tock",e,t),r=0;r<this.systemNames.length;r++)s[this.systemNames[r]].tock&&s[this.systemNames[r]].tock(e,t,i)}render(e,t){var i=this.renderer;this.frame=t,this.delta=1e3*this.clock.getDelta(),this.time=1e3*this.clock.elapsedTime,this.isPlaying&&this.tick(this.time,this.delta);var r=null;if(this.is("ar-mode")&&(r=this.object3D.background,this.object3D.background=null),i.render(this.object3D,this.camera),r&&(this.object3D.background=r),this.isPlaying){var s=i.xr.isPresenting?i.xr.getCamera():this.camera;this.tock(this.time,this.delta,s)}}callComponentBehaviors(e,t,i){for(var r,s=0;s<this.componentOrder.length;s++){var o=this.behaviors[this.componentOrder[s]];if(o){var a=o[e];for(a.inUse=!0,r=0;r<a.array.length;r++)a.array[r].isPlaying&&a.array[r][e](t,i);for(a.inUse=!1,r=0;r<a.markedForRemoval.length;r++)this.removeBehavior(a.markedForRemoval[r]);a.markedForRemoval.length=0}}}}function zx(n,e){var t,i,r={},s=e||[];for(i in s.length=0,n){var o=n[i];if(o!==void 0){var a=o.before?o.before.slice(0):[],l=o.after?o.after.slice(0):[];r[i]={before:a,after:l,visited:!1,done:!1}}}for(i in r)for(t=0;t<r[i].before.length;t++){var c=r[i].before[t];c in r?r[c].after.push(i):fm("Invalid ordering constraint, no component named `"+c+"` referenced by `"+i+"`")}function h(u){if(u in r&&!r[u].done)if(r[u].visited)fm("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");else{r[u].visited=!0;for(var d=0;d<r[u].after.length;d++){var f=r[u].after[d];f in r||fm("Invalid before/after constraint, no component named `"+f+"` referenced in `"+u+"`"),h(f)}r[u].done=!0,s.push(u)}}for(i in r)r[i].done||h(i);return s}function Hx(n,e){var t,i=window.devicePixelRatio;return!e||e.width===-1&&e.height===-1||n.width*i<e.width&&n.height*i<e.height||(t=n.width/n.height,n.width*i>e.width&&e.width!==-1&&(n.width=Math.round(e.width/i),n.height=Math.round(e.width/t/i)),n.height*i>e.height&&e.height!==-1&&(n.height=Math.round(e.height/i),n.width=Math.round(e.height*t/i))),n}function Vx(n,e,t,i){return n.parentElement?e?Hx({height:n.parentElement.offsetHeight,width:n.parentElement.offsetWidth},t):function(r,s){var o;return o={height:document.body.offsetHeight,width:document.body.offsetWidth},s?o:Hx(o,r)}(t,i):{height:0,width:0}}customElements.define("a-scene",SS);var JU=Vc,Ss={},av=[],tg=function(){};function Nn(n,e){var t,i={};if(Object.keys(e).forEach(function(r){i[r]={value:e[r],writable:!0}}),Ss[n])throw new Error("The geometry `"+n+"` has been already registered");return((t=function(){tg.call(this)}).prototype=Object.create(tg.prototype,i)).name=n,t.prototype.constructor=t,Ss[n]={Geometry:t,schema:JU(t.prototype.schema)},av.push(n),t}tg.prototype={schema:{},init:function(n){return this.geometry=new C.BufferGeometry,this.geometry},update:function(n){}};var lv=Bt,ZU=K0,eF=lv("extras:primitives:debug"),Qx=lv("extras:primitives:warn"),tF=lv("extras:primitives:error"),wS={};function Pn(n,e){if(n=n.toLowerCase(),!eg[n]){eg[n]=!0,eF("Registering <%s>",n),e.defaultAttributes&&Qx("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");var t=e.mappings||{},i=class extends an{constructor(){super(),this.defaultComponentsFromPrimitive=e.defaultComponents||e.defaultAttributes||{},this.deprecated=e.deprecated||null,this.deprecatedMappings=e.deprecatedMappings||{},this.mappings=t,e.deprecated&&console.warn(e.deprecated),this.resolveMappingCollisions()}resolveMappingCollisions(){var r=this.mappings,s=this;Object.keys(r).forEach(function(o){var a;o!==o.toLowerCase()&&Qx("Mapping keys should be specified in lower case. The mapping key "+o+" may not be recognized"),Yt[o]&&(a=r[o].replace(".","-"),r[a]=r[o],delete r[o],console.warn("The primitive "+s.tagName.toLowerCase()+" has a mapping collision. The attribute "+o+" has the same name as a registered component and has been renamed to "+a))})}getExtraComponents(){var r,s,o,a,l,c=this;for(s=iv(this.defaultComponentsFromPrimitive),(l=this.getAttribute("mixin"))&&(l=Fr(l.trim(),/\s+/)).forEach(function(f){var A,g,m=document.getElementById(f);if(m){var p=m.rawAttributeCache,v=m.componentCache;for(var E in p){if(a=c.mappings[E])return void Wx(a,p[E],s);E in v&&(s[E]=(A=s[E],g=v[E],h(A)?u(g):h(g)?u(A):d(A)&&d(g)?ti(A,g):u(g)))}}}),o=0;o<this.attributes.length;o++)r=this.attributes[o],(a=this.mappings[r.name])&&Wx(a,r.value,s);return s;function h(f){return f===void 0}function u(f){return d(f)?ti({},f):f}function d(f){return f!==null&&f.constructor===Object}}attributeChangedCallback(r,s,o){var a=this.mappings[r];r in this.deprecatedMappings&&console.warn(this.deprecatedMappings[r]),r&&a?ZU(this,a,o):super.attributeChangedCallback(r,s,o)}};return customElements.define(n,i),i.mappings=t,wS[n]=i,i}tF("Trying to register primitive "+n+" that has been already previously registered")}function Wx(n,e,t){var i=Vf(n);i.constructor===Array?(t[i[0]]=t[i[0]]||{},t[i[0]][i[1]]=e.trim()):t[i]=e.trim()}var ji={},TS=[],nF={array:"v3",color:"v3",int:"i",number:"f",map:"t",time:"f",vec2:"v2",vec3:"v3",vec4:"v4"},ng=function(){};function hs(n,e){var t,i={};if(Object.keys(e).forEach(function(r){i[r]={value:e[r],writable:!0}}),ji[n])throw new Error("The shader "+n+" has already been registered");return((t=function(){ng.call(this)}).prototype=Object.create(ng.prototype,i)).name=n,t.prototype.constructor=t,ji[n]={Shader:t,schema:Vc(t.prototype.schema)},TS.push(n),t}ng.prototype={schema:{},vertexShader:"void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",fragmentShader:"void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",init:function(n){return this.uniforms=this.initUniforms(),this.material=new(this.raw?C.RawShaderMaterial:C.ShaderMaterial)({uniforms:this.uniforms,glslVersion:this.raw||this.glsl3?C.GLSL3:null,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader}),this.material},initUniforms:function(){var n,e,t=this.schema,i={};for(n in t)t[n].is==="uniform"&&(e=nF[t[n].type],i[n]={type:e,value:void 0});return i},update:function(n){var e,t,i=this.schema,r=this.uniforms;for(e in n)if(i[e]&&i[e].is==="uniform")if(i[e].type!=="map")r[e].value=this.parseValue(i[e].type,n[e]),r[e].needsUpdate=!0;else{if(!r[e]||r[e].value===n[e])continue;t="_texture_"+e,this.setMapOnTextureLoad(r,e,t),Qf(t,e,this,n)}},parseValue:function(n,e){var t;switch(n){case"vec2":return new C.Vector2(e.x,e.y);case"vec3":return new C.Vector3(e.x,e.y,e.z);case"vec4":return new C.Vector4(e.x,e.y,e.z,e.w);case"color":return t=new C.Color(e),new C.Vector3(t.r,t.g,t.b);default:return e}},setMapOnTextureLoad:function(n,e,t){var i=this;this.el.addEventListener("materialtextureloaded",function(){n[e].value=i.material[t],n[e].needsUpdate=!0})}};var pm=new C.FileLoader,ig=Bt("core:a-assets:warn");function iF(n){if(n.hasAttribute("autoplay")||n.getAttribute("preload")==="auto")return new Promise(function(e,t){if(n.readyState===4)return e();if(n.error)return t();function i(){for(var r=0,s=0;s<n.buffered.length;s++)r+=n.buffered.end(s)-n.buffered.start(s);r>=n.duration&&(n.tagName==="VIDEO"&&C.Cache.add(n.getAttribute("src"),n),e())}n.addEventListener("loadeddata",i,!1),n.addEventListener("progress",i,!1),n.addEventListener("error",t,!1)})}function Xx(n){var e=function(t){var i,r,s;return t.hasAttribute("crossorigin")||(i=t.getAttribute("src"))!==null&&(i.indexOf("://")===-1||(s=(r=i).indexOf("://")>-1?r.split("/")[2]:r.split("/")[0]).substring(0,s.indexOf(":"))===window.location.host)?t:(ig('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)',i),t.crossOrigin="anonymous",t.cloneNode(!0))}(n);return e.tagName&&e.tagName.toLowerCase()==="video"&&(e.setAttribute("playsinline",""),e.setAttribute("webkit-playsinline","")),e!==n&&(n.parentNode.appendChild(e),n.parentNode.removeChild(n)),e}customElements.define("a-assets",class extends En{constructor(){super(),this.isAssets=!0,this.fileLoader=pm,this.timeout=null}doConnectedCallback(){var n,e,t,i,r,s,o=this,a=[];if(super.doConnectedCallback(),!this.parentNode.isScene)throw new Error("<a-assets> must be a child of a <a-scene>.");for(r=this.querySelectorAll("img"),n=0;n<r.length;n++)i=Xx(r[n]),a.push(new Promise(function(l,c){C.Cache.add(r[n].getAttribute("src"),i),i.complete?l():(i.onload=l,i.onerror=c)}));for(t=this.querySelectorAll("audio, video"),n=0;n<t.length;n++)(e=Xx(t[n])).src||e.srcObject||ig("Audio/video asset has neither `src` nor `srcObject` attributes."),a.push(iF(e));this.getChildren().forEach(function(l){l.isAssetItem&&l.hasAttribute("src")&&a.push(new Promise(function(c,h){if(l.hasLoaded)return c();l.addEventListener("loaded",c),l.addEventListener("error",h)}))}),Promise.allSettled(a).then(function(){o.timeout!==null&&o.load()}),s=parseInt(this.getAttribute("timeout"),10)||3e3,this.timeout=setTimeout(function(){o.hasLoaded||(ig("Asset loading timed out in",s,"ms"),o.timeout=null,o.emit("timeout"),o.load())},s)}disconnectedCallback(){super.disconnectedCallback(),this.timeout&&clearTimeout(this.timeout)}load(){super.load.call(this,null,function(){return!1})}}),customElements.define("a-asset-item",class extends En{constructor(){super(),this.data=null,this.isAssetItem=!0}connectedCallback(){var n=this,e=this.getAttribute("src");pm.setResponseType(this.getAttribute("response-type")||function(t){var i=function(s){var o=document.createElement("a");o.href=s;var a=o.search.replace(/^\?/,""),l=s.replace(a,"").replace("?","");return l.substring(l.lastIndexOf("/")+1)}(t),r=i.lastIndexOf(".");return r>=0&&i.slice(r,t.search(/\?|#|$/))===".glb"?"arraybuffer":"text"}(e)),pm.load(e,function(t){n.data=t,En.prototype.load.call(n)},function(t){n.emit("progress",{loadedBytes:t.loaded,totalBytes:t.total,xhr:t})},function(t){n.emit("error",{xhr:t},!1)})}});var rF=Bt("core:cubemap:warn");class cv extends HTMLElement{constructor(e){return super(e)}onReadyStateChange(){document.readyState==="complete"&&this.doConnectedCallback()}connectedCallback(){document.readyState==="complete"?cv.prototype.doConnectedCallback.call(this):document.addEventListener("readystatechange",this.onReadyStateChange.bind(this))}doConnectedCallback(){this.srcs=this.validate()}validate(){var e,t=this.querySelectorAll("[src]"),i=[];if(t.length===6){for(e=0;e<t.length;e++)t[e].tagName==="IMG"?i.push(t[e]):i.push(t[e].getAttribute("src"));return i}rF("<a-cubemap> did not contain exactly six elements each with a `src` attribute.")}}customElements.define("a-cubemap",cv),customElements.define("a-mixin",class extends En{constructor(){super(),this.componentCache={},this.rawAttributeCache={},this.isMixin=!0}doConnectedCallback(){super.doConnectedCallback(),this.sceneEl=this.closestScene(),this.id=this.getAttribute("id"),this.cacheAttributes(),this.updateEntities(),this.load()}attributeChangedCallback(n,e,t){super.attributeChangedCallback(),this.cacheAttribute(n,t),this.updateEntities()}setAttribute(n,e){window.HTMLElement.prototype.setAttribute.call(this,n,e),this.cacheAttribute(n,e)}cacheAttribute(n,e){var t,i;i=Fr(n,"__")[0],t=Yt[i],e===void 0&&(e=window.HTMLElement.prototype.getAttribute.call(this,n)),this.rawAttributeCache[n]=e,t&&(this.componentCache[n]=this.parseComponentAttrValue(t,e))}parseComponentAttrValue(n,e){var t;return typeof e!="string"?e:(n.isSingleProperty?typeof(t=n.schema.parse(e))=="string"&&(t=e):t=bc(e),t)}getAttribute(n){return this.componentCache[n]||window.HTMLElement.prototype.getAttribute.call(this,n)}cacheAttributes(){var n,e,t=this.attributes;for(e=0;e<t.length;e++)n=t[e].name,this.cacheAttribute(n)}updateEntities(){var n,e,t;if(this.sceneEl)for(e=this.sceneEl.querySelectorAll("[mixin~="+this.id+"]"),t=0;t<e.length;t++)(n=e[t]).hasLoaded&&!n.isMixin&&n.mixinUpdate(this.id)}});const IS="1.7.0";var Xh=new C.Color,qh=new C.Color,qx=aS,Yx=K0,mm={},RS="color",jx="rotation",BS="components";function $x(n){n.x=C.MathUtils.degToRad(n.x),n.y=C.MathUtils.degToRad(n.y),n.z=C.MathUtils.degToRad(n.z)}function Am(n,e,t){var i;for(i=0;i<e.length;i++)n.addEventListener(e[i],t)}function gm(n,e,t){var i;for(i=0;i<e.length;i++)n.removeEventListener(e[i],t)}function Kx(n,e){var t,i,r;for(i=ef(e),r=n,t=0;t<i.length;t++)r=r[i[t]];if(r===void 0)throw console.log(n),new Error("[animation] property ("+e+") could not be found");return r}function Jx(n,e,t,i){var r,s,o,a;for(e.startsWith("object3D.rotation")&&(t=C.MathUtils.degToRad(t)),s=ef(e),a=n,r=0;r<s.length-1;r++)a=a[s[r]];o=s[s.length-1],i!==RS?a[o]=t:"r"in a[o]?(a[o].r=t.r,a[o].g=t.g,a[o].b=t.b):(a[o].x=t.r,a[o].y=t.g,a[o].z=t.b)}function ef(n){return n in mm||(mm[n]=n.split(".")),mm[n]}function vm(n){return n.isRawProperty||n.property.startsWith(BS)||n.property.startsWith("object3D")}tt("animation",{schema:{autoplay:{default:!0},delay:{default:0},dir:{default:""},dur:{default:1e3},easing:{default:"easeInQuad"},elasticity:{default:400},enabled:{default:!0},from:{default:""},loop:{default:0,parse:function(n){return n===!0||n==="true"||n!==!1&&n!=="false"&&parseInt(n,10)}},property:{default:""},startEvents:{type:"array"},pauseEvents:{type:"array"},resumeEvents:{type:"array"},round:{default:!1},to:{default:""},type:{default:""},isRawProperty:{default:!1}},multiple:!0,init:function(){var n=this;this.eventDetail={name:this.attrName},this.time=0,this.animation=null,this.animationIsPlaying=!1,this.onStartEvent=this.onStartEvent.bind(this),this.beginAnimation=this.beginAnimation.bind(this),this.pauseAnimation=this.pauseAnimation.bind(this),this.resumeAnimation=this.resumeAnimation.bind(this),this.fromColor={},this.toColor={},this.targets={},this.targetsArray=[],this.updateConfigForDefault=this.updateConfigForDefault.bind(this),this.updateConfigForRawColor=this.updateConfigForRawColor.bind(this),this.config={complete:function(){n.animationIsPlaying=!1,n.el.emit("animationcomplete",n.eventDetail,!1),n.id&&n.el.emit("animationcomplete__"+n.id,n.eventDetail,!1)}}},update:function(n){var e=this.config,t=this.data;this.animationIsPlaying=!1,this.data.enabled&&t.property&&(e.autoplay=!1,e.direction=t.dir,e.duration=t.dur,e.easing=t.easing,e.elasticity=t.elasticity,e.loop=t.loop,e.round=t.round,this.createAndStartAnimation())},tick:function(n,e){this.animationIsPlaying&&(this.time+=e,this.animation.tick(this.time))},remove:function(){this.pauseAnimation(),this.removeEventListeners()},pause:function(){this.paused=!0,this.pausedWasPlaying=this.animationIsPlaying,this.pauseAnimation(),this.removeEventListeners()},play:function(){this.paused&&(this.paused=!1,this.addEventListeners(),this.pausedWasPlaying&&(this.resumeAnimation(),this.pausedWasPlaying=!1))},createAndStartAnimation:function(){var n=this.data;this.updateConfig(),this.animationIsPlaying=!1,this.animation=zu(this.config),this.animation.began=!0,this.removeEventListeners(),this.addEventListeners(),!n.autoplay||n.startEvents&&n.startEvents.length||(n.delay?setTimeout(this.beginAnimation,n.delay):this.beginAnimation())},beginAnimation:function(){this.updateConfig(),this.animation.began=!0,this.time=0,this.animationIsPlaying=!0,this.stopRelatedAnimations(),this.el.emit("animationbegin",this.eventDetail,!1)},pauseAnimation:function(){this.animationIsPlaying=!1},resumeAnimation:function(){this.animationIsPlaying=!0},onStartEvent:function(){this.data.enabled&&(this.updateConfig(),this.animation&&this.animation.pause(),this.animation=zu(this.config),this.data.delay?setTimeout(this.beginAnimation,this.data.delay):this.beginAnimation())},updateConfigForRawColor:function(){var n,e,t,i=this.config,r=this.data,s=this.el;if(!this.waitComponentInitRawProperty(this.updateConfigForRawColor)){for(e in n=r.from===""?Kx(s,r.property):r.from,t=r.to,this.setColorConfig(n,t),n=this.fromColor,t=this.toColor,this.targetsArray.length=0,this.targetsArray.push(n),i.targets=this.targetsArray,t)i[e]=t[e];var o;i.update=(o={},function(a){var l;(l=a.animatables[0].target).r===o.r&&l.g===o.g&&l.b===o.b||Jx(s,r.property,l,r.type)})}},updateConfigForDefault:function(){var n,e,t,i,r=this.config,s=this.data,o=this.el;this.waitComponentInitRawProperty(this.updateConfigForDefault)||(n=s.from===""?vm(s)?Kx(o,s.property):qx(o,s.property):s.from,t=s.to,isNaN(n||t)?(n=n&&n.toString(),t=t&&t.toString()):(n=parseFloat(n),t=parseFloat(t)),(e=s.to==="true"||s.to==="false"||s.to===!0||s.to===!1)&&(n=s.from==="true"||s.from===!0?1:0,t=s.to==="true"||s.to===!0?1:0),this.targets.aframeProperty=n,r.targets=this.targets,r.aframeProperty=t,r.update=function(a){var l;(l=a.animatables[0].target.aframeProperty)!==i&&(i=l,e&&(l=l>=1),vm(s)?Jx(o,s.property,l,s.type):Yx(o,s.property,l))})},updateConfigForVector:function(){var n,e,t,i,r=this.config,s=this.data,o=this.el,a=ef(s.property),l=a[0]==="object3D"?a[1]:a[0];for(n in e=s.from!==""?Xd(s.from):qx(o,l),t=Xd(s.to),l===jx&&($x(e),$x(t)),this.targetsArray.length=0,this.targetsArray.push(e),r.targets=this.targetsArray,t)r[n]=t[n];r.update=l!=="position"&&l!==jx&&l!=="scale"?function(){var c={};return function(h){var u=h.animatables[0].target;u.x===c.x&&u.y===c.y&&u.z===c.z||(c.x=u.x,c.y=u.y,c.z=u.z,Yx(o,s.property,u))}}():(i={},function(c){var h=c.animatables[0].target;h.x===i.x&&h.y===i.y&&h.z===i.z||(i.x=h.x,i.y=h.y,i.z=h.z,o.object3D[l].set(h.x,h.y,h.z))})},updateConfig:function(){var n;n=function(e,t){var i,r,s,o;return(s=t.split("."))[0]!=="object3D"||s[2]||s[1]!=="position"&&s[1]!=="rotation"&&s[1]!=="scale"?(r=s[0],o=s[1],(i=e.components[r]||Yt[r])?o&&!i.schema[o]?null:o?i.schema[o].type:i.schema.type:null):"vec3"}(this.el,this.data.property),vm(this.data)&&this.data.type===RS?this.updateConfigForRawColor():n==="vec2"||n==="vec3"||n==="vec4"?this.updateConfigForVector():this.updateConfigForDefault()},waitComponentInitRawProperty:function(n){var e,t=this.data,i=this.el,r=this;return t.from===""&&!!t.property.startsWith(BS)&&(e=ef(t.property)[1],!i.components[e]&&(i.addEventListener("componentinitialized",function s(o){o.detail.name===e&&(n(),r.animation=zu(r.config),i.removeEventListener("componentinitialized",s))}),!0))},stopRelatedAnimations:function(){var n,e;for(e in this.el.components)n=this.el.components[e],e!==this.attrName&&n.name==="animation"&&n.animationIsPlaying&&n.data.property===this.data.property&&(n.animationIsPlaying=!1)},addEventListeners:function(){var n=this.data,e=this.el;Am(e,n.startEvents,this.onStartEvent),Am(e,n.pauseEvents,this.pauseAnimation),Am(e,n.resumeEvents,this.resumeAnimation)},removeEventListeners:function(){var n=this.data,e=this.el;gm(e,n.startEvents,this.onStartEvent),gm(e,n.pauseEvents,this.pauseAnimation),gm(e,n.resumeEvents,this.resumeAnimation)},setColorConfig:function(n,e){Xh.set(n),qh.set(e),n=this.fromColor,e=this.toColor,n.r=Xh.r,n.g=Xh.g,n.b=Xh.b,e.r=qh.r,e.g=qh.g,e.b=qh.b}});var Em=Bt("components:anchored:warn");tt("anchored",{schema:{persistent:{default:!1}},init:function(){var n=this.el.sceneEl.getAttribute("webxr"),e=n.optionalFeatures;e.indexOf("anchors")===-1&&(e.push("anchors"),this.el.sceneEl.setAttribute("webxr",n)),this.auxQuaternion=new C.Quaternion,this.onEnterVR=this.onEnterVR.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR)},onEnterVR:function(){this.anchor=void 0,this.requestPersistentAnchorPending=this.data.persistent,this.requestAnchorPending=!this.data.persistent},tick:function(){var n,e,t,i=this.el.sceneEl,r=i.renderer.xr,s=this.el.object3D;(i.is("ar-mode")||i.is("vr-mode"))&&(!this.anchor&&this.requestPersistentAnchorPending&&this.restorePersistentAnchor(),!this.anchor&&this.requestAnchorPending&&this.createAnchor(),this.anchor&&(n=i.frame,e=r.getReferenceSpace(),t=n.getPose(this.anchor.anchorSpace,e),s.position.copy(t.transform.position),s.quaternion.copy(t.transform.orientation)))},createAnchor:async function(n,e){var t,i,r,s,o=this.el.sceneEl,a=o.renderer.xr,l=this.el.object3D;n=n||l.position,e=e||this.auxQuaternion.setFromEuler(l.rotation),function(c){var h=c.renderer.xr.getSession();return h&&h.restorePersistentAnchor}(o)?(this.anchor&&this.deleteAnchor(),t=o.frame,i=a.getReferenceSpace(),r=new XRRigidTransform({x:n.x,y:n.y,z:n.z},{x:e.x,y:e.y,z:e.z,w:e.w}),this.requestAnchorPending=!1,s=await t.createAnchor(r,i),this.data.persistent&&(this.el.id?(this.persistentHandle=await s.requestPersistentHandle(),localStorage.setItem(this.el.id,this.persistentHandle)):Em("The anchor won't be persisted because the entity has no assigned id.")),o.object3D.attach(this.el.object3D),this.anchor=s):Em("This browser doesn't support the WebXR anchors module")},restorePersistentAnchor:async function(){var n,e=this.el.sceneEl.renderer.xr.getSession(),t=e.persistentAnchors;if(this.requestPersistentAnchorPending=!1,!this.el.id)return Em("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."),void(this.requestAnchorPending=!0);if(t){n=localStorage.getItem(this.el.id);for(var i=0;i<t.length;++i)if(n===t[i]){this.anchor=await e.restorePersistentAnchor(t[i]),this.anchor&&(this.persistentHandle=t[i]);break}this.anchor||(this.requestAnchorPending=!0)}else this.requestPersistentAnchorPending=!0},deleteAnchor:function(){var n,e=this.anchor;e&&(n=this.el.sceneEl.renderer.xr.getSession(),e.delete(),this.el.sceneEl.object3D.add(this.el.object3D),this.persistentHandle&&n.deletePersistentAnchor(this.persistentHandle),this.anchor=void 0)}}),tt("camera",{schema:{active:{default:!0},far:{default:1e4},fov:{default:80,min:0},near:{default:.005,min:0},spectator:{default:!1},zoom:{default:1,min:0}},init:function(){var n,e=this.el;n=this.camera=new C.PerspectiveCamera,e.setObject3D("camera",n)},update:function(n){var e=this.data,t=this.camera;t.aspect=e.aspect||window.innerWidth/window.innerHeight,t.far=e.far,t.fov=e.fov,t.near=e.near,t.zoom=e.zoom,t.updateProjectionMatrix(),this.updateActiveCamera(n),this.updateSpectatorCamera(n)},updateActiveCamera:function(n){var e=this.data,t=this.el,i=this.system;n&&n.active===e.active||e.spectator||(e.active&&i.activeCameraEl!==t?i.setActiveCamera(t):e.active||i.activeCameraEl!==t||i.disableActiveCamera())},updateSpectatorCamera:function(n){var e=this.data,t=this.el,i=this.system;n&&n.spectator===e.spectator||(e.spectator&&i.spectatorCameraEl!==t?i.setSpectatorCamera(t):e.spectator||i.spectatorCameraEl!==t||i.disableSpectatorCamera())},remove:function(){this.el.removeObject3D("camera")}});var es,Js,ts,Zx,ey="click",ty="mouseup",Yh="cursor-fusing",xm="cursor-hovering",ym="cursor-hovered",jh={DOWN:["mousedown","touchstart"],UP:["mouseup","touchend"]},$h={DOWN:["selectstart"],UP:["selectend"]},ny="a-mouse-cursor-hover",sF=(tt("cursor",{dependencies:["raycaster"],schema:{downEvents:{default:[]},fuse:{default:Ms()},fuseTimeout:{default:1500,min:0},mouseCursorStylesEnabled:{default:!0},upEvents:{default:[]},rayOrigin:{default:"entity",oneOf:["mouse","entity","xrselect"]}},after:["tracked-controls"],multiple:!0,init:function(){var n=this;this.fuseTimeout=void 0,this.cursorDownEl=null,this.intersectedEl=null,this.canvasBounds=document.body.getBoundingClientRect(),this.isCursorDown=!1,this.activeXRInput=null,this.updateCanvasBounds=pS(function(){n.canvasBounds=n.el.sceneEl.canvas.getBoundingClientRect()},500),this.eventDetail={},this.intersectedEventDetail={cursorEl:this.el},this.onCursorDown=this.onCursorDown.bind(this),this.onCursorUp=this.onCursorUp.bind(this),this.onIntersection=this.onIntersection.bind(this),this.onIntersectionCleared=this.onIntersectionCleared.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onEnterVR=this.onEnterVR.bind(this)},update:function(n){var e=this.data.rayOrigin;e!==n.rayOrigin&&(e==="entity"&&this.resetRaycaster(),this.updateMouseEventListeners(),e!=="xrselect"&&e!=="entity"||this.addWebXREventListeners(),n.rayOrigin!=="xrselect"&&n.rayOrigin!=="entity"||this.removeWebXREventListeners())},tick:function(){var n=this.el.sceneEl.frame,e=this.activeXRInput;this.data.rayOrigin==="xrselect"&&n&&e&&this.onMouseMove({frame:n,inputSource:e,type:"fakeselectevent"})},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){var n=this.el;n.removeState(xm),n.removeState(Yh),clearTimeout(this.fuseTimeout),this.intersectedEl&&this.intersectedEl.removeState(ym),this.removeEventListeners()},addEventListeners:function(){var n,e=this.data,t=this.el,i=this;function r(){n=t.sceneEl.canvas,e.downEvents.length||e.upEvents.length||(jh.DOWN.forEach(function(s){n.addEventListener(s,i.onCursorDown,{passive:!1})}),jh.UP.forEach(function(s){n.addEventListener(s,i.onCursorUp,{passive:!1})}))}(n=t.sceneEl.canvas)?r():t.sceneEl.addEventListener("render-target-loaded",r),e.downEvents.forEach(function(s){t.addEventListener(s,i.onCursorDown)}),e.upEvents.forEach(function(s){t.addEventListener(s,i.onCursorUp)}),t.addEventListener("raycaster-intersection",this.onIntersection),t.addEventListener("raycaster-closest-entity-changed",this.onIntersection),t.addEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),t.sceneEl.addEventListener("rendererresize",this.updateCanvasBounds),t.sceneEl.addEventListener("enter-vr",this.onEnterVR),window.addEventListener("resize",this.updateCanvasBounds),window.addEventListener("scroll",this.updateCanvasBounds),this.updateMouseEventListeners()},removeEventListeners:function(){var n,e=this.data,t=this.el,i=this;!(n=t.sceneEl.canvas)||e.downEvents.length||e.upEvents.length||(jh.DOWN.forEach(function(r){n.removeEventListener(r,i.onCursorDown)}),jh.UP.forEach(function(r){n.removeEventListener(r,i.onCursorUp)})),e.downEvents.forEach(function(r){t.removeEventListener(r,i.onCursorDown)}),e.upEvents.forEach(function(r){t.removeEventListener(r,i.onCursorUp)}),t.removeEventListener("raycaster-intersection",this.onIntersection),t.removeEventListener("raycaster-closest-entity-changed",this.onIntersection),t.removeEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),n.removeEventListener("mousemove",this.onMouseMove),n.removeEventListener("touchstart",this.onMouseMove),n.removeEventListener("touchmove",this.onMouseMove),t.sceneEl.removeEventListener("rendererresize",this.updateCanvasBounds),t.sceneEl.removeEventListener("enter-vr",this.onEnterVR),window.removeEventListener("resize",this.updateCanvasBounds),window.removeEventListener("scroll",this.updateCanvasBounds),this.removeWebXREventListeners()},updateMouseEventListeners:function(){var n,e=this.el;(n=e.sceneEl.canvas).removeEventListener("mousemove",this.onMouseMove),n.removeEventListener("touchmove",this.onMouseMove),e.setAttribute("raycaster","useWorldCoordinates",!1),this.data.rayOrigin==="mouse"&&(n.addEventListener("mousemove",this.onMouseMove),n.addEventListener("touchmove",this.onMouseMove,{passive:!1}),e.setAttribute("raycaster","useWorldCoordinates",!0),this.updateCanvasBounds())},resetRaycaster:function(){this.el.setAttribute("raycaster",{direction:new C.Vector3().set(0,0,-1),origin:new C.Vector3})},addWebXREventListeners:function(){var n=this,e=this.el.sceneEl.xrSession;e&&($h.DOWN.forEach(function(t){e.addEventListener(t,n.onCursorDown)}),$h.UP.forEach(function(t){e.addEventListener(t,n.onCursorUp)}))},removeWebXREventListeners:function(){var n=this,e=this.el.sceneEl.xrSession;e&&($h.DOWN.forEach(function(t){e.removeEventListener(t,n.onCursorDown)}),$h.UP.forEach(function(t){e.removeEventListener(t,n.onCursorUp)}))},onMouseMove:(es=new C.Vector3,Js=new C.Vector2,ts=new C.Vector3,Zx={origin:ts,direction:es},function(n){var e,t,i,r,s,o,a,l,c,h=this.canvasBounds,u=this.el.sceneEl.camera;u.parent.updateMatrixWorld(),t=(i=n.type==="touchmove"||n.type==="touchstart"?n.touches.item(0):n).clientX-h.left,r=i.clientY-h.top,Js.x=t/h.width*2-1,Js.y=-r/h.height*2+1,this.data.rayOrigin!=="xrselect"||n.type!=="selectstart"&&n.type!=="fakeselectevent"?n.type==="fakeselectout"?(es.set(0,1,0),ts.set(0,9999,0)):u&&u.isPerspectiveCamera?(ts.setFromMatrixPosition(u.matrixWorld),es.set(Js.x,Js.y,.5).unproject(u).sub(ts).normalize()):u&&u.isOrthographicCamera?(ts.set(Js.x,Js.y,(u.near+u.far)/(u.near-u.far)).unproject(u),es.set(0,0,-1).transformDirection(u.matrixWorld)):console.error("AFRAME.Raycaster: Unsupported camera type: "+u.type):(s=n.frame,o=n.inputSource,a=this.el.sceneEl.renderer.xr.getReferenceSpace(),(l=s.getPose(o.targetRaySpace,a))&&(c=l.transform,es.set(0,0,-1),es.applyQuaternion(c.orientation),ts.copy(c.position),(e=u.el.object3D.parent).localToWorld(ts),es.transformDirection(e.matrixWorld))),this.el.setAttribute("raycaster",Zx),n.type==="touchmove"&&n.preventDefault()}),onCursorDown:function(n){this.isCursorDown=!0,this.data.rayOrigin==="mouse"&&n.type==="touchstart"&&(this.onMouseMove(n),this.el.components.raycaster.checkIntersections(),n.preventDefault()),this.data.rayOrigin==="xrselect"&&n.type==="selectstart"&&(this.activeXRInput=n.inputSource,this.onMouseMove(n),this.el.components.raycaster.checkIntersections(),this.el.components.raycaster.intersectedEls.length&&this.el.sceneEl.components["ar-hit-test"]!==void 0&&this.el.sceneEl.getAttribute("ar-hit-test").enabled&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!1),this.reenableARHitTest=!0)),this.twoWayEmit("mousedown",n),this.cursorDownEl=this.intersectedEl},onCursorUp:function(n){if(this.isCursorDown&&(this.data.rayOrigin!=="xrselect"||this.activeXRInput===n.inputSource)){this.isCursorDown=!1;var e=this.data;this.twoWayEmit(ty,n),this.reenableARHitTest===!0&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!0),this.reenableARHitTest=void 0),this.cursorDownEl&&this.cursorDownEl!==this.intersectedEl&&(this.intersectedEventDetail.intersection=null,this.cursorDownEl.emit(ty,this.intersectedEventDetail)),e.fuse&&e.rayOrigin!=="mouse"&&e.rayOrigin!=="xrselect"||!this.intersectedEl||this.cursorDownEl!==this.intersectedEl||this.twoWayEmit(ey,n),e.rayOrigin==="xrselect"&&this.onMouseMove({type:"fakeselectout"}),this.activeXRInput=null,this.cursorDownEl=null,n.type==="touchend"&&n.preventDefault()}},onIntersection:function(n){var e,t,i,r,s=this.el;t=n.detail.els[0]===s?1:0,r=n.detail.intersections[t],(i=n.detail.els[t])&&this.intersectedEl!==i&&(this.intersectedEl&&(e=this.el.components.raycaster.getIntersection(this.intersectedEl))&&e.distance<=r.distance||(this.clearCurrentIntersection(!0),this.setIntersection(i,r)))},onIntersectionCleared:function(n){n.detail.clearedEls.indexOf(this.intersectedEl)!==-1&&this.clearCurrentIntersection()},onEnterVR:function(){var n=this.data.rayOrigin;this.clearCurrentIntersection(!0),n!=="xrselect"&&n!=="entity"||this.addWebXREventListeners()},setIntersection:function(n,e){var t=this.el,i=this.data,r=this;this.intersectedEl!==n&&(this.intersectedEl=n,t.addState(xm),n.addState(ym),this.twoWayEmit("mouseenter"),this.data.mouseCursorStylesEnabled&&this.data.rayOrigin==="mouse"&&this.el.sceneEl.canvas.classList.add(ny),i.fuseTimeout!==0&&i.fuse&&i.rayOrigin!=="xrselect"&&i.rayOrigin!=="mouse"&&(t.addState(Yh),this.twoWayEmit("fusing"),this.fuseTimeout=setTimeout(function(){t.removeState(Yh),r.twoWayEmit(ey)},i.fuseTimeout)))},clearCurrentIntersection:function(n){var e,t,i=this.el;this.intersectedEl&&(this.intersectedEl.removeState(ym),i.removeState(xm),i.removeState(Yh),this.twoWayEmit("mouseleave"),this.data.mouseCursorStylesEnabled&&this.data.rayOrigin==="mouse"&&this.el.sceneEl.canvas.classList.remove(ny),this.intersectedEl=null,clearTimeout(this.fuseTimeout),n!==!0&&(t=this.el.components.raycaster.intersections).length!==0&&(e=t[t[0].object.el===i?1:0])&&this.setIntersection(e.object.el,e))},twoWayEmit:function(n,e){var t,i=this.el,r=this.intersectedEl;function s(o,a){e instanceof MouseEvent?o.mouseEvent=e:typeof TouchEvent<"u"&&e instanceof TouchEvent&&(o.touchEvent=e)}t=this.el.components.raycaster.getIntersection(r),this.eventDetail.intersectedEl=r,this.eventDetail.intersection=t,s(this.eventDetail),i.emit(n,this.eventDetail),r&&(this.intersectedEventDetail.intersection=t,s(this.intersectedEventDetail),r.emit(n,this.intersectedEventDetail))}}),new C.BufferGeometry),iy=(tt("geometry",{schema:{buffer:{default:!0},primitive:{default:"box",oneOf:av,schemaChange:!0},skipCache:{default:!1}},init:function(){this.geometry=null},update:function(n){var e,t=this.data,i=this.el,r=this.system;this.geometry&&(r.unuseGeometry(n),this.geometry=null),this.geometry=r.getOrCreateGeometry(t),(e=i.getObject3D("mesh"))?e.geometry=this.geometry:((e=new C.Mesh).geometry=this.geometry,this.el.getAttribute("material")||(e.material=new C.MeshStandardMaterial({color:16777215*Math.random(),metalness:0,roughness:.5})),i.setObject3D("mesh",e))},remove:function(){this.system.unuseGeometry(this.data),this.el.getObject3D("mesh").geometry=sF,this.geometry=null},updateSchema:function(n){var e=this.oldData&&this.oldData.primitive,t=n.primitive,i=Ss[t]&&Ss[t].schema;if(!i)throw new Error("Unknown geometry schema `"+t+"`");e&&e===t||this.extendSchema(i)}}),"generic"),oF=(tt("generic-tracked-controller-controls",{schema:{hand:{default:""},defaultModel:{default:!0},defaultModelColor:{default:"gray"},disabled:{default:!1}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick"]},bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var n=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n)},this.onButtonUp=function(e){dt(e.detail.id,"up",n)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n)},this.controllerPresent=!1,this.wasControllerConnected=!1,this.bindMethods(),this.el.addEventListener("controllerconnected",function(e){e.detail.name!==n.name&&(n.wasControllerConnected=!0,n.removeEventListeners(),n.removeControllersUpdateListener())})},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.data,e=n.hand?n.hand:void 0;si(this,iy,{hand:e,iterateControllerProfiles:!0})},play:function(){this.wasControllerConnected||(this.checkIfControllerPresent(),this.addControllersUpdateListener())},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var n=this.el,e=this.data;this.el.components["tracked-controls"]?this.removeEventListeners():(n.setAttribute("tracked-controls",{hand:e.hand,idPrefix:iy,iterateControllerProfiles:!0}),this.data.defaultModel&&this.initDefaultModel())},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.wasControllerConnected&&this.checkIfControllerPresent()},onButtonChanged:function(n){var e=this.mapping.buttons[n.detail.id];e&&this.el.emit(e+"changed",n.detail.state)},onAxisMoved:function(n){vi(this,this.mapping.axes,n)},initDefaultModel:function(){var n=this.modelEl=document.createElement("a-entity");n.setAttribute("geometry",{primitive:"sphere",radius:.03}),n.setAttribute("material",{color:this.data.color}),this.el.appendChild(n),this.el.emit("controllermodelready",{name:"generic-tracked-controller-controls",model:this.modelEl,rayOrigin:{origin:{x:0,y:0,z:-.01},direction:{x:0,y:0,z:-1}}})}}),Bt("components:gltf-model:warn"));tt("gltf-model",{schema:{type:"model"},init:function(){var n=this,e=this.system.getDRACOLoader(),t=this.system.getMeshoptDecoder(),i=this.system.getKTX2Loader();this.model=null,this.loader=new G0,e&&this.loader.setDRACOLoader(e),this.ready=t?t.then(function(r){n.loader.setMeshoptDecoder(r)}):Promise.resolve(),i&&this.loader.setKTX2Loader(i)},update:function(){var n=this,e=this.el,t=this.data;t&&(this.remove(),this.ready.then(function(){n.loader.load(t,function(i){n.model=i.scene||i.scenes[0],n.model.animations=i.animations,e.setObject3D("mesh",n.model),e.emit("model-loaded",{format:"gltf",model:n.model})},void 0,function(i){var r=i&&i.message?i.message:"Failed to load glTF model";oF(r),e.emit("model-error",{format:"gltf",src:t})})}))},remove:function(){this.model&&this.el.removeObject3D("mesh")}}),tt("grabbable",{init:function(){this.el.setAttribute("obb-collider","centerModel: true")}});var Kh,aF=qt+"controllers/oculus-hands/v4/left.glb",lF=qt+"controllers/oculus-hands/v4/right.glb",_m=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];tt("hand-tracking-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},modelStyle:{default:"mesh",oneOf:["dots","mesh"]},modelColor:{default:"white"},modelOpacity:{default:1}},after:["tracked-controls"],bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this)},addEventListeners:function(){this.el.addEventListener("model-loaded",this.onModelLoaded);for(var n=0;n<this.jointEls.length;++n)this.jointEls[n].object3D.visible=!0},removeEventListeners:function(){this.el.removeEventListener("model-loaded",this.onModelLoaded);for(var n=0;n<this.jointEls.length;++n)this.jointEls[n].object3D.visible=!1},init:function(){var n=this.el.sceneEl,e=n.getAttribute("webxr"),t=e.optionalFeatures;t.indexOf("hand-tracking")===-1&&(t.push("hand-tracking"),n.setAttribute("webxr",e)),this.wristObject3D=new C.Object3D,this.el.sceneEl.object3D.add(this.wristObject3D),this.onModelLoaded=this.onModelLoaded.bind(this),this.onChildAttached=this.onChildAttached.bind(this),this.jointEls=[],this.controllerPresent=!1,this.isPinched=!1,this.pinchEventDetail={position:new C.Vector3,wristRotation:new C.Quaternion},this.indexTipPosition=new C.Vector3,this.hasPoses=!1,this.jointPoses=new Float32Array(16*_m.length),this.jointRadii=new Float32Array(_m.length),this.bindMethods(),this.updateReferenceSpace=this.updateReferenceSpace.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.updateReferenceSpace),this.el.sceneEl.addEventListener("exit-vr",this.updateReferenceSpace),this.el.addEventListener("child-attached",this.onChildAttached),this.wristObject3D.visible=!1},onChildAttached:function(n){this.addChildEntity(n.detail.el)},update:function(){this.updateModelMaterial()},updateModelMaterial:function(){var n=this.jointEls,e=this.skinnedMesh,t=this.data.modelOpacity!==1;e&&(this.skinnedMesh.material.color.set(this.data.modelColor),this.skinnedMesh.material.transparent=t,this.skinnedMesh.material.opacity=this.data.modelOpacity);for(var i=0;i<n.length;i++)n[i].setAttribute("material",{color:this.data.modelColor,transparent:t,opacity:this.data.modelOpacity})},updateReferenceSpace:function(){var n=this,e=this.el.sceneEl.xrSession;if(this.referenceSpace=void 0,e){var t=n.el.sceneEl.systems.webxr.sessionReferenceSpaceType;e.requestReferenceSpace(t).then(function(i){n.referenceSpace=i}).catch(function(i){throw n.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(t,"tracked-controls-webxr uses reference space "+t),i})}},checkIfControllerPresent:function(){var n=this.data;si(this,"",{hand:n.hand?n.hand:void 0,iterateControllerProfiles:!0,handTracking:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},tick:function(){var n=this.el.sceneEl,e=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,t=n.frame,i=this.el.components["tracked-controls"],r=this.referenceSpace;e&&t&&r&&i&&(this.hasPoses=!1,e.hand&&(this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),this.hasPoses=t.fillPoses(e.hand.values(),r,this.jointPoses)&&t.fillJointRadii(e.hand.values(),this.jointRadii),this.updateHandModel(),this.detectGesture(),this.updateWristObject()))},updateWristObject:(Kh=new C.Matrix4,function(){var n=this.wristObject3D;n&&this.hasPoses&&(Kh.fromArray(this.jointPoses,0),n.position.setFromMatrixPosition(Kh),n.quaternion.setFromRotationMatrix(Kh))}),updateHandModel:function(){this.wristObject3D.visible=!0,this.el.object3D.visible=!0,this.data.modelStyle==="dots"&&this.updateHandDotsModel(),this.data.modelStyle==="mesh"&&this.updateHandMeshModel()},getBone:function(n){for(var e=this.bones,t=0;t<e.length;t++)if(e[t].name===n)return e[t];return null},updateHandMeshModel:function(){var n=new C.Matrix4;return function(){var e=0,t=this.jointPoses,i=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller;if(i&&this.mesh&&(this.mesh.visible=!1,this.hasPoses))for(var r of i.hand.values()){var s=this.getBone(r.jointName);s!=null&&(this.mesh.visible=!0,n.fromArray(t,16*e),s.position.setFromMatrixPosition(n),s.quaternion.setFromRotationMatrix(n)),e++}}}(),updateHandDotsModel:function(){for(var n,e,t=this.jointPoses,i=this.jointRadii,r=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,s=0;s<r.hand.size;s++)e=(n=this.jointEls[s]).object3D,n.object3D.visible=this.hasPoses,this.hasPoses&&(e.matrix.fromArray(t,16*s),e.matrix.decompose(e.position,e.rotation,e.scale),n.setAttribute("scale",{x:i[s],y:i[s],z:i[s]}))},detectGesture:function(){this.detectPinch()},detectPinch:function(){var n=new C.Vector3,e=new C.Matrix4;return function(){var t=this.indexTipPosition,i=this.pinchEventDetail;if(this.hasPoses){n.setFromMatrixPosition(e.fromArray(this.jointPoses,64)),t.setFromMatrixPosition(e.fromArray(this.jointPoses,144)),i.wristRotation.setFromRotationMatrix(e.fromArray(this.jointPoses,0));var r=t.distanceTo(n);r<.015&&this.isPinched===!1&&(this.isPinched=!0,i.position.copy(t).add(n).multiplyScalar(.5),this.el.emit("pinchstarted",i)),r>.02&&this.isPinched===!0&&(this.isPinched=!1,i.position.copy(t).add(n).multiplyScalar(.5),this.el.emit("pinchended",i)),this.isPinched&&(i.position.copy(t).add(n).multiplyScalar(.5),this.el.emit("pinchmoved",i))}}}(),pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{id:"",hand:e.hand,iterateControllerProfiles:!0,handTrackingEnabled:!0}),this.mesh?this.mesh!==n.getObject3D("mesh")&&n.setObject3D("mesh",this.mesh):this.initDefaultModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){var n,e=this.el;this.checkIfControllerPresent(),n=e.components["tracked-controls"]&&e.components["tracked-controls"].controller,this.mesh&&n&&n.hand&&n.hand instanceof XRHand&&e.setObject3D("mesh",this.mesh)},initDefaultModel:function(){var n=this.data;n.modelStyle==="dots"&&this.initDotsModel(),n.modelStyle==="mesh"&&this.initMeshHandModel(),this.el.object3D.visible=!0,this.wristObject3D.visible=!0},initDotsModel:function(){if(this.jointEls.length===0){for(var n=0;n<_m.length;++n){var e=this.jointEl=document.createElement("a-entity");e.setAttribute("geometry",{primitive:"sphere",radius:1}),e.object3D.visible=!1,this.el.appendChild(e),this.jointEls.push(e)}this.updateModelMaterial()}},initMeshHandModel:function(){var n=this.data.hand==="left"?aF:lF;this.el.setAttribute("gltf-model",n)},onModelLoaded:function(){var n=this.mesh=this.el.getObject3D("mesh").children[0],e=this.skinnedMesh=n.getObjectByProperty("type","SkinnedMesh");this.skinnedMesh&&(this.bones=e.skeleton.bones,this.el.removeObject3D("mesh"),n.position.set(0,0,0),n.rotation.set(0,0,0),e.frustumCulled=!1,e.material=new C.MeshStandardMaterial,this.updateModelMaterial(),this.setupChildrenEntities(),this.el.setObject3D("mesh",n),this.el.emit("controllermodelready",{name:"hand-tracking-controls",model:this.data.model,rayOrigin:new C.Vector3(0,0,0)}))},setupChildrenEntities:function(){for(var n=this.el.children,e=0;e<n.length;++e)n[e]instanceof an&&this.addChildEntity(n[e])},addChildEntity:function(n){n instanceof an&&this.wristObject3D.add(n.object3D)}}),tt("hand-tracking-grab-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},color:{type:"color",default:"white"},hoverColor:{type:"color",default:"#538df1"},hoverEnabled:{default:!1}},init:function(){var n,e=this.el,t=this.data;n=t.hand==="right"?"components.hand-tracking-controls.bones.3":"components.hand-tracking-controls.bones.21",e.setAttribute("hand-tracking-controls",{hand:t.hand}),e.setAttribute("obb-collider",{trackedObject3D:n,size:.04}),this.auxMatrix=new C.Matrix4,this.onCollisionStarted=this.onCollisionStarted.bind(this),this.el.addEventListener("obbcollisionstarted",this.onCollisionStarted),this.onCollisionEnded=this.onCollisionEnded.bind(this),this.el.addEventListener("obbcollisionended",this.onCollisionEnded),this.onPinchStarted=this.onPinchStarted.bind(this),this.el.addEventListener("pinchstarted",this.onPinchStarted),this.onPinchEnded=this.onPinchEnded.bind(this),this.el.addEventListener("pinchended",this.onPinchEnded)},transferEntityOwnership:function(){for(var n,e=this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"),t=0;t<e.length;++t)(n=e[t].components["hand-tracking-grab-controls"])!==this&&this.grabbedEl&&this.grabbedEl===n.grabbedEl&&n.releaseGrabbedEntity();return!1},onCollisionStarted:function(n){var e=n.detail.withEl;this.collidedEl||e.getAttribute("grabbable")&&(this.collidedEl=e,this.grabbingObject3D=n.detail.trackedObject3D,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.hoverColor))},onCollisionEnded:function(){this.collidedEl=void 0,this.grabbedEl||(this.grabbingObject3D=void 0,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.color))},onPinchStarted:function(n){this.collidedEl&&(this.grabbedEl=this.collidedEl,this.transferEntityOwnership(),this.grab())},onPinchEnded:function(){this.releaseGrabbedEntity()},releaseGrabbedEntity:function(){var n=this.grabbedEl;if(n){var e=n.object3D,t=e.parent,i=this.originalParent;e.applyMatrix4(t.matrixWorld),e.applyMatrix4(this.auxMatrix.copy(i.matrixWorld).invert()),t.remove(e),i.add(e),this.el.emit("grabended",{grabbedEl:n}),this.grabbedEl=void 0,this.originalParent=void 0}},grab:function(){var n=this.grabbedEl,e=n.object3D,t=e.parent;this.originalParent=t;var i=this.el.components["hand-tracking-controls"].wristObject3D;e.applyMatrix4(t.matrixWorld),e.applyMatrix4(this.auxMatrix.copy(i.matrixWorld).invert()),t.remove(e),i.add(e),this.el.emit("grabstarted",{grabbedEl:n})}});var cF={toonLeft:qt+"controllers/hands/leftHand.glb",toonRight:qt+"controllers/hands/rightHand.glb",lowPolyLeft:qt+"controllers/hands/leftHandLow.glb",lowPolyRight:qt+"controllers/hands/rightHandLow.glb",highPolyLeft:qt+"controllers/hands/leftHandHigh.glb",highPolyRight:qt+"controllers/hands/rightHandHigh.glb"},bm="Point",Cm="Fist",ry="Thumb Up",Xu={};function sy(n,e){var t;if(n)return(t=Xu[n])==="grip"?t+(e?"close":"open"):t==="point"?t+(e?"up":"down"):t==="pointing"||t==="pistol"?t+(e?"start":"end"):void 0}Xu[Cm]="grip",Xu[ry]="pistol",Xu[bm]="pointing",tt("hand-controls",{schema:{color:{default:"white",type:"color"},hand:{default:"left"},handModelStyle:{default:"lowPoly",oneOf:["lowPoly","highPoly","toon"]}},after:["tracked-controls"],init:function(){var n=this,e=this.el;this.pressedButtons={},this.touchedButtons={},this.loader=new G0,this.loader.setCrossOrigin("anonymous"),this.onGripDown=function(){n.handleButton("grip","down")},this.onGripUp=function(){n.handleButton("grip","up")},this.onTrackpadDown=function(){n.handleButton("trackpad","down")},this.onTrackpadUp=function(){n.handleButton("trackpad","up")},this.onTrackpadTouchStart=function(){n.handleButton("trackpad","touchstart")},this.onTrackpadTouchEnd=function(){n.handleButton("trackpad","touchend")},this.onTriggerDown=function(){n.handleButton("trigger","down")},this.onTriggerUp=function(){n.handleButton("trigger","up")},this.onTriggerTouchStart=function(){n.handleButton("trigger","touchstart")},this.onTriggerTouchEnd=function(){n.handleButton("trigger","touchend")},this.onGripTouchStart=function(){n.handleButton("grip","touchstart")},this.onGripTouchEnd=function(){n.handleButton("grip","touchend")},this.onThumbstickDown=function(){n.handleButton("thumbstick","down")},this.onThumbstickUp=function(){n.handleButton("thumbstick","up")},this.onAorXTouchStart=function(){n.handleButton("AorX","touchstart")},this.onAorXTouchEnd=function(){n.handleButton("AorX","touchend")},this.onBorYTouchStart=function(){n.handleButton("BorY","touchstart")},this.onBorYTouchEnd=function(){n.handleButton("BorY","touchend")},this.onSurfaceTouchStart=function(){n.handleButton("surface","touchstart")},this.onSurfaceTouchEnd=function(){n.handleButton("surface","touchend")},this.onControllerConnected=this.onControllerConnected.bind(this),this.onControllerDisconnected=this.onControllerDisconnected.bind(this),e.addEventListener("controllerconnected",this.onControllerConnected),e.addEventListener("controllerdisconnected",this.onControllerDisconnected),e.object3D.visible=!1},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},tick:function(n,e){var t=this.el.getObject3D("mesh");t&&t.mixer&&t.mixer.update(e/1e3)},onControllerConnected:function(n){var e=this.el,t=this.data.hand,i=this.el.getObject3D("mesh");e.object3D.visible=!0;var r=t==="left"?Math.PI/2:-Math.PI/2,s=e.sceneEl.hasWebXR?-Math.PI/2:0;n.detail.name==="pico-controls"&&(s+=Math.PI/4),i.position.set(0,0,0),i.rotation.set(s,0,r)},onControllerDisconnected:function(){this.el.object3D.visible=!1},addEventListeners:function(){var n=this.el;n.addEventListener("gripdown",this.onGripDown),n.addEventListener("gripup",this.onGripUp),n.addEventListener("trackpaddown",this.onTrackpadDown),n.addEventListener("trackpadup",this.onTrackpadUp),n.addEventListener("trackpadtouchstart",this.onTrackpadTouchStart),n.addEventListener("trackpadtouchend",this.onTrackpadTouchEnd),n.addEventListener("triggerdown",this.onTriggerDown),n.addEventListener("triggerup",this.onTriggerUp),n.addEventListener("triggertouchstart",this.onTriggerTouchStart),n.addEventListener("triggertouchend",this.onTriggerTouchEnd),n.addEventListener("griptouchstart",this.onGripTouchStart),n.addEventListener("griptouchend",this.onGripTouchEnd),n.addEventListener("thumbstickdown",this.onThumbstickDown),n.addEventListener("thumbstickup",this.onThumbstickUp),n.addEventListener("abuttontouchstart",this.onAorXTouchStart),n.addEventListener("abuttontouchend",this.onAorXTouchEnd),n.addEventListener("bbuttontouchstart",this.onBorYTouchStart),n.addEventListener("bbuttontouchend",this.onBorYTouchEnd),n.addEventListener("xbuttontouchstart",this.onAorXTouchStart),n.addEventListener("xbuttontouchend",this.onAorXTouchEnd),n.addEventListener("ybuttontouchstart",this.onBorYTouchStart),n.addEventListener("ybuttontouchend",this.onBorYTouchEnd),n.addEventListener("surfacetouchstart",this.onSurfaceTouchStart),n.addEventListener("surfacetouchend",this.onSurfaceTouchEnd)},removeEventListeners:function(){var n=this.el;n.removeEventListener("gripdown",this.onGripDown),n.removeEventListener("gripup",this.onGripUp),n.removeEventListener("trackpaddown",this.onTrackpadDown),n.removeEventListener("trackpadup",this.onTrackpadUp),n.removeEventListener("trackpadtouchstart",this.onTrackpadTouchStart),n.removeEventListener("trackpadtouchend",this.onTrackpadTouchEnd),n.removeEventListener("triggerdown",this.onTriggerDown),n.removeEventListener("triggerup",this.onTriggerUp),n.removeEventListener("triggertouchstart",this.onTriggerTouchStart),n.removeEventListener("triggertouchend",this.onTriggerTouchEnd),n.removeEventListener("griptouchstart",this.onGripTouchStart),n.removeEventListener("griptouchend",this.onGripTouchEnd),n.removeEventListener("thumbstickdown",this.onThumbstickDown),n.removeEventListener("thumbstickup",this.onThumbstickUp),n.removeEventListener("abuttontouchstart",this.onAorXTouchStart),n.removeEventListener("abuttontouchend",this.onAorXTouchEnd),n.removeEventListener("bbuttontouchstart",this.onBorYTouchStart),n.removeEventListener("bbuttontouchend",this.onBorYTouchEnd),n.removeEventListener("xbuttontouchstart",this.onAorXTouchStart),n.removeEventListener("xbuttontouchend",this.onAorXTouchEnd),n.removeEventListener("ybuttontouchstart",this.onBorYTouchStart),n.removeEventListener("ybuttontouchend",this.onBorYTouchEnd),n.removeEventListener("surfacetouchstart",this.onSurfaceTouchStart),n.removeEventListener("surfacetouchend",this.onSurfaceTouchEnd)},update:function(n){var e,t=this.el,i=this.data.hand,r=this.data.handModelStyle,s=this.data.color,o=this;if(e={hand:i,model:!1},i!==n){var a=cF[r+i.charAt(0).toUpperCase()+i.slice(1)];this.loader.load(a,function(l){var c=l.scene.children[0];c.mixer=new C.AnimationMixer(c),o.clips=l.animations,t.setObject3D("mesh",c),c.traverse(function(h){h.isMesh&&(h.material.color=new C.Color(s))}),t.setAttribute("magicleap-controls",e),t.setAttribute("vive-controls",e),t.setAttribute("meta-touch-controls",e),t.setAttribute("pico-controls",e),t.setAttribute("windows-motion-controls",e),t.setAttribute("hp-mixed-reality-controls",e)})}},remove:function(){this.el.removeObject3D("mesh")},handleButton:function(n,e){var t,i=e==="down",r=e==="touchstart";if(e.indexOf("touch")===0){if(r===this.touchedButtons[n])return;this.touchedButtons[n]=r}else{if(i===this.pressedButtons[n])return;this.pressedButtons[n]=i}t=this.gesture,this.gesture=this.determineGesture(),this.gesture!==t&&(this.animateGesture(this.gesture,t),this.emitGestureEvents(this.gesture,t))},determineGesture:function(){var n,e,t,i=this.pressedButtons.grip,r=this.pressedButtons.surface||this.touchedButtons.surface,s=this.pressedButtons.trackpad||this.touchedButtons.trackpad,o=this.pressedButtons.trigger||this.touchedButtons.trigger,a=this.touchedButtons.AorX||this.touchedButtons.BorY;return e=this.el.components["tracked-controls"],(t=e&&e.controller)&&(t.id&&t.id.indexOf("OpenVR ")===0||t.profiles&&t.profiles[0]&&t.profiles[0]==="htc-vive")?i||o?n=Cm:s&&(n=bm):i?n=r||a||s?o?Cm:bm:o?ry:"Point + Thumb":o&&(n="Hold"),n},getClip:function(n){var e,t;for(t=0;t<this.clips.length;t++)if((e=this.clips[t]).name===n)return e},animateGesture:function(n,e){n?this.playAnimation(n||"Open",e,!1):this.playAnimation(e,e,!0)},emitGestureEvents:function(n,e){var t,i=this.el;e!==n&&((t=sy(e,!1))&&i.emit(t),(t=sy(n,!0))&&i.emit(t))},playAnimation:function(n,e,t){var i,r,s=this.el.getObject3D("mesh");if(s){if(i=this.getClip(n),r=s.mixer.clipAction(i),t)return r.paused=!1,void(r.timeScale=-1);if(r.clampWhenFinished=!0,r.loop=C.LoopOnce,r.repetitions=0,r.timeScale=1,r.time=0,r.weight=1,!e)return s.mixer.stopAllAction(),void r.play();i=this.getClip(e),r.reset(),r.play(),s.mixer.clipAction(i).crossFadeTo(r,.15,!0)}}}),tt("hide-on-enter-ar",{init:function(){var n=this;this.el.sceneEl.addEventListener("enter-vr",function(){n.el.sceneEl.is("ar-mode")&&(n.el.object3D.visible=!1)}),this.el.sceneEl.addEventListener("exit-vr",function(){n.el.object3D.visible=!0})}}),tt("hide-on-enter-vr",{init:function(){var n=this;this.el.sceneEl.addEventListener("enter-vr",function(){n.el.sceneEl.is("vr-mode")&&(n.el.object3D.visible=!1)}),this.el.sceneEl.addEventListener("exit-vr",function(){n.el.object3D.visible=!0})}});var oy="hp-mixed-reality",hF=qt+"controllers/hp/mixed-reality/",uF={x:0,y:0,z:.06},dF={_x:Math.PI/4,_y:0,_z:0,_order:"XYZ"},fF=(tt("hp-mixed-reality-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{left:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var n=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n,n.data.hand)},this.onButtonUp=function(e){dt(e.detail.id,"up",n,n.data.hand)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n,n.data.hand)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n,n.data.hand)},this.previousButtonValues={},this.bindMethods()},update:function(){var n=this.data;this.controllerIndex=n.hand==="right"?0:n.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),n.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),n.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.data;si(this,oy,{index:this.controllerIndex,hand:n.hand})},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{idPrefix:oy,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",hF+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e,t=this.mapping[this.data.hand].buttons[n.detail.id];t&&(t==="trigger"&&(e=n.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(t+"changed",n.detail.state))},onModelLoaded:function(n){var e=n.detail.model;this.data.model&&(e.position.copy(uF),e.rotation.copy(dF),this.el.emit("controllermodelready",{name:"hp-mixed-reality-controls",model:this.data.model,rayOrigin:new C.Vector3(0,0,0)}))},onAxisMoved:function(n){vi(this,this.mapping.axes,n)}}),Bt("components:layer:warn"));function ay(n,e,t){return(e.dot(n)-e.dot(t))/e.length()}tt("layer",{schema:{type:{default:"quad",oneOf:["quad","monocubemap","stereocubemap"]},src:{type:"map"},rotateCubemap:{default:!1},width:{default:0},height:{default:0}},init:function(){var n=this.el.sceneEl.renderer.getContext();this.quaternion=new C.Quaternion,this.position=new C.Vector3,this.bindMethods(),this.needsRedraw=!1,this.frameBuffer=n.createFramebuffer();var e=this.el.sceneEl.getAttribute("webxr"),t=e.requiredFeatures;t.indexOf("layers")===-1&&(t.push("layers"),this.el.sceneEl.setAttribute("webxr",e)),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR),this.el.sceneEl.addEventListener("exit-vr",this.onExitVR)},bindMethods:function(){this.onRequestedReferenceSpace=this.onRequestedReferenceSpace.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this)},update:function(n){this.data.src!==n.src&&this.updateSrc()},updateSrc:function(){var n=this.data.type;this.texture=void 0,n!=="quad"?n!=="monocubemap"&&n!=="stereocubemap"||this.loadCubeMapImages():this.loadQuadImage()},loadCubeMapImages:function(){var n,e=this.xrGLFactory,t=this.el.sceneEl.frame,i=this.data.src,r=this.data.type;this.visibilityChanged=!1,this.layer&&(r!=="monocubemap"&&r!=="stereocubemap"||(i.complete?this.pendingCubeMapUpdate=!1:this.pendingCubeMapUpdate=!0,this.loadingScreen?this.loadingScreen=!1:this.loadingScreen=!0,r==="monocubemap"?(n=e.getSubImage(this.layer,t),this.loadCubeMapImage(n.colorTexture,i,0)):(n=e.getSubImage(this.layer,t,"left"),this.loadCubeMapImage(n.colorTexture,i,0),n=e.getSubImage(this.layer,t,"right"),this.loadCubeMapImage(n.colorTexture,i,6))))},loadQuadImage:function(){var n=this.data.src,e=this;this.el.sceneEl.systems.material.loadTexture(n,{src:n},function(t){e.el.sceneEl.renderer.initTexture(t),e.texture=t,n.tagName==="VIDEO"&&setTimeout(function(){e.textureIsVideo=!0},1e3),e.layer&&(e.layer.height=e.data.height/2||e.texture.image.height/1e3,e.layer.width=e.data.width/2||e.texture.image.width/1e3,e.needsRedraw=!0),e.updateQuadPanel()})},preGenerateCubeMapTextures:function(n,e){this.data.type==="monocubemap"?this.generateCubeMapTextures(n,0,e):(this.generateCubeMapTextures(n,0,e),this.generateCubeMapTextures(n,6,e))},generateCubeMapTextures:function(n,e,t){for(var i,r,s=this.data,o=this.cubeFaceSize,a=Math.min(n.width,n.height),l=[],c=0;c<6;c++){var h=document.createElement("CANVAS");h.width=h.height=o;var u=h.getContext("2d");s.rotateCubemap&&(c!==2&&c!==3||(u.save(),u.translate(o,o),u.rotate(Math.PI))),u.drawImage(n,(c+e)*a,0,a,a,0,0,o,o),u.restore(),t&&t(),l.push(h)}return s.rotateCubemap&&(i=l[0],r=l[1],l[0]=r,l[1]=i,i=l[4],r=l[5],l[4]=r,l[5]=i),t&&t(),l},loadCubeMapImage:function(n,e,t){var i,r=this.el.sceneEl.renderer.getContext();r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,!1),r.bindTexture(r.TEXTURE_CUBE_MAP,n),i=!e.complete||this.loadingScreen?this.loadingScreenImages:this.generateCubeMapTextures(e,t);var s=0;i.forEach(function(o,a){r.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+a,0,0,0,r.RGBA,r.UNSIGNED_BYTE,o),s=r.getError()}),s!==0&&console.log("renderingError, WebGL Error Code: "+s),r.bindTexture(r.TEXTURE_CUBE_MAP,null)},tick:function(){this.el.sceneEl.xrSession&&this.referenceSpace&&(this.layer||!this.el.sceneEl.is("vr-mode")&&!this.el.sceneEl.is("ar-mode")||this.initLayer(),this.updateTransform(),this.data.src.complete&&(this.pendingCubeMapUpdate||this.loadingScreen||this.visibilityChanged)&&this.loadCubeMapImages(),(this.needsRedraw||this.layer.needsRedraw||this.textureIsVideo)&&(this.data.type==="quad"&&this.draw(),this.needsRedraw=!1))},initLayer:function(){var n=this,e=this.data.type;this.el.sceneEl.xrSession.onvisibilitychange=function(t){n.visibilityChanged=t.session.visibilityState!=="hidden"},e!=="quad"?e!=="monocubemap"&&e!=="stereocubemap"||this.initCubeMapLayer():this.initQuadLayer()},initQuadLayer:function(){var n=this.el.sceneEl,e=n.renderer.getContext(),t=this.xrGLFactory=new XRWebGLBinding(n.xrSession,e);this.texture&&(this.layer=t.createQuadLayer({space:this.referenceSpace,viewPixelHeight:2048,viewPixelWidth:2048,height:this.data.height/2||this.texture.image.height/1e3,width:this.data.width/2||this.texture.image.width/1e3}),this.initLoadingScreenImages(),n.renderer.xr.addLayer(this.layer))},initCubeMapLayer:function(){var n=this.data.src,e=this.el.sceneEl,t=e.renderer.getContext(),i=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),r=this.cubeFaceSize=Math.min(i,Math.min(n.width,n.height)),s=this.xrGLFactory=new XRWebGLBinding(e.xrSession,t);this.layer=s.createCubeLayer({space:this.referenceSpace,viewPixelWidth:r,viewPixelHeight:r,layout:this.data.type==="monocubemap"?"mono":"stereo",isStatic:!1}),this.initLoadingScreenImages(),this.loadCubeMapImages(),e.renderer.xr.addLayer(this.layer)},initLoadingScreenImages:function(){for(var n=this.cubeFaceSize,e=this.loadingScreenImages=[],t=0;t<6;t++){var i=document.createElement("CANVAS");i.width=i.height=n;var r=i.getContext("2d");i.width=i.height=n,r.fillStyle="black",r.fillRect(0,0,n,n),t!==2&&t!==3&&(r.translate(n,0),r.scale(-1,1),r.fillStyle="white",r.font="30px Arial",r.fillText("Loading",n/2,n/2)),e.push(i)}},destroyLayer:function(){this.layer&&(this.el.sceneEl.renderer.xr.removeLayer(this.layer),this.layer.destroy(),this.layer=void 0)},toggleCompositorLayer:function(){this.enableCompositorLayer(!this.layerEnabled)},enableCompositorLayer:function(n){this.layerEnabled=n,this.quadPanelEl.object3D.visible=!this.layerEnabled},updateQuadPanel:function(){var n=this.quadPanelEl;this.quadPanelEl||(n=this.quadPanelEl=document.createElement("a-entity"),this.el.appendChild(n)),n.setAttribute("material",{shader:"flat",src:this.data.src,transparent:!0}),n.setAttribute("geometry",{primitive:"plane",height:this.data.height||this.texture.image.height/1e3,width:this.data.width||this.texture.image.height/1e3})},draw:function(){var n=this.el.sceneEl,e=this.el.sceneEl.renderer.getContext(),t=this.xrGLFactory.getSubImage(this.layer,n.frame),i=n.renderer.properties.get(this.texture).__webglTexture,r=e.getParameter(e.FRAMEBUFFER_BINDING);e.viewport(t.viewport.x,t.viewport.y,t.viewport.width,t.viewport.height),e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t.colorTexture,0),function(s,o,a,l){var c=s.createFramebuffer(),h=a.viewport.x,u=a.viewport.y,d=a.viewport.x+a.viewport.width,f=a.viewport.y+a.viewport.height;l.tagName==="VIDEO"&&(s.bindTexture(s.TEXTURE_2D,o),s.texSubImage2D(s.TEXTURE_2D,0,0,0,l.width,l.height,s.RGB,s.UNSIGNED_BYTE,l)),s.bindFramebuffer(s.READ_FRAMEBUFFER,c),s.framebufferTexture2D(s.READ_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,o,0),s.readBuffer(s.COLOR_ATTACHMENT0),s.blitFramebuffer(0,0,l.width,l.height,h,u,d,f,s.COLOR_BUFFER_BIT,s.NEAREST),s.bindFramebuffer(s.READ_FRAMEBUFFER,null),s.deleteFramebuffer(c)}(e,i,t,this.data.src),e.bindFramebuffer(e.FRAMEBUFFER,r)},updateTransform:function(){var n=this.el,e=this.position,t=this.quaternion;n.object3D.updateMatrixWorld(),e.setFromMatrixPosition(n.object3D.matrixWorld),t.setFromRotationMatrix(n.object3D.matrixWorld),this.layerEnabled||e.set(0,0,1e8),this.layer.transform=new XRRigidTransform(e,t)},onEnterVR:function(){var n=this.el.sceneEl,e=n.xrSession;n.hasWebXR&&XRWebGLBinding&&e?(e.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace),this.layerEnabled=!0,this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!1),this.data.src.play&&this.data.src.play()):fF("The layer component requires WebXR and the layers API enabled")},onExitVR:function(){this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!0),this.destroyLayer()},onRequestedReferenceSpace:function(n){this.referenceSpace=n}}),tt("laser-controls",{schema:{hand:{default:"right"},model:{default:!0},defaultModelColor:{type:"color",default:"grey"}},init:function(){var n=this.config,e=this.data,t=this.el,i=this,r={hand:e.hand,model:e.model};function s(o){var a=n[o.detail.name];if(a){var l=qn({showLine:!0},a.raycaster||{});o.detail.rayOrigin&&(l.origin=o.detail.rayOrigin.origin,l.direction=o.detail.rayOrigin.direction,l.showLine=!0),o.detail.rayOrigin||!i.modelReady?t.setAttribute("raycaster",l):t.setAttribute("raycaster","showLine",!0),t.setAttribute("cursor",qn({fuse:!1},a.cursor))}}t.setAttribute("hp-mixed-reality-controls",r),t.setAttribute("magicleap-controls",r),t.setAttribute("oculus-go-controls",r),t.setAttribute("meta-touch-controls",r),t.setAttribute("pico-controls",r),t.setAttribute("valve-index-controls",r),t.setAttribute("vive-controls",r),t.setAttribute("vive-focus-controls",r),t.setAttribute("windows-motion-controls",r),t.setAttribute("generic-tracked-controller-controls",{hand:r.hand}),t.addEventListener("controllerconnected",s),t.addEventListener("controllerdisconnected",function(o){n[o.detail.name]&&t.setAttribute("raycaster","showLine",!1)}),t.addEventListener("controllermodelready",function(o){s(o),i.modelReady=!0})},config:{"generic-tracked-controller-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"hp-mixed-reality-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"magicleap-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"oculus-go-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:5e-4,z:0}}},"meta-touch-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"pico-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"valve-index-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-focus-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"windows-motion-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{showLine:!1}}}});var Mm,Jh,Zh,eu,hr,ly,Sm,Il,Rl,tu,cy=C.MathUtils.degToRad,pF=Bt("components:light:warn"),mF=new C.CubeTextureLoader,Zs={};function hy(n,e){return!(!n||!e)&&n.x===e.x&&n.y===e.y&&n.z===e.z}tt("light",{schema:{angle:{default:60,if:{type:["spot"]}},color:{type:"color",if:{type:["ambient","directional","hemisphere","point","spot"]}},envMap:{default:"",if:{type:["probe"]}},groundColor:{type:"color",if:{type:["hemisphere"]}},decay:{default:1,if:{type:["point","spot"]}},distance:{default:0,min:0,if:{type:["point","spot"]}},intensity:{default:3.14,min:0,if:{type:["ambient","directional","hemisphere","point","spot","probe"]}},penumbra:{default:0,min:0,max:1,if:{type:["spot"]}},type:{default:"directional",oneOf:["ambient","directional","hemisphere","point","spot","probe"],schemaChange:!0},target:{type:"selector",if:{type:["spot","directional"]}},castShadow:{default:!1,if:{type:["point","spot","directional"]}},shadowBias:{default:0,if:{castShadow:!0}},shadowCameraFar:{default:500,if:{castShadow:!0}},shadowCameraFov:{default:90,if:{castShadow:!0}},shadowCameraNear:{default:.5,if:{castShadow:!0}},shadowCameraTop:{default:5,if:{castShadow:!0}},shadowCameraRight:{default:5,if:{castShadow:!0}},shadowCameraBottom:{default:-5,if:{castShadow:!0}},shadowCameraLeft:{default:-5,if:{castShadow:!0}},shadowCameraVisible:{default:!1,if:{castShadow:!0}},shadowCameraAutomatic:{default:"",if:{type:["directional"]}},shadowMapHeight:{default:512,if:{castShadow:!0}},shadowMapWidth:{default:512,if:{castShadow:!0}},shadowRadius:{default:1,if:{castShadow:!0}}},init:function(){var n=this.el;this.light=null,this.defaultTarget=null,this.system.registerLight(n)},update:function(n){var e=this.data,t=mS(e,n),i=this.light,r=this;if(!i||"type"in t)this.setLight(this.data),this.updateShadow();else{var s=!1;Object.keys(t).forEach(function(o){var a=e[o];switch(o){case"color":i.color.set(a);break;case"groundColor":i.groundColor.set(a);break;case"angle":i.angle=cy(a);break;case"target":a===null?e.type!=="spot"&&e.type!=="directional"||(i.target=r.defaultTarget):a.hasLoaded?r.onSetTarget(a,i):a.addEventListener("loaded",r.onSetTarget.bind(r,a,i));break;case"envMap":r.updateProbeMap(e,i);break;case"castShadow":case"shadowBias":case"shadowCameraFar":case"shadowCameraFov":case"shadowCameraNear":case"shadowCameraTop":case"shadowCameraRight":case"shadowCameraBottom":case"shadowCameraLeft":case"shadowCameraVisible":case"shadowMapHeight":case"shadowMapWidth":case"shadowRadius":s||(r.updateShadow(),s=!0);break;case"shadowCameraAutomatic":e.shadowCameraAutomatic?r.shadowCameraAutomaticEls=Array.from(document.querySelectorAll(e.shadowCameraAutomatic)):r.shadowCameraAutomaticEls=[];break;default:i[o]=a}})}},tick:(Mm=new C.Box3,Jh=new C.Vector3,Zh=new C.Vector3,eu=new C.Matrix4,hr=new C.Sphere,ly=new C.Vector3,function(){if(this.data.type==="directional"&&this.light.shadow&&this.light.shadow.camera instanceof C.OrthographicCamera&&this.shadowCameraAutomaticEls.length){var n=this.light.shadow.camera;n.getWorldDirection(Jh),n.getWorldPosition(Zh),eu.copy(n.matrixWorld),eu.invert(),n.near=1,n.left=1e5,n.right=-1e5,n.top=-1e5,n.bottom=1e5,this.shadowCameraAutomaticEls.forEach(function(e){Mm.setFromObject(e.object3D),Mm.getBoundingSphere(hr);var t,i,r,s,o,a=ay(Zh,Jh,hr.center),l=(t=Zh,i=Jh,r=hr.center,s=ly,o=ay(t,i,r),s.copy(i),s.multiplyScalar(o),s.add(r),s).applyMatrix4(eu);n.near=Math.min(-a-hr.radius-1,n.near),n.left=Math.min(-hr.radius+l.x,n.left),n.right=Math.max(hr.radius+l.x,n.right),n.top=Math.max(hr.radius+l.y,n.top),n.bottom=Math.min(-hr.radius+l.y,n.bottom)}),n.updateProjectionMatrix()}}),setLight:function(n){var e=this.el,t=this.getLight(n);t&&(this.light&&e.removeObject3D("light"),this.light=t,this.light.el=e,e.setObject3D("light",this.light),n.type!=="spot"&&n.type!=="directional"&&n.type!=="hemisphere"||e.getObject3D("light").translateY(-1),n.type==="spot"&&(e.setObject3D("light-target",this.defaultTarget),e.getObject3D("light-target").position.set(0,0,-1)),n.shadowCameraAutomatic?this.shadowCameraAutomaticEls=Array.from(document.querySelectorAll(n.shadowCameraAutomatic)):this.shadowCameraAutomaticEls=[])},updateShadow:function(){var n=this.el,e=this.data,t=this.light;t.castShadow=e.castShadow;var i=n.getObject3D("cameraHelper");if(e.shadowCameraVisible&&!i?(i=new C.CameraHelper(t.shadow.camera),n.setObject3D("cameraHelper",i)):!e.shadowCameraVisible&&i&&n.removeObject3D("cameraHelper"),!e.castShadow)return t;t.shadow.bias=e.shadowBias,t.shadow.radius=e.shadowRadius,t.shadow.mapSize.height=e.shadowMapHeight,t.shadow.mapSize.width=e.shadowMapWidth,t.shadow.camera.near=e.shadowCameraNear,t.shadow.camera.far=e.shadowCameraFar,t.shadow.camera instanceof C.OrthographicCamera?(t.shadow.camera.top=e.shadowCameraTop,t.shadow.camera.right=e.shadowCameraRight,t.shadow.camera.bottom=e.shadowCameraBottom,t.shadow.camera.left=e.shadowCameraLeft):t.shadow.camera.fov=e.shadowCameraFov,t.shadow.camera.updateProjectionMatrix(),i&&i.update()},getLight:function(n){var e=n.angle,t=new C.Color(n.color);t=t.getHex();var i=n.decay,r=n.distance,s=new C.Color(n.groundColor);s=s.getHex();var o=n.intensity,a=n.type,l=n.target,c=null;switch(a.toLowerCase()){case"ambient":return new C.AmbientLight(t,o);case"directional":return c=new C.DirectionalLight(t,o),this.defaultTarget=c.target,l&&(l.hasLoaded?this.onSetTarget(l,c):l.addEventListener("loaded",this.onSetTarget.bind(this,l,c))),c;case"hemisphere":return new C.HemisphereLight(t,s,o);case"point":return new C.PointLight(t,o,r,i);case"spot":return c=new C.SpotLight(t,o,r,cy(e),n.penumbra,i),this.defaultTarget=c.target,l&&(l.hasLoaded?this.onSetTarget(l,c):l.addEventListener("loaded",this.onSetTarget.bind(this,l,c))),c;case"probe":return c=new C.LightProbe,this.updateProbeMap(n,c),c;default:pF("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.",a)}},updateProbeMap:function(n,e){n.envMap?(Zs[n.envMap]===void 0&&(Zs[n.envMap]=new window.Promise(function(t){cS(n.envMap,function(i){mF.load(i,function(r){var s=KM.fromCubeTexture(r);Zs[n.envMap]=s,t(s)})})})),Zs[n.envMap]instanceof window.Promise?Zs[n.envMap].then(function(t){e.copy(t)}):Zs[n.envMap]instanceof C.LightProbe&&e.copy(Zs[n.envMap])):e.copy(new C.LightProbe)},onSetTarget:function(n,e){e.target=n.object3D},remove:function(){var n=this.el;n.removeObject3D("light"),n.getObject3D("cameraHelper")&&n.removeObject3D("cameraHelper")}}),tt("line",{schema:{start:{type:"vec3",default:{x:0,y:0,z:0}},end:{type:"vec3",default:{x:0,y:0,z:0}},color:{type:"color",default:"#74BEC1"},opacity:{type:"number",default:1},visible:{default:!0}},multiple:!0,init:function(){var n,e,t=this.data;e=this.material=new C.LineBasicMaterial({color:t.color,opacity:t.opacity,transparent:t.opacity<1,visible:t.visible}),(n=this.geometry=new C.BufferGeometry).setAttribute("position",new C.BufferAttribute(new Float32Array(6),3)),this.line=new C.Line(n,e),this.el.setObject3D(this.attrName,this.line)},update:function(n){var e=this.data,t=this.geometry,i=!1,r=this.material,s=t.attributes.position.array;hy(e.start,n.start)||(s[0]=e.start.x,s[1]=e.start.y,s[2]=e.start.z,i=!0),hy(e.end,n.end)||(s[3]=e.end.x,s[4]=e.end.y,s[5]=e.end.z,i=!0),i&&(t.attributes.position.needsUpdate=!0,t.computeBoundingSphere()),r.color.setStyle(e.color),r.opacity=e.opacity,r.transparent=e.opacity<1,r.visible=e.visible},remove:function(){this.el.removeObject3D(this.attrName,this.line)}}),tt("link",{schema:{backgroundColor:{default:"red",type:"color"},borderColor:{default:"white",type:"color"},highlighted:{default:!1},highlightedColor:{default:"#24CAFF",type:"color"},href:{default:""},image:{type:"asset"},on:{default:"click"},peekMode:{default:!1},title:{default:""},titleColor:{default:"white",type:"color"},visualAspectEnabled:{default:!1}},init:function(){this.navigate=this.navigate.bind(this),this.previousQuaternion=void 0,this.quaternionClone=new C.Quaternion,this.hiddenEls=[]},update:function(n){var e,t,i=this.data,r=this.el;if(i.visualAspectEnabled){var s=this.el.getAttribute("scale");this.previewDistance=15*(s.x+s.y)/2,this.initVisualAspect(),e=i.highlighted?i.highlightedColor:i.backgroundColor,t=i.highlighted?i.highlightedColor:i.borderColor,r.setAttribute("material","backgroundColor",e),r.setAttribute("material","strokeColor",t),i.on!==n.on&&this.updateEventListener(),n.peekMode!==void 0&&i.peekMode!==n.peekMode&&this.updatePeekMode(),i.image&&n.image!==i.image&&r.setAttribute("material","pano",typeof i.image=="string"?i.image:i.image.src)}},updatePeekMode:function(){var n=this.el,e=this.sphereEl;this.data.peekMode?(this.hideAll(),n.getObject3D("mesh").visible=!1,e.setAttribute("visible",!0)):(this.showAll(),n.getObject3D("mesh").visible=!0,e.setAttribute("visible",!1))},play:function(){this.updateEventListener()},pause:function(){this.removeEventListener()},updateEventListener:function(){var n=this.el;n.isPlaying&&(this.removeEventListener(),n.addEventListener(this.data.on,this.navigate))},removeEventListener:function(){var n=this.data.on;n&&this.el.removeEventListener(n,this.navigate)},initVisualAspect:function(){var n,e,t,i=this.el;this.data.visualAspectEnabled&&!this.visualAspectInitialized&&(t=this.textEl=this.textEl||document.createElement("a-entity"),e=this.sphereEl=this.sphereEl||document.createElement("a-entity"),n=this.semiSphereEl=this.semiSphereEl||document.createElement("a-entity"),i.setAttribute("geometry",{primitive:"circle",radius:1,segments:64}),i.setAttribute("material",{shader:"portal",pano:this.data.image,side:"double",previewDistance:this.previewDistance}),t.setAttribute("text",{color:this.data.titleColor,align:"center",font:"kelsonsans",value:this.data.title||this.data.href,width:4}),t.setAttribute("position","0 1.5 0"),i.appendChild(t),n.setAttribute("geometry",{primitive:"sphere",radius:1,phiStart:0,segmentsWidth:64,segmentsHeight:64,phiLength:180,thetaStart:0,thetaLength:360}),n.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back",previewDistance:this.previewDistance}),n.setAttribute("rotation","0 180 0"),n.setAttribute("position","0 0 0"),n.setAttribute("visible",!1),i.appendChild(n),e.setAttribute("geometry",{primitive:"sphere",radius:10,segmentsWidth:64,segmentsHeight:64}),e.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back",previewDistance:this.previewDistance}),e.setAttribute("visible",!1),i.appendChild(e),this.visualAspectInitialized=!0)},navigate:function(){window.location=this.data.href},tick:function(){var n=new C.Vector3,e=new C.Vector3,t=new C.Quaternion,i=new C.Vector3;return function(){var r,s,o=this.el,a=o.object3D,l=o.sceneEl.camera,c=this.textEl;if(this.data.visualAspectEnabled)if(a.updateMatrixWorld(),l.parent.updateMatrixWorld(),l.updateMatrixWorld(),a.matrix.decompose(e,t,i),e.setFromMatrixPosition(a.matrixWorld),n.setFromMatrixPosition(l.matrixWorld),(s=e.distanceTo(n))>1.33333*this.previewDistance)this.previousQuaternion||(this.quaternionClone.copy(t),this.previousQuaternion=this.quaternionClone),a.lookAt(n);else{if(r=this.calculateCameraPortalOrientation(),s<.5){if(this.semiSphereEl.getAttribute("visible")===!0)return;c.setAttribute("text","width",1.5),r<=0?(c.setAttribute("position","0 0 0.75"),c.setAttribute("rotation","0 180 0"),this.semiSphereEl.setAttribute("rotation","0 0 0")):(c.setAttribute("position","0 0 -0.75"),c.setAttribute("rotation","0 0 0"),this.semiSphereEl.setAttribute("rotation","0 180 0")),o.getObject3D("mesh").visible=!1,this.semiSphereEl.setAttribute("visible",!0),this.peekCameraPortalOrientation=r}else r<=0?c.setAttribute("rotation","0 180 0"):c.setAttribute("rotation","0 0 0"),c.setAttribute("text","width",5),c.setAttribute("position","0 1.5 0"),o.getObject3D("mesh").visible=!0,this.semiSphereEl.setAttribute("visible",!1),this.peekCameraPortalOrientation=void 0;this.previousQuaternion&&(a.quaternion.copy(this.previousQuaternion),this.previousQuaternion=void 0)}}}(),hideAll:function(){var n=this.el,e=this.hiddenEls,t=this;e.length>0||n.sceneEl.object3D.traverse(function(i){i&&i.el&&i.el.hasAttribute("link-controls")||i.el&&i!==n.sceneEl.object3D&&i.el!==n&&i.el!==t.sphereEl&&i.el!==n.sceneEl.cameraEl&&i.el.getAttribute("visible")!==!1&&i.el!==t.textEl&&i.el!==t.semiSphereEl&&(i.el.setAttribute("visible",!1),e.push(i.el))})},showAll:function(){this.hiddenEls.forEach(function(n){n.setAttribute("visible",!0)}),this.hiddenEls=[]},calculateCameraPortalOrientation:(Sm=new C.Matrix4,Il=new C.Vector3,Rl=new C.Vector3(0,0,1),tu=new C.Vector3(0,0,0),function(){var n=this.el,e=n.sceneEl.camera;return Il.set(0,0,0),Rl.set(0,0,1),tu.set(0,0,0),n.object3D.matrixWorld.extractRotation(Sm),Rl.applyMatrix4(Sm),n.object3D.updateMatrixWorld(),n.object3D.localToWorld(tu),e.parent.parent.updateMatrixWorld(),e.parent.updateMatrixWorld(),e.updateMatrixWorld(),e.localToWorld(Il),Il.sub(tu).normalize(),Rl.normalize(),Math.sign(Rl.dot(Il))}),remove:function(){this.removeEventListener()}}),hs("portal",{schema:{borderEnabled:{default:1,type:"int",is:"uniform"},backgroundColor:{default:"red",type:"color",is:"uniform"},pano:{type:"map",is:"uniform"},strokeColor:{default:"white",type:"color",is:"uniform"},previewDistance:{default:15,type:"float",is:"uniform"}},vertexShader:["vec3 portalPosition;","varying vec3 vWorldPosition;","varying float vDistanceToCenter;","varying float vDistance;","void main() {","vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);","portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;","vDistance = length(portalPosition - cameraPosition);","vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join(`
`),fragmentShader:["#define RECIPROCAL_PI2 0.15915494","uniform sampler2D pano;","uniform vec3 strokeColor;","uniform vec3 backgroundColor;","uniform float borderEnabled;","uniform float previewDistance;","varying float vDistanceToCenter;","varying float vDistance;","varying vec3 vWorldPosition;","void main() {","vec3 direction = normalize(vWorldPosition - cameraPosition);","vec2 sampleUV;","float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);","sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);","sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;","if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {","gl_FragColor = vec4(strokeColor, 1.0);","} else {","gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / previewDistance), 2.0), 0.0, 1.0));","}","}"].join(`
`)});var uy="logitech-mx-ink",AF=qt+"controllers/logitech/",dy=(tt("logitech-mx-ink-controls",{schema:{hand:{default:"left"},model:{default:!0},orientationOffset:{type:"vec3"}},mapping:{left:{buttons:["front","back","none","none","none","tip"]},right:{buttons:["front","back","none","none","none","tip"]}},init:function(){var n=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n,n.data.hand)},this.onButtonUp=function(e){dt(e.detail.id,"up",n,n.data.hand)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n,n.data.hand)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n,n.data.hand)},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),n.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),n.removeEventListener("model-loaded",this.onModelLoaded),n.sceneEl.removeEventListener("enter-vr",this.onEnterVR),n.sceneEl.removeEventListener("exit-vr",this.onExitVR),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.controllerObject3D;n&&(n.visible=!1),si(this,uy,{hand:this.data.hand,iterateControllerProfiles:!0})},injectTrackedControls:function(){var n=this.el,e=this.data,t=uy;n.setAttribute("tracked-controls",{id:t,hand:e.hand,handTrackingEnabled:!1,iterateControllerProfiles:!0,orientationOffset:e.orientationOffset}),this.loadModel()},loadModel:function(){var n=this.controllerObject3D;if(this.data.model)return n?(n.visible=this.el.sceneEl.is("vr-mode"),void this.el.setObject3D("mesh",n)):void this.el.setAttribute("gltf-model",AF+"logitech-mx-ink.glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e,t=this.mapping[this.data.hand].buttons[n.detail.id];t&&(t==="trigger"&&(e=n.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(t+"changed",n.detail.state))},onModelLoaded:function(n){n.target===this.el&&this.data.model&&(this.el.emit("controllermodelready",{name:"logitech-mx-ink-controls",model:this.data.model,rayOrigin:new C.Vector3(0,0,0)}),this.controllerObject3D=this.el.getObject3D("mesh"),this.controllerObject3D.visible=this.el.sceneEl.is("vr-mode"))},onAxisMoved:function(n){vi(this,this.mapping.axes,n)}}),Math.PI/2),fy=(tt("look-controls",{dependencies:["position","rotation"],schema:{enabled:{default:!0},magicWindowTrackingEnabled:{default:!0},pointerLockEnabled:{default:!1},reverseMouseDrag:{default:!1},reverseTouchDrag:{default:!1},touchEnabled:{default:!0},mouseEnabled:{default:!0}},init:function(){this.deltaYaw=0,this.previousHMDPosition=new C.Vector3,this.hmdQuaternion=new C.Quaternion,this.magicWindowAbsoluteEuler=new C.Euler,this.magicWindowDeltaEuler=new C.Euler,this.position=new C.Vector3,this.magicWindowObject=new C.Object3D,this.rotation={},this.deltaRotation={},this.savedPose=null,this.pointerLocked=!1,this.setupMouseControls(),this.bindMethods(),this.previousMouseEvent={},this.setupMagicWindowControls(),this.savedPose={position:new C.Vector3,rotation:new C.Euler},(this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode"))&&this.onEnterVR()},setupMagicWindowControls:function(){var n,e=this.data;(Ms()||Q0())&&(n=this.magicWindowControls=new JM(this.magicWindowObject),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission&&(n.enabled=!1,this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted?n.enabled=e.magicWindowTrackingEnabled:this.el.sceneEl.addEventListener("deviceorientationpermissiongranted",function(){n.enabled=e.magicWindowTrackingEnabled})))},update:function(n){var e=this.data;e.enabled!==n.enabled&&this.updateGrabCursor(e.enabled),n&&!e.magicWindowTrackingEnabled&&n.magicWindowTrackingEnabled&&(this.magicWindowAbsoluteEuler.set(0,0,0),this.magicWindowDeltaEuler.set(0,0,0)),this.magicWindowControls&&(this.magicWindowControls.enabled=e.magicWindowTrackingEnabled),n&&!e.pointerLockEnabled!==n.pointerLockEnabled&&(this.removeEventListeners(),this.addEventListeners(),this.pointerLocked&&this.exitPointerLock())},tick:function(n){this.data.enabled&&this.updateOrientation()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},remove:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},bindMethods:function(){this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this),this.onPointerLockChange=this.onPointerLockChange.bind(this),this.onPointerLockError=this.onPointerLockError.bind(this)},setupMouseControls:function(){this.mouseDown=!1,this.pitchObject=new C.Object3D,this.yawObject=new C.Object3D,this.yawObject.position.y=10,this.yawObject.add(this.pitchObject)},addEventListeners:function(){var n=this.el.sceneEl,e=n.canvas;e?(e.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),e.addEventListener("touchstart",this.onTouchStart,{passive:!0}),window.addEventListener("touchmove",this.onTouchMove,{passive:!0}),window.addEventListener("touchend",this.onTouchEnd,{passive:!0}),n.addEventListener("enter-vr",this.onEnterVR),n.addEventListener("exit-vr",this.onExitVR),this.data.pointerLockEnabled&&(document.addEventListener("pointerlockchange",this.onPointerLockChange,!1),document.addEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.addEventListener("pointerlockerror",this.onPointerLockError,!1))):n.addEventListener("render-target-loaded",this.addEventListeners.bind(this))},removeEventListeners:function(){var n=this.el.sceneEl,e=n&&n.canvas;e&&(e.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),e.removeEventListener("touchstart",this.onTouchStart),window.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("touchend",this.onTouchEnd),n.removeEventListener("enter-vr",this.onEnterVR),n.removeEventListener("exit-vr",this.onExitVR),document.removeEventListener("pointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("pointerlockerror",this.onPointerLockError,!1))},updateOrientation:function(){var n=this.el.object3D,e=this.pitchObject,t=this.yawObject,i=this.el.sceneEl;(i.is("vr-mode")||i.is("ar-mode"))&&i.checkHeadsetConnected()||(this.updateMagicWindowOrientation(),n.rotation.x=this.magicWindowDeltaEuler.x+e.rotation.x,n.rotation.y=this.magicWindowDeltaEuler.y+t.rotation.y,n.rotation.z=this.magicWindowDeltaEuler.z)},updateMagicWindowOrientation:function(){var n=this.magicWindowAbsoluteEuler,e=this.magicWindowDeltaEuler;this.magicWindowControls&&this.magicWindowControls.enabled&&(this.magicWindowControls.update(),n.setFromQuaternion(this.magicWindowObject.quaternion,"YXZ"),this.previousMagicWindowYaw||n.y===0||(this.previousMagicWindowYaw=n.y),this.previousMagicWindowYaw&&(e.x=n.x,e.y+=n.y-this.previousMagicWindowYaw,e.z=n.z,this.previousMagicWindowYaw=n.y))},onMouseMove:function(n){var e,t,i,r=this.pitchObject,s=this.previousMouseEvent,o=this.yawObject;this.data.enabled&&(this.mouseDown||this.pointerLocked)&&(this.pointerLocked?(t=n.movementX||n.mozMovementX||0,i=n.movementY||n.mozMovementY||0):(t=n.screenX-s.screenX,i=n.screenY-s.screenY),this.previousMouseEvent.screenX=n.screenX,this.previousMouseEvent.screenY=n.screenY,e=this.data.reverseMouseDrag?1:-1,o.rotation.y+=.002*t*e,r.rotation.x+=.002*i*e,r.rotation.x=Math.max(-dy,Math.min(dy,r.rotation.x)))},onMouseDown:function(n){var e=this.el.sceneEl;if(this.data.enabled&&this.data.mouseEnabled&&(!e.is("vr-mode")&&!e.is("ar-mode")||!e.checkHeadsetConnected())&&n.button===0){var t=e&&e.canvas;this.mouseDown=!0,this.previousMouseEvent.screenX=n.screenX,this.previousMouseEvent.screenY=n.screenY,this.showGrabbingCursor(),this.data.pointerLockEnabled&&!this.pointerLocked&&(t.requestPointerLock?t.requestPointerLock():t.mozRequestPointerLock&&t.mozRequestPointerLock())}},showGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor="grabbing"},hideGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor=""},onMouseUp:function(){this.mouseDown=!1,this.hideGrabbingCursor()},onTouchStart:function(n){n.touches.length!==1||!this.data.touchEnabled||this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode")||(this.touchStart={x:n.touches[0].pageX,y:n.touches[0].pageY},this.touchStarted=!0)},onTouchMove:function(n){var e,t,i=this.el.sceneEl.canvas,r=this.yawObject;this.touchStarted&&this.data.touchEnabled&&(t=2*Math.PI*(n.touches[0].pageX-this.touchStart.x)/i.clientWidth,e=this.data.reverseTouchDrag?1:-1,r.rotation.y-=.5*t*e,this.touchStart={x:n.touches[0].pageX,y:n.touches[0].pageY})},onTouchEnd:function(){this.touchStarted=!1},onEnterVR:function(){var n=this.el.sceneEl;n.checkHeadsetConnected()&&(this.saveCameraPose(),this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),n.hasWebXR&&(this.el.object3D.matrixAutoUpdate=!1,this.el.object3D.updateMatrix()))},onExitVR:function(){this.el.sceneEl.checkHeadsetConnected()&&(this.restoreCameraPose(),this.previousHMDPosition.set(0,0,0),this.el.object3D.matrixAutoUpdate=!0)},onPointerLockChange:function(){this.pointerLocked=!(!document.pointerLockElement&&!document.mozPointerLockElement)},onPointerLockError:function(){this.pointerLocked=!1},exitPointerLock:function(){document.exitPointerLock(),this.pointerLocked=!1},updateGrabCursor:function(n){var e=this.el.sceneEl;function t(){e.canvas.classList.add("a-grab-cursor")}function i(){e.canvas.classList.remove("a-grab-cursor")}e.canvas?n?t():i():n?e.addEventListener("render-target-loaded",t):e.addEventListener("render-target-loaded",i)},saveCameraPose:function(){var n=this.el;this.savedPose.position.copy(n.object3D.position),this.savedPose.rotation.copy(n.object3D.rotation),this.hasSavedPose=!0},restoreCameraPose:function(){var n=this.el,e=this.savedPose;this.hasSavedPose&&(n.object3D.position.copy(e.position),n.object3D.rotation.copy(e.rotation),this.hasSavedPose=!1)}}),"magicleap-one"),gF=qt+"controllers/magicleap/magicleap-one-controller.glb",vF=(tt("magicleap-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","menu"]},init:function(){var n=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n)},this.onButtonUp=function(e){dt(e.detail.id,"up",n)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n)},this.previousButtonValues={},this.bindMethods()},update:function(){var n=this.data;this.controllerIndex=n.hand==="right"?0:n.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),n.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),n.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.data;si(this,fy,{index:this.controllerIndex,hand:n.hand})},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{idPrefix:fy,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",gF)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e,t=this.mapping.buttons[n.detail.id];t&&(t==="trigger"&&(e=n.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(t+"changed",n.detail.state))},onModelLoaded:function(n){n.detail.model.scale.set(.01,.01,.01)},onAxisMoved:function(n){vi(this,this.mapping.axes,n)},updateModel:function(n,e){},setButtonColor:function(n,e){}}),Bt("components:material:error"));function py(n,e){n.dispose(),e.unregisterMaterial(n),Object.keys(n).filter(function(t){return n[t]&&n[t].isTexture}).forEach(function(t){n[t].dispose()})}tt("material",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:TS,schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColorsEnabled:{default:!1},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]},dithering:{default:!0},anisotropy:{default:0,min:0}},init:function(){this.material=null},update:function(n){var e=this.data;this.shader&&e.shader===n.shader||this.updateShader(e.shader),this.shader.update(this.data),this.updateMaterial(n)},updateSchema:function(n){var e,t,i,r;t=n&&n.shader,e=this.oldData&&this.oldData.shader,(i=ji[r=t||e]&&ji[r].schema)||vF("Unknown shader schema "+r),e&&t===e||(this.extendSchema(i),this.updateBehavior())},updateBehavior:function(){var n,e,t=this.el.sceneEl,i=this.schema,r=this;function s(o,a){var l;for(l in e)e[l]=o;r.shader.update(e)}for(n in this.tick=void 0,e={},i)i[n].type==="time"&&(this.tick=s,e[n]=!0);t&&(this.tick?t.addBehavior(this):t.removeBehavior(this))},updateShader:function(n){var e,t=this.data,i=ji[n]&&ji[n].Shader;if(!i)throw new Error("Unknown shader "+n);(e=this.shader=new i).el=this.el,e.init(t),this.setMaterial(e.material),this.updateSchema(t)},updateMaterial:function(n){var e,t=this.data,i=this.material;for(e in i.alphaTest=t.alphaTest,i.depthTest=t.depthTest!==!1,i.depthWrite=t.depthWrite!==!1,i.opacity=t.opacity,i.flatShading=t.flatShading,i.side=function(r){switch(r){case"back":return C.BackSide;case"double":return C.DoubleSide;default:return C.FrontSide}}(t.side),i.transparent=t.transparent!==!1||t.opacity<1,i.vertexColors=t.vertexColorsEnabled,i.visible=t.visible,i.blending=function(r){switch(r){case"none":return C.NoBlending;case"additive":return C.AdditiveBlending;case"subtractive":return C.SubtractiveBlending;case"multiply":return C.MultiplyBlending;default:return C.NormalBlending}}(t.blending),i.dithering=t.dithering,n)break;!e||n.alphaTest===t.alphaTest&&n.side===t.side&&n.vertexColorsEnabled===t.vertexColorsEnabled||(i.needsUpdate=!0)},remove:function(){var n=new C.MeshBasicMaterial,e=this.material,t=this.el.getObject3D("mesh");t&&(t.material=n),py(e,this.system)},setMaterial:function(n){var e,t=this.el,i=this.system;this.material&&py(this.material,i),this.material=n,i.registerMaterial(n),(e=t.getObject3D("mesh"))?e.material=n:t.addEventListener("object3dset",function r(s){s.detail.type==="mesh"&&s.target===t&&(t.getObject3D("mesh").material=n,t.removeEventListener("object3dset",r))})}});var nu,iu,wm,my,Tm,Ay="oculus-touch",Na=qt+"controllers/oculus/oculus-touch-controller-",ru=qt+"controllers/meta/",EF={left:{modelUrl:Na+"left.gltf",rayOrigin:{origin:{x:.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new C.Vector3(-.005,.036,-.037),modelPivotRotation:new C.Euler(Math.PI/4.5,0,0)},right:{modelUrl:Na+"right.gltf",rayOrigin:{origin:{x:-.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new C.Vector3(.005,.036,-.037),modelPivotRotation:new C.Euler(Math.PI/4.5,0,0)}},gy="oculus-touch",eo={"oculus-touch":EF,"oculus-touch-v2":{left:{modelUrl:Na+"gen2-left.gltf",rayOrigin:{origin:{x:-.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new C.Vector3(0,-.007,-.021),modelPivotRotation:new C.Euler(-Math.PI/4,0,0)},right:{modelUrl:Na+"gen2-right.gltf",rayOrigin:{origin:{x:.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new C.Vector3(0,-.007,-.021),modelPivotRotation:new C.Euler(-Math.PI/4,0,0)}},"oculus-touch-v3":{left:{modelUrl:Na+"v3-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new C.Vector3(0,0,0),modelPivotRotation:new C.Euler(0,0,0)},right:{modelUrl:Na+"v3-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new C.Vector3(0,0,0),modelPivotRotation:new C.Euler(0,0,0)}},"meta-quest-touch-pro":{left:{modelUrl:ru+"quest-touch-pro-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new C.Vector3(0,0,0),modelPivotRotation:new C.Euler(0,0,0)},right:{modelUrl:ru+"quest-touch-pro-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new C.Vector3(0,0,0),modelPivotRotation:new C.Euler(0,0,0)}},"meta-quest-touch-plus":{left:{modelUrl:ru+"quest-touch-plus-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new C.Vector3(0,0,0),modelPivotRotation:new C.Euler(0,0,0)},right:{modelUrl:ru+"quest-touch-plus-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new C.Vector3(0,0,0),modelPivotRotation:new C.Euler(0,0,0)}}},vy={schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#999"},buttonTouchColor:{type:"color",default:"#8AB"},buttonHighlightColor:{type:"color",default:"#2DF"},model:{default:!0},controllerType:{default:"auto",oneOf:["auto","oculus-touch","oculus-touch-v2","oculus-touch-v3"]}},after:["tracked-controls"],mapping:{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton","surface"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton","surface"]}},bindMethods:function(){this.onButtonChanged=this.onButtonChanged.bind(this),this.onThumbstickMoved=this.onThumbstickMoved.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var n=this;this.onButtonDown=function(e){dt(e.detail.id,"down",n,n.data.hand)},this.onButtonUp=function(e){dt(e.detail.id,"up",n,n.data.hand)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n,n.data.hand)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n,n.data.hand)},this.controllerPresent=!1,this.previousButtonValues={},this.bindMethods(),this.triggerEuler=new C.Euler},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),n.addEventListener("model-loaded",this.onModelLoaded),n.addEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),n.removeEventListener("model-loaded",this.onModelLoaded),n.removeEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.controllerObject3D;n&&(n.visible=!1),si(this,Ay,{hand:this.data.hand,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},loadModel:function(n){var e,t=this.data;if(t.model){if(this.controllerObject3D)return this.controllerObject3D.visible=!0,void this.el.setObject3D("mesh",this.controllerObject3D);if(this.displayModel=eo[t.controllerType]||eo[gy],t.controllerType==="auto"){e=gy;for(var i=Object.keys(eo),r=0;r<n.profiles.length;r++)if(i.indexOf(n.profiles[r])!==-1){e=n.profiles[r];break}this.displayModel=eo[e]}var s=this.displayModel[t.hand].modelUrl;this.isTouchV3orPROorPlus=this.displayModel===eo["oculus-touch-v3"]||this.displayModel===eo["meta-quest-touch-pro"]||this.displayModel===eo["meta-quest-touch-plus"],this.el.setAttribute("gltf-model",s)}},injectTrackedControls:function(n){var e=this.data,t=Ay;this.el.setAttribute("tracked-controls",{id:t,hand:e.hand,handTrackingEnabled:!1,iterateControllerProfiles:!0}),this.loadModel(n)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e=this.mapping[this.data.hand].buttons[n.detail.id];if(e){if(this.isTouchV3orPROorPlus)this.onButtonChangedV3orPROorPlus(n);else{var t,i=this.buttonMeshes;e!=="trigger"&&e!=="grip"||(t=n.detail.state.value),i&&(e==="trigger"&&i.trigger&&(i.trigger.rotation.x=this.originalXRotationTrigger-t*(Math.PI/26)),e==="grip"&&i.grip&&(t*=this.data.hand==="left"?-1:1,i.grip.position.x=this.originalXPositionGrip+.004*t))}this.el.emit(e+"changed",n.detail.state)}},onButtonChangedV3orPROorPlus:function(n){var e,t=this.mapping[this.data.hand].buttons[n.detail.id],i=this.buttonObjects;i&&i[t]&&(e=n.detail.state.value,i[t].quaternion.slerpQuaternions(this.buttonRanges[t].min.quaternion,this.buttonRanges[t].max.quaternion,e),i[t].position.lerpVectors(this.buttonRanges[t].min.position,this.buttonRanges[t].max.position,e))},onModelLoaded:function(n){if(n.target===this.el&&this.data.model){if(this.isTouchV3orPROorPlus)this.onTouchV3orPROorPlusModelLoaded(n);else{var e,t=this.controllerObject3D=n.detail.model;(e=this.buttonMeshes={}).grip=t.getObjectByName("buttonHand"),this.originalXPositionGrip=e.grip&&e.grip.position.x,e.trigger=t.getObjectByName("buttonTrigger"),this.originalXRotationTrigger=e.trigger&&e.trigger.rotation.x,e.thumbstick=t.getObjectByName("stick"),e.xbutton=t.getObjectByName("buttonX"),e.abutton=t.getObjectByName("buttonA"),e.ybutton=t.getObjectByName("buttonY"),e.bbutton=t.getObjectByName("buttonB")}for(var i in this.buttonMeshes)this.buttonMeshes[i]&&xF(this.buttonMeshes[i]);this.applyOffset(n.detail.model),this.el.emit("controllermodelready",{name:"meta-touch-controls",model:this.data.model,rayOrigin:this.displayModel[this.data.hand].rayOrigin})}},applyOffset:function(n){n.position.copy(this.displayModel[this.data.hand].modelPivotOffset),n.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation)},onTouchV3orPROorPlusModelLoaded:function(n){var e=this.controllerObject3D=n.detail.model,t=this.buttonObjects={},i=this.buttonMeshes={},r=this.buttonRanges={};i.grip=e.getObjectByName("squeeze"),t.grip=e.getObjectByName("xr_standard_squeeze_pressed_value"),r.grip={min:e.getObjectByName("xr_standard_squeeze_pressed_min"),max:e.getObjectByName("xr_standard_squeeze_pressed_max")},t.grip.minX=t.grip.position.x,i.thumbstick=e.getObjectByName("thumbstick"),t.thumbstick=e.getObjectByName("xr_standard_thumbstick_pressed_value"),r.thumbstick={min:e.getObjectByName("xr_standard_thumbstick_pressed_min"),max:e.getObjectByName("xr_standard_thumbstick_pressed_max")},t.thumbstickXAxis=e.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"),r.thumbstickXAxis={min:e.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),max:e.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")},t.thumbstickYAxis=e.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"),r.thumbstickYAxis={min:e.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),max:e.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")},i.trigger=e.getObjectByName("trigger"),t.trigger=e.getObjectByName("xr_standard_trigger_pressed_value"),r.trigger={min:e.getObjectByName("xr_standard_trigger_pressed_min"),max:e.getObjectByName("xr_standard_trigger_pressed_max")},r.trigger.diff={x:Math.abs(r.trigger.max.rotation.x)-Math.abs(r.trigger.min.rotation.x),y:Math.abs(r.trigger.max.rotation.y)-Math.abs(r.trigger.min.rotation.y),z:Math.abs(r.trigger.max.rotation.z)-Math.abs(r.trigger.min.rotation.z)};var s=this.data.hand==="left"?"x":"a",o=this.data.hand==="left"?"y":"b",a=s+"button",l=o+"button";i[a]=e.getObjectByName(s+"_button"),t[a]=e.getObjectByName(s+"_button_pressed_value"),r[a]={min:e.getObjectByName(s+"_button_pressed_min"),max:e.getObjectByName(s+"_button_pressed_max")},i[l]=e.getObjectByName(o+"_button"),t[l]=e.getObjectByName(o+"_button_pressed_value"),r[l]={min:e.getObjectByName(o+"_button_pressed_min"),max:e.getObjectByName(o+"_button_pressed_max")}},onAxisMoved:function(n){vi(this,this.mapping[this.data.hand].axes,n)},onThumbstickMoved:function(n){if(this.buttonMeshes&&this.buttonMeshes.thumbstick)if(this.isTouchV3orPROorPlus)this.updateThumbstickTouchV3orPROorPlus(n);else for(var e in n.detail)this.buttonObjects.thumbstick.rotation[this.axisMap[e]]=this.buttonRanges.thumbstick.originalRotation[this.axisMap[e]]-Math.PI/8*n.detail[e]*(e==="y"||this.data.hand==="right"?-1:1)},axisMap:{y:"x",x:"z"},updateThumbstickTouchV3orPROorPlus:function(n){var e=(n.detail.x+1)/2;this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion,this.buttonRanges.thumbstickXAxis.max.quaternion,e);var t=(n.detail.y+1)/2;this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion,this.buttonRanges.thumbstickYAxis.max.quaternion,t)},updateModel:function(n,e){this.data.model&&this.updateButtonModel(n,e)},updateButtonModel:function(n,e){var t,i=this.buttonMeshes;i&&i[n]&&(t=e==="up"||e==="touchend"?i[n].originalColor||this.data.buttonColor:e==="touchstart"?this.data.buttonTouchColor:this.data.buttonHighlightColor,i[n].material.color.set(t))}};function xF(n){n.traverse(function(e){var t;e.type==="Mesh"&&(t=e.material.clone(),n.originalColor=e.material.color,e.material.dispose(),e.material=t)})}tt("oculus-touch-controls",vy),tt("meta-touch-controls",vy),tt("obb-collider",{schema:{size:{default:0},trackedObject3D:{default:""},minimumColliderDimension:{default:.02},centerModel:{default:!1}},init:function(){this.previousScale=new C.Vector3().copy(this.el.object3D.scale),this.auxEuler=new C.Euler,this.boundingBox=new C.Box3,this.boundingBoxSize=new C.Vector3,this.updateCollider=this.updateCollider.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.updateBoundingBox=this.updateBoundingBox.bind(this),this.el.addEventListener("model-loaded",this.onModelLoaded),this.updateCollider(),this.system.addCollider(this.el)},remove:function(){this.system.removeCollider(this.el)},update:function(){this.data.trackedObject3D&&(this.trackedObject3DPath=this.data.trackedObject3D.split("."))},onModelLoaded:function(){this.data.centerModel&&this.centerModel(),this.updateCollider()},centerModel:function(){var n,e=this.el,t=e.components["gltf-model"]&&e.components["gltf-model"].model;t&&(this.el.removeObject3D("mesh"),n=new C.Box3().setFromObject(t).getCenter(new C.Vector3),t.position.x+=t.position.x-n.x,t.position.y+=t.position.y-n.y,t.position.z+=t.position.z-n.z,this.el.setObject3D("mesh",t))},updateCollider:function(){var n=this.el,e=this.boundingBoxSize,t=this.aabb=this.aabb||new Vd;this.obb=this.obb||new Vd,n.hasLoaded?(this.updateBoundingBox(),t.halfSize.copy(e).multiplyScalar(.5),this.el.sceneEl.systems["obb-collider"].data.showColliders&&this.showCollider()):n.addEventListener("loaded",this.updateCollider)},showCollider:function(){this.updateColliderMesh(),this.renderColliderMesh.visible=!0},updateColliderMesh:function(){var n=this.renderColliderMesh,e=this.boundingBoxSize;n?(n.geometry.dispose(),n.geometry=new C.BoxGeometry(e.x,e.y,e.z)):this.initColliderMesh()},hideCollider:function(){this.renderColliderMesh&&(this.renderColliderMesh.visible=!1)},initColliderMesh:function(){var n,e,t;n=this.boundingBoxSize,e=this.renderColliderGeometry=new C.BoxGeometry(n.x,n.y,n.z),(t=this.renderColliderMesh=new C.Mesh(e,new C.MeshLambertMaterial({color:65280,side:C.DoubleSide}))).matrixAutoUpdate=!1,t.matrixWorldAutoUpdate=!1,t.updateMatrixWorld=function(){},this.el.sceneEl.object3D.add(t)},updateBoundingBox:(nu=new C.Vector3,iu=new C.Vector3,wm=new C.Quaternion,my=new C.Quaternion,Tm=new C.Matrix4,function(){var n=this.auxEuler,e=this.boundingBox,t=this.data.size,i=this.trackedObject3D||this.el.object3D,r=this.boundingBoxSize,s=this.data.minimumColliderDimension;if(t)return this.boundingBoxSize.x=t,this.boundingBoxSize.y=t,void(this.boundingBoxSize.z=t);n.copy(i.rotation),i.rotation.set(0,0,0),i.parent.matrixWorld.decompose(nu,wm,iu),Tm.compose(nu,my,iu),i.parent.matrixWorld.copy(Tm),e.setFromObject(i,!0),e.getSize(r),r.x=r.x<s?s:r.x,r.y=r.y<s?s:r.y,r.z=r.z<s?s:r.z,i.parent.matrixWorld.compose(nu,wm,iu),this.el.object3D.rotation.copy(n)}),checkTrackedObject:function(){var n,e=this.trackedObject3DPath;if(e&&e.length&&!this.trackedObject3D){n=this.el;for(var t=0;t<e.length&&(n=n[e[t]]);t++);n&&(this.trackedObject3D=n,this.updateCollider())}return this.trackedObject3D},tick:function(){var n=new C.Vector3,e=new C.Vector3,t=new C.Quaternion,i=new C.Matrix4;return function(){var r=this.obb,s=this.renderColliderMesh,o=this.checkTrackedObject()||this.el.object3D;o&&(o.updateMatrix(),o.updateMatrixWorld(!0),o.matrixWorld.decompose(n,t,e),(Math.abs(e.x-this.previousScale.x)>1e-4||Math.abs(e.y-this.previousScale.y)>1e-4||Math.abs(e.z-this.previousScale.z)>1e-4)&&this.updateCollider(),this.previousScale.copy(e),e.set(1,1,1),i.compose(n,t,e),s&&s.matrixWorld.copy(i),r.copy(this.aabb),r.applyMatrix4(i))}}()});var yF=Bt("components:obj-model:warn"),_F=(tt("obj-model",{schema:{mtl:{type:"model"},obj:{type:"model"}},init:function(){var n=this;this.model=null,this.objLoader=new jM,this.mtlLoader=new $M(this.objLoader.manager),this.mtlLoader.crossOrigin="",this.el.addEventListener("componentinitialized",function(e){n.model&&e.detail.name==="material"&&n.applyMaterial()})},update:function(){var n=this.data;n.obj&&(this.resetMesh(),this.loadObj(n.obj,n.mtl))},remove:function(){this.resetMesh()},resetMesh:function(){this.model&&this.el.removeObject3D("mesh")},loadObj:function(n,e){var t=this,i=this.el,r=this.mtlLoader,s=this.objLoader,o=this.el.sceneEl.systems.renderer,a=e.substr(0,e.lastIndexOf("/")+1);if(e)return i.hasAttribute("material")&&yF("Material component properties are ignored when a .MTL is provided"),r.setResourcePath(a),void r.load(e,function(l){l.preload(),s.setMaterials(l),s.load(n,function(c){t.model=c,t.model.traverse(function(h){if(h.isMesh){var u=h.material;u.map&&o.applyColorCorrection(u.map),u.emissiveMap&&o.applyColorCorrection(u.emissiveMap)}}),i.setObject3D("mesh",c),i.emit("model-loaded",{format:"obj",model:c})})});s.load(n,function(l){t.model=l,t.applyMaterial(),i.setObject3D("mesh",l),i.emit("model-loaded",{format:"obj",model:l})})},applyMaterial:function(){var n=this.el.components.material;n&&this.model.traverse(function(e){e instanceof C.Mesh&&(e.material=n.material)})}}),qt+"controllers/oculus/go/oculus-go-controller.gltf"),Ey="oculus-go",xy=(tt("oculus-go-controls",{schema:{hand:{default:""},buttonColor:{type:"color",default:"#FFFFFF"},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var n=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n)},this.onButtonUp=function(e){dt(e.detail.id,"up",n)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n)},this.controllerPresent=!1,this.bindMethods()},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("model-loaded",this.onModelLoaded),n.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("model-loaded",this.onModelLoaded),n.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){si(this,Ey,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{hand:e.hand,idPrefix:Ey}),this.data.model&&this.el.setAttribute("gltf-model",_F)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(n){var e,t=n.detail.model;n.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).trigger=t.getObjectByName("oculus_go_button_trigger"),e.trackpad=t.getObjectByName("oculus_go_touchpad"),e.touchpad=t.getObjectByName("oculus_go_touchpad"))},onButtonChanged:function(n){var e=this.mapping.buttons[n.detail.id];e&&this.el.emit(e+"changed",n.detail.state)},onAxisMoved:function(n){vi(this,this.mapping.axes,n)},updateModel:function(n,e){this.data.model&&this.updateButtonModel(n,e)},updateButtonModel:function(n,e){var t=this.buttonMeshes;if(t&&t[n]){var i;switch(e){case"down":i=this.data.buttonHighlightColor;break;case"touchstart":i=this.data.buttonTouchedColor;break;default:i=this.data.buttonColor}t[n].material.color.set(i)}}}),"pico-4"),bF=qt+"controllers/pico/pico4/",yy=(tt("pico-controls",{schema:{hand:{default:"none"},model:{default:!0}},mapping:{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var n=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n,n.data.hand)},this.onButtonUp=function(e){dt(e.detail.id,"up",n,n.data.hand)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n,n.data.hand)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n,n.data.hand)},this.bindMethods()},update:function(){var n=this.data;this.controllerIndex=n.hand==="right"?0:n.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),n.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),n.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.data;si(this,xy,{index:this.controllerIndex,hand:n.hand})},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{idPrefix:xy,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("gltf-model",bF+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e,t=this.mapping[this.data.hand].buttons[n.detail.id];t&&(t==="trigger"&&(e=n.detail.state.value,console.log("analog value of trigger press: "+e)),this.el.emit(t+"changed",n.detail.state))},onModelLoaded:function(n){n.target===this.el&&this.data.model&&this.el.emit("controllermodelready",{name:"pico-controls",model:this.data.model,rayOrigin:new C.Vector3(0,0,0)})},onAxisMoved:function(n){vi(this,this.mapping[this.data.hand].axes,n)}}),tt("position",{schema:{type:"vec3"},update:function(){var n=this.el.object3D,e=this.data;n.position.set(e.x,e.y,e.z)},remove:function(){this.el.object3D.position.set(0,0,0)}}),Bt("components:raycaster:warn")),CF=/^[\w\s-.,[\]#]*$/,MF={childList:!0,attributes:!0,subtree:!0},_y="raycaster-intersected-cleared",by="raycaster-intersection-cleared";function Cy(n,e){var t;for(n.length=e.length,t=0;t<e.length;t++)n[t]=e[t]}tt("raycaster",{schema:{autoRefresh:{default:!0},direction:{type:"vec3",default:{x:0,y:0,z:-1}},enabled:{default:!0},far:{default:1e3},interval:{default:0},near:{default:0},objects:{default:""},origin:{type:"vec3"},showLine:{default:!1},lineColor:{default:"white"},lineOpacity:{default:1},useWorldCoordinates:{default:!1}},multiple:!0,init:function(){this.clearedIntersectedEls=[],this.unitLineEndVec3=new C.Vector3,this.intersectedEls=[],this.intersections=[],this.newIntersectedEls=[],this.newIntersections=[],this.objects=[],this.prevCheckTime=void 0,this.prevIntersectedEls=[],this.rawIntersections=[],this.raycaster=new C.Raycaster,this.updateOriginDirection(),this.setDirty=this.setDirty.bind(this),this.updateLine=this.updateLine.bind(this),this.observer=new MutationObserver(this.setDirty),this.dirty=!0,this.lineEndVec3=new C.Vector3,this.otherLineEndVec3=new C.Vector3,this.lineData={end:this.lineEndVec3},this.getIntersection=this.getIntersection.bind(this),this.intersectedDetail={el:this.el,getIntersection:this.getIntersection},this.intersectedClearedDetail={el:this.el},this.intersectionClearedDetail={clearedEls:this.clearedIntersectedEls},this.intersectionDetail={}},update:function(n){var e=this.data,t=this.el,i=this.raycaster;i.far=e.far,i.near=e.near,!e.showLine||e.far===n.far&&e.origin===n.origin&&e.direction===n.direction&&n.showLine||(this.unitLineEndVec3.copy(e.direction).normalize(),this.drawLine()),!e.showLine&&n.showLine&&t.removeAttribute("line"),e.objects===n.objects||CF.test(e.objects)||yy('[raycaster] Selector "'+e.objects+'" may not update automatically with DOM changes.'),e.objects||yy('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'),e.autoRefresh!==n.autoRefresh&&t.isPlaying&&(e.autoRefresh?this.addEventListeners():this.removeEventListeners()),n.enabled&&!e.enabled&&this.clearAllIntersections(),e.objects!==n.objects&&this.setDirty()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){this.data.showLine&&this.el.removeAttribute("line"),this.clearAllIntersections()},addEventListeners:function(){this.data.autoRefresh&&(this.observer.observe(this.el.sceneEl,MF),this.el.sceneEl.addEventListener("object3dset",this.setDirty),this.el.sceneEl.addEventListener("object3dremove",this.setDirty))},removeEventListeners:function(){this.observer.disconnect(),this.el.sceneEl.removeEventListener("object3dset",this.setDirty),this.el.sceneEl.removeEventListener("object3dremove",this.setDirty)},setDirty:function(){this.dirty=!0},refreshObjects:function(){var n,e=this.data;n=e.objects?this.el.sceneEl.querySelectorAll(e.objects):this.el.sceneEl.querySelectorAll("*"),this.objects=this.flattenObject3DMaps(n),this.dirty=!1},tock:function(n){var e=this.data,t=this.prevCheckTime;e.enabled&&(t&&n-t<e.interval||(this.prevCheckTime=n,this.checkIntersections()))},checkIntersections:function(){var n,e,t=this.clearedIntersectedEls,i=this.el,r=this.data,s=this.intersectedEls,o=this.intersections,a=this.newIntersectedEls,l=this.newIntersections,c=this.prevIntersectedEls,h=this.rawIntersections;for(this.dirty&&this.refreshObjects(),Cy(this.prevIntersectedEls,this.intersectedEls),this.updateOriginDirection(),h.length=0,this.raycaster.intersectObjects(this.objects,!0,h),o.length=0,s.length=0,n=0;n<h.length;n++)e=h[n],r.showLine&&e.object===i.getObject3D("line")||e.object.el&&(o.push(e),s.push(e.object.el));for(l.length=0,a.length=0,n=0;n<o.length;n++)c.indexOf(o[n].object.el)===-1&&(l.push(o[n]),a.push(o[n].object.el));for(t.length=0,n=0;n<c.length;n++)s.indexOf(c[n])===-1&&(c[n].emit(_y,this.intersectedClearedDetail),t.push(c[n]));for(t.length&&i.emit(by,this.intersectionClearedDetail),n=0;n<a.length;n++)a[n].emit("raycaster-intersected",this.intersectedDetail);l.length&&(this.intersectionDetail.els=a,this.intersectionDetail.intersections=l,i.emit("raycaster-intersection",this.intersectionDetail)),(c.length===0&&o.length>0||c.length>0&&o.length===0||c.length&&o.length&&c[0]!==o[0].object.el)&&(this.intersectionDetail.els=this.intersectedEls,this.intersectionDetail.intersections=o,i.emit("raycaster-closest-entity-changed",this.intersectionDetail)),r.showLine&&setTimeout(this.updateLine)},updateLine:function(){var n,e=this.el,t=this.intersections;t.length&&(n=t[0].object.el===e&&t[1]?t[1].distance:t[0].distance),this.drawLine(n)},getIntersection:function(n){var e,t;for(e=0;e<this.intersections.length;e++)if((t=this.intersections[e]).object.el===n)return t;return null},updateOriginDirection:function(){var n=new C.Vector3,e=new C.Vector3;return function(){var t=this.el,i=this.data;i.useWorldCoordinates?this.raycaster.set(i.origin,i.direction):(t.object3D.updateMatrixWorld(),e.setFromMatrixPosition(t.object3D.matrixWorld),i.origin.x===0&&i.origin.y===0&&i.origin.z===0||(e=t.object3D.localToWorld(e.copy(i.origin))),n.copy(i.direction).transformDirection(t.object3D.matrixWorld).normalize(),this.raycaster.set(e,n))}}(),drawLine:function(n){var e,t=this.data,i=this.el;e=this.lineData.end===this.lineEndVec3?this.otherLineEndVec3:this.lineEndVec3,n===void 0&&(n=t.far===1/0?1e3:t.far),this.lineData.start=t.origin,this.lineData.end=e.copy(this.unitLineEndVec3).multiplyScalar(n).add(t.origin),this.lineData.color=t.lineColor,this.lineData.opacity=t.lineOpacity,i.setAttribute("line",this.lineData)},flattenObject3DMaps:function(n){var e,t,i=this.objects,r=this.el.sceneEl.object3D;function s(a){return a.parent?s(a.parent):a===r}for(i.length=0,t=0;t<n.length;t++){var o=n[t];if(o.isEntity&&o.object3D&&s(o.object3D))for(e in o.object3DMap)i.push(o.getObject3D(e))}return i},clearAllIntersections:function(){var n;for(n=0;n<this.intersectedEls.length;n++)this.intersectedEls[n].emit(_y,this.intersectedClearedDetail);Cy(this.clearedIntersectedEls,this.intersectedEls),this.intersectedEls.length=0,this.intersections.length=0,this.el.emit(by,this.intersectionClearedDetail)}});var My,ca,Sy,wy,Im=C.MathUtils.degToRad,Rm=(tt("rotation",{schema:{type:"vec3"},update:function(){var n=this.data;this.el.object3D.rotation.set(Im(n.x),Im(n.y),Im(n.z),"YXZ")},remove:function(){this.el.object3D.rotation.set(0,0,0)}}),tt("scale",{schema:{type:"vec3",default:{x:1,y:1,z:1}},update:function(){var n=this.data;this.el.object3D.scale.set(n.x,n.y,n.z)},remove:function(){this.el.object3D.scale.set(1,1,1)}}),tt("shadow",{schema:{cast:{default:!0},receive:{default:!0}},init:function(){this.onMeshChanged=this.update.bind(this),this.el.addEventListener("object3dset",this.onMeshChanged),this.system.setShadowMapEnabled(!0)},update:function(){var n=this.data;this.updateDescendants(n.cast,n.receive)},remove:function(){this.el.removeEventListener("object3dset",this.onMeshChanged),this.updateDescendants(!1,!1)},updateDescendants:function(n,e){var t=this.el.sceneEl;this.el.object3D.traverse(function(i){if(i instanceof C.Mesh&&(i.castShadow=n,i.receiveShadow=e,t.hasLoaded&&i.material))for(var r=Array.isArray(i.material)?i.material:[i.material],s=0;s<r.length;s++)r[s].needsUpdate=!0})}}),Bt("components:sound:warn")),SF=(tt("sound",{schema:{autoplay:{default:!1},distanceModel:{default:"inverse",oneOf:["linear","inverse","exponential"]},loop:{default:!1},loopStart:{default:0},loopEnd:{default:0},maxDistance:{default:1e4},on:{default:""},poolSize:{default:1},positional:{default:!0},refDistance:{default:1},rolloffFactor:{default:1},src:{type:"audio"},volume:{default:1}},multiple:!0,init:function(){var n=this;this.listener=null,this.audioLoader=new C.AudioLoader,this.pool=new C.Group,this.loaded=!1,this.mustPlay=!1,this.playSoundBound=function(){n.playSound()}},update:function(n){var e,t,i=this.data,r=i.src!==n.src;if(r){if(!i.src)return;this.setupSound()}for(e=0;e<this.pool.children.length;e++)t=this.pool.children[e],i.positional&&(t.setDistanceModel(i.distanceModel),t.setMaxDistance(i.maxDistance),t.setRefDistance(i.refDistance),t.setRolloffFactor(i.rolloffFactor)),t.setLoop(i.loop),t.setLoopStart(i.loopStart),i.loopStart!==0&&i.loopEnd===0?t.setLoopEnd(t.buffer.duration):t.setLoopEnd(i.loopEnd),t.setVolume(i.volume),t.isPaused=!1;if(i.on!==n.on&&this.updateEventListener(n.on),r){var s=this;this.loaded=!1,this.audioLoader.load(i.src,function(o){for(e=0;e<s.pool.children.length;e++)(t=s.pool.children[e]).setBuffer(o);s.loaded=!0,C.Cache.remove(i.src),(s.data.autoplay||s.mustPlay)&&s.playSound(s.processSound),s.el.emit("sound-loaded",s.evtDetail,!1)})}},pause:function(){this.stopSound(),this.removeEventListener()},play:function(){this.data.autoplay&&this.playSound(),this.updateEventListener()},remove:function(){var n;this.removeEventListener(),this.el.getObject3D(this.attrName)&&this.el.removeObject3D(this.attrName);try{for(n=0;n<this.pool.children.length;n++)this.pool.children[n].disconnect()}catch{Rm("Audio source not properly disconnected")}},updateEventListener:function(n){var e=this.el;n&&e.removeEventListener(n,this.playSoundBound),e.addEventListener(this.data.on,this.playSoundBound)},removeEventListener:function(){this.el.removeEventListener(this.data.on,this.playSoundBound)},setupSound:function(){var n,e,t=this.el,i=t.sceneEl,r=this;this.pool.children.length>0&&(this.stopSound(),t.removeObject3D("sound"));var s=this.listener=i.audioListener||new C.AudioListener;for(i.audioListener=s,i.camera&&i.camera.add(s),i.addEventListener("camera-set-active",function(o){o.detail.cameraEl.getObject3D("camera").add(s)}),this.pool=new C.Group,n=0;n<this.data.poolSize;n++)e=this.data.positional?new C.PositionalAudio(s):new C.Audio(s),this.pool.add(e);for(t.setObject3D(this.attrName,this.pool),n=0;n<this.pool.children.length;n++)(e=this.pool.children[n]).onEnded=function(){this.isPlaying=!1,r.el.emit("sound-ended",r.evtDetail,!1)}},pauseSound:function(){var n,e;for(this.isPlaying=!1,n=0;n<this.pool.children.length;n++)(e=this.pool.children[n]).source&&e.source.buffer&&e.isPlaying&&!e.isPaused&&(e.isPaused=!0,e.pause())},playSound:function(n){var e,t,i;if(!this.loaded)return Rm("Sound not loaded yet. It will be played once it finished loading"),this.mustPlay=!0,void(this.processSound=n);for(e=!1,this.isPlaying=!0,t=0;t<this.pool.children.length;t++)(i=this.pool.children[t]).isPlaying||!i.buffer||e||(n&&n(i),i.play(),i.isPaused=!1,e=!0);e?(this.mustPlay=!1,this.processSound=void 0):Rm("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.",this.el)},stopSound:function(){var n,e;for(this.isPlaying=!1,n=0;n<this.pool.children.length;n++){if(!(e=this.pool.children[n]).source||!e.source.buffer)return;e.stop()}}}),nt(4433)),wF=nt.n(SF),TF=nt(5751),IF=nt.n(TF),ha=Bt("components:text:error"),RF=Bt("components:text:warn"),ur=qt+"fonts/",Ty={aileronsemibold:ur+"Aileron-Semibold.fnt",dejavu:ur+"DejaVu-sdf.fnt",exo2bold:ur+"Exo2Bold.fnt",exo2semibold:ur+"Exo2SemiBold.fnt",kelsonsans:ur+"KelsonSans.fnt",monoid:ur+"Monoid.fnt",mozillavr:ur+"mozillavr.fnt",roboto:ur+"Roboto-msdf.json",sourcecodepro:ur+"SourceCodePro.fnt"},Iy=["roboto"],Bm="roboto",Ry=new function(){var n=this.cache={};this.get=function(e,t){return e in n||(n[e]=t()),n[e]}},By={},su={},BF=/^\w+:/;function Ly(n,e,t){return n||(.5+e)*t}tt("text",{multiple:!0,schema:{align:{type:"string",default:"left",oneOf:["left","right","center"]},alphaTest:{default:.5},anchor:{default:"center",oneOf:["left","right","center","align"]},baseline:{default:"center",oneOf:["top","center","bottom"]},color:{type:"color",default:"#FFF"},font:{type:"string",default:Bm},fontImage:{type:"string"},height:{type:"number"},letterSpacing:{type:"number",default:0},lineHeight:{type:"number"},negate:{type:"boolean",default:!0},opacity:{type:"number",default:1},shader:{default:"sdf",oneOf:ji},side:{default:"front",oneOf:["front","back","double"]},tabSize:{default:4},transparent:{default:!0},value:{type:"string"},whiteSpace:{default:"normal",oneOf:["normal","pre","nowrap"]},width:{type:"number"},wrapCount:{type:"number",default:40},wrapPixels:{type:"number"},xOffset:{type:"number",default:0},yOffset:{type:"number",default:0},zOffset:{type:"number",default:.001}},init:function(){this.shaderData={},this.geometry=wF()(),this.createOrUpdateMaterial(),this.explicitGeoDimensionsChecked=!1},update:function(n){var e=this.data,t=this.currentFont;su[e.font]?this.texture=su[e.font]:(this.texture=su[e.font]=new C.Texture,this.texture.anisotropy=16),this.createOrUpdateMaterial(),n.font===e.font?t&&(this.updateGeometry(this.geometry,t),this.updateLayout()):this.updateFont()},remove:function(){this.geometry.dispose(),this.geometry=null,this.el.removeObject3D(this.attrName),this.material.dispose(),this.material=null,this.texture.dispose(),this.texture=null,this.shaderObject&&delete this.shaderObject},createOrUpdateMaterial:function(){var n,e,t,i=this.data,r=this.material,s=this.shaderData;if(t=i.shader,Iy.indexOf(i.font)!==-1||i.font.indexOf("-msdf.")>=0?t="msdf":i.font in Ty&&Iy.indexOf(i.font)===-1&&(t="sdf"),n=(this.shaderObject&&this.shaderObject.name)!==t,s.alphaTest=i.alphaTest,s.color=i.color,s.map=this.texture,s.opacity=i.opacity,s.side=function(o){switch(o){case"back":return C.FrontSide;case"double":return C.DoubleSide;default:return C.BackSide}}(i.side),s.transparent=i.transparent,s.negate=i.negate,!n)return this.shaderObject.update(s),r.transparent=s.transparent,void(r.side=s.side);e=function(o,a,l){var c,h;return(h=new ji[a].Shader).el=o,h.init(l),h.update(l),(c=h.material).transparent=l.transparent,{material:c,shader:h}}(this.el,t,s),this.material=e.material,this.shaderObject=e.shader,this.material.side=s.side,this.mesh&&(this.mesh.material=this.material)},updateFont:function(){var n,e=this.data,t=this.el,i=this.geometry,r=this;e.font||RF("No font specified. Using the default font."),this.mesh&&(this.mesh.visible=!1),n=this.lookupFont(e.font||Bm)||e.font,Ry.get(n,function(){return function(s,o){return new Promise(function(a,l){IF()(s,function(c,h){if(c)return ha("Error loading font",s),void l(c);s.indexOf("/Roboto-msdf.json")>=0&&(o=30),o&&h.chars.forEach(function(u){u.yoffset+=o}),a(h)})})}(n,e.yOffset)}).then(function(s){var o;if(s.pages.length!==1)throw new Error("Currently only single-page bitmap fonts are supported.");By[n]||(s.widthFactor=By[s]=function(a){var l=0,c=0,h=0;return a.chars.forEach(function(u){l+=u.xadvance,u.id>=48&&u.id<=57&&(h++,c+=u.xadvance)}),h?c/h:l/a.chars.length}(s)),r.currentFont=s,o=r.getFontImageSrc(),Ry.get(o,function(){return function(a){return new Promise(function(l,c){new C.ImageLoader().load(a,function(h){l(h)},void 0,function(){ha("Error loading font image",a),c(null)})})}(o)}).then(function(a){var l=r.texture;l&&(l.image=a,l.needsUpdate=!0,su[e.font]=l,r.texture=l,r.initMesh(),r.currentFont=s,r.updateGeometry(i,s),r.updateLayout(),r.mesh.visible=!0,t.emit("textfontset",{font:e.font,fontObj:s}))}).catch(function(a){ha(a.message),ha(a.stack)})}).catch(function(s){ha(s.message),ha(s.stack)})},initMesh:function(){this.mesh||(this.mesh=new C.Mesh(this.geometry,this.material),this.el.setObject3D(this.attrName,this.mesh))},getFontImageSrc:function(){if(this.data.fontImage)return this.data.fontImage;var n=this.lookupFont(this.data.font||Bm)||this.data.font,e=this.currentFont.pages[0];return e.match(BF)&&e.indexOf("http")!==0?n.replace(/(\.fnt)|(\.json)/,".png"):C.LoaderUtils.extractUrlBase(n)+e},updateLayout:function(){var n,e,t,i,r,s,o,a,l,c=this.el,h=this.data,u=this.geometry,d=this.mesh;if(d&&u.layout){if(t=c.getAttribute("geometry"),i=(s=(o=h.width||t&&t.width||1)/Ly(h.wrapPixels,h.wrapCount,this.currentFont.widthFactor))*((r=u.layout).height+r.descender),t&&t.primitive==="plane"&&(this.explicitGeoDimensionsChecked||(this.explicitGeoDimensionsChecked=!0,this.hasExplicitGeoWidth=!!t.width,this.hasExplicitGeoHeight=!!t.height),this.hasExplicitGeoWidth||c.setAttribute("geometry","width",o),this.hasExplicitGeoHeight||c.setAttribute("geometry","height",i)),(n=h.anchor==="align"?h.align:h.anchor)==="left")a=0;else if(n==="right")a=-1*r.width;else{if(n!=="center")throw new TypeError("Invalid text.anchor property value",n);a=-1*r.width/2}if((e=h.baseline)==="bottom")l=0;else if(e==="top")l=-1*r.height+r.ascender;else{if(e!=="center")throw new TypeError("Invalid text.baseline property value",e);l=-1*r.height/2}d.position.x=a*s+h.xOffset,d.position.y=l*s,d.position.z=h.zOffset,d.scale.set(s,-1*s,s)}},lookupFont:function(n){return Ty[n]},updateGeometry:(My={},ca={},Sy=/\\n/g,wy=/\\t/g,function(n,e){var t=this.data;ca.font=e,ca.lineHeight=t.lineHeight&&isFinite(t.lineHeight)?t.lineHeight:e.common.lineHeight,ca.text=t.value.toString().replace(Sy,`
`).replace(wy,"	"),ca.width=Ly(t.wrapPixels,t.wrapCount,e.widthFactor),n.update(qn(My,t,ca))})});var ua,Lm,Dy=(tt("tracked-controls",{schema:{id:{type:"string",default:""},controller:{default:-1},autoHide:{default:!0},hand:{type:"string",default:""},handTrackingEnabled:{default:!1},iterateControllerProfiles:{default:!1}},init:function(){this.buttonEventDetails={},this.buttonStates=this.el.components["tracked-controls"].buttonStates={},this.axis=this.el.components["tracked-controls"].axis=[0,0,0],this.changedAxes=[],this.axisMoveEventDetail={axis:this.axis,changed:this.changedAxes},this.updateController=this.updateController.bind(this)},update:function(){this.updateController()},play:function(){var n=this.el.sceneEl;this.updateController(),n.addEventListener("controllersupdated",this.updateController)},pause:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.updateController)},isControllerPresent:function(n){return!(!this.controller||this.controller.gamepad||n.inputSource.handedness!=="none"&&n.inputSource.handedness!==this.data.hand)},updateController:function(){this.controller=tv(this.system.controllers,this.data.id,this.data.hand,this.data.controller,this.data.iterateControllerProfiles,this.data.handTrackingEnabled),this.el.components["tracked-controls"].controller=this.controller},tick:function(){var n=this.el.sceneEl,e=this.controller,t=n.frame;this.data.autoHide&&(this.el.object3D.visible=!!e),e&&n.frame&&this.system.referenceSpace&&(e.hand||(this.pose=t.getPose(e.gripSpace,this.system.referenceSpace),this.updatePose(),this.updateButtons()))},updatePose:function(){var n=this.el.object3D,e=this.pose;e&&(n.matrix.elements=e.transform.matrix,n.matrix.decompose(n.position,n.rotation,n.scale))},updateButtons:function(){var n,e,t,i=this.controller;if(i&&i.gamepad){for(t=i.gamepad,e=0;e<t.buttons.length;++e)this.buttonStates[e]||(this.buttonStates[e]={pressed:!1,touched:!1,value:0}),this.buttonEventDetails[e]||(this.buttonEventDetails[e]={id:e,state:this.buttonStates[e]}),n=t.buttons[e],this.handleButton(e,n);this.handleAxes()}},handleButton:function(n,e){return!!(this.handlePress(n,e)|this.handleTouch(n,e)|this.handleValue(n,e))&&(this.el.emit("buttonchanged",this.buttonEventDetails[n],!1),!0)},handleAxes:function(){var n,e=!1,t=this.controller.gamepad.axes,i=this.axis,r=this.changedAxes;for(this.changedAxes.splice(0,this.changedAxes.length),n=0;n<t.length;++n)r.push(i[n]!==t[n]),r[n]&&(e=!0);if(!e)return!1;for(this.axis.splice(0,this.axis.length),n=0;n<t.length;n++)this.axis.push(t[n]);return this.el.emit("axismove",this.axisMoveEventDetail,!1),!0},handlePress:function(n,e){var t,i=this.buttonStates[n];return e.pressed!==i.pressed&&(t=e.pressed?"buttondown":"buttonup",this.el.emit(t,this.buttonEventDetails[n],!1),i.pressed=e.pressed,!0)},handleTouch:function(n,e){var t,i=this.buttonStates[n];return e.touched!==i.touched&&(t=e.touched?"touchstart":"touchend",this.el.emit(t,this.buttonEventDetails[n],!1),i.touched=e.touched,!0)},handleValue:function(n,e){var t=this.buttonStates[n];return e.value!==t.value&&(t.value=e.value,!0)}}),tt("visible",{schema:{default:!0},update:function(){this.el.object3D.visible=this.data}}),qt+"controllers/valve/index/valve-index-"),LF={left:Dy+"left.glb",right:Dy+"right.glb"},Py="valve",DF={left:{x:0,y:-.05,z:.06},right:{x:0,y:-.05,z:.06}},PF={left:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"},right:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"}},UF=(tt("valve-index-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{trackpad:[0,1],thumbstick:[2,3]},buttons:["trigger","grip","trackpad","thumbstick","abutton"]},init:function(){var n=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n)},this.onButtonUp=function(e){dt(e.detail.id,"up",n)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n)},this.previousButtonValues={},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("model-loaded",this.onModelLoaded),n.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("model-loaded",this.onModelLoaded),n.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.data,e=n.hand==="right"?0:n.hand==="left"?1:2;si(this,Py,{index:e,iterateControllerProfiles:!0,hand:n.hand})},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{idPrefix:Py,controller:e.hand==="right"?1:e.hand==="left"?0:2,hand:e.hand}),this.loadModel()},loadModel:function(){var n=this.data;n.model&&this.el.setAttribute("gltf-model",""+LF[n.hand])},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e,t=this.mapping.buttons[n.detail.id],i=this.buttonMeshes;t&&(t==="trigger"&&(e=n.detail.state.value,i&&i.trigger&&(i.trigger.rotation.x=this.triggerOriginalRotationX-e*(Math.PI/40))),this.el.emit(t+"changed",n.detail.state))},onModelLoaded:function(n){var e,t=n.detail.model,i=this;n.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).grip={left:t.getObjectByName("leftgrip"),right:t.getObjectByName("rightgrip")},e.menu=t.getObjectByName("menubutton"),e.system=t.getObjectByName("systembutton"),e.trackpad=t.getObjectByName("touchpad"),e.trigger=t.getObjectByName("trigger"),this.triggerOriginalRotationX=e.trigger.rotation.x,Object.keys(e).forEach(function(r){i.setButtonColor(r,i.data.buttonColor)}),t.position.copy(PF[this.data.hand]),t.rotation.copy(DF[this.data.hand]),this.el.emit("controllermodelready",{name:"valve-index-controls",model:this.data.model,rayOrigin:new C.Vector3(0,0,0)}))},onAxisMoved:function(n){vi(this,this.mapping.axes,n)},updateModel:function(n,e){var t;this.data.model&&(e.indexOf("touch")!==-1||(t=e==="up"?this.data.buttonColor:this.data.buttonHighlightColor,this.setButtonColor(n,t)))},setButtonColor:function(n,e){}}),qt+"controllers/vive/vr_controller_vive.obj"),FF=qt+"controllers/vive/vr_controller_vive.mtl",Uy="htc-vive",NF=(tt("vive-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","none"]},init:function(){var n=this;this.controllerPresent=!1,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n)},this.onButtonUp=function(e){dt(e.detail.id,"up",n)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n)},this.previousButtonValues={},this.bindMethods()},update:function(){var n=this.data;this.controllerIndex=n.hand==="right"?0:n.hand==="left"?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("model-loaded",this.onModelLoaded),n.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("model-loaded",this.onModelLoaded),n.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var n=this.data;si(this,Uy,{index:this.controllerIndex,hand:n.hand})},injectTrackedControls:function(){var n=this.el,e=this.data;n.setAttribute("tracked-controls",{idPrefix:Uy,hand:e.hand,controller:this.controllerIndex}),this.data.model&&this.el.setAttribute("obj-model",{obj:UF,mtl:FF})},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(n){var e,t=this.mapping.buttons[n.detail.id],i=this.buttonMeshes;t&&(t==="trigger"&&(e=n.detail.state.value,i&&i.trigger&&(i.trigger.rotation.x=-e*(Math.PI/12))),this.el.emit(t+"changed",n.detail.state))},onModelLoaded:function(n){var e,t=n.detail.model,i=this;n.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).grip={left:t.getObjectByName("leftgrip"),right:t.getObjectByName("rightgrip")},e.menu=t.getObjectByName("menubutton"),e.system=t.getObjectByName("systembutton"),e.trackpad=t.getObjectByName("touchpad"),e.touchpad=t.getObjectByName("touchpad"),e.trigger=t.getObjectByName("trigger"),Object.keys(e).forEach(function(r){i.setButtonColor(r,i.data.buttonColor)}),t.position.set(0,-.015,.04))},onAxisMoved:function(n){vi(this,this.mapping.axes,n)},updateModel:function(n,e){var t;this.data.model&&(e.indexOf("touch")!==-1||(t=e==="up"?this.data.buttonColor:this.data.buttonHighlightColor,this.setButtonColor(n,t)))},setButtonColor:function(n,e){var t=this.buttonMeshes;if(t)return n==="grip"?(t.grip.left.material.color.set(e),void t.grip.right.material.color.set(e)):void t[n].material.color.set(e)}}),qt+"controllers/vive/focus-controller/focus-controller.gltf"),Fy="htc-vive-focus",Ny=(tt("vive-focus-controls",{schema:{hand:{default:""},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad","none","menu"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var n=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(e){dt(e.detail.id,"down",n)},this.onButtonUp=function(e){dt(e.detail.id,"up",n)},this.onButtonTouchStart=function(e){dt(e.detail.id,"touchstart",n)},this.onButtonTouchEnd=function(e){dt(e.detail.id,"touchend",n)},this.controllerPresent=!1,this.bindMethods()},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("model-loaded",this.onModelLoaded),n.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0,this.addControllersUpdateListener()},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("model-loaded",this.onModelLoaded),n.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1,this.removeControllersUpdateListener()},checkIfControllerPresent:function(){si(this,Fy,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){this.el.setAttribute("tracked-controls",{idPrefix:Fy}),this.data.model&&this.el.setAttribute("gltf-model",NF)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(n){var e,t=n.detail.model;n.target===this.el&&this.data.model&&((e=this.buttonMeshes={}).trigger=t.getObjectByName("BumperKey"),e.triggerPressed=t.getObjectByName("BumperKey_Press"),e.triggerPressed&&(e.triggerPressed.visible=!1),e.touchpad=t.getObjectByName("TouchPad"),e.touchpadPressed=t.getObjectByName("TouchPad_Press"),e.trackpad=t.getObjectByName("TouchPad"),e.trackpadPressed=t.getObjectByName("TouchPad_Press"),e.trackpadPressed&&(e.trackpadPressed.visible=!1))},onButtonChanged:function(n){var e=this.mapping.buttons[n.detail.id];e&&this.el.emit(e+"changed",n.detail.state)},onAxisMoved:function(n){vi(this,this.mapping.axes,n)},updateModel:function(n,e){this.data.model&&this.updateButtonModel(n,e)},updateButtonModel:function(n,e){var t=this.buttonMeshes,i=n+"Pressed";if(t&&t[n]&&t[i]){var r;switch(e){case"down":r=this.data.buttonHighlightColor;break;case"touchstart":r=this.data.buttonTouchedColor}r&&t[i].material.color.set(r),t[i].visible=!!r,t[n].visible=!r}}}),{38:"ArrowUp",37:"ArrowLeft",40:"ArrowDown",39:"ArrowRight",87:"KeyW",65:"KeyA",83:"KeyS",68:"KeyD"}),OF=sv,Oy=1e-5,kF=["KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowLeft","ArrowRight","ArrowDown"];tt("wasd-controls",{schema:{acceleration:{default:65},adAxis:{default:"x",oneOf:["x","y","z"]},adEnabled:{default:!0},adInverted:{default:!1},enabled:{default:!0},fly:{default:!1},wsAxis:{default:"z",oneOf:["x","y","z"]},wsEnabled:{default:!0},wsInverted:{default:!1}},after:["look-controls"],init:function(){this.keys={},this.easing=1.1,this.velocity=new C.Vector3,this.onBlur=this.onBlur.bind(this),this.onContextMenu=this.onContextMenu.bind(this),this.onFocus=this.onFocus.bind(this),this.onKeyDown=this.onKeyDown.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onVisibilityChange=this.onVisibilityChange.bind(this),this.attachVisibilityEventListeners()},tick:function(n,e){var t=this.data,i=this.el,r=this.velocity;(r[t.adAxis]||r[t.wsAxis]||!function(s){var o;for(o in s)return!1;return!0}(this.keys))&&(e/=1e3,this.updateVelocity(e),(r[t.adAxis]||r[t.wsAxis])&&i.object3D.position.add(this.getMovementVector(e)))},update:function(n){n.adAxis!==this.data.adAxis&&(this.velocity[n.adAxis]=0),n.wsAxis!==this.data.wsAxis&&(this.velocity[n.wsAxis]=0)},remove:function(){this.removeKeyEventListeners(),this.removeVisibilityEventListeners()},play:function(){this.attachKeyEventListeners()},pause:function(){this.keys={},this.removeKeyEventListeners()},updateVelocity:function(n){var e,t,i,r,s,o=this.data,a=this.keys,l=this.velocity;if(t=o.adAxis,r=o.wsAxis,n>.2)return l[t]=0,void(l[r]=0);var c=Math.pow(1/this.easing,60*n);l[t]!==0&&(l[t]=l[t]*c),l[r]!==0&&(l[r]=l[r]*c),Math.abs(l[t])<Oy&&(l[t]=0),Math.abs(l[r])<Oy&&(l[r]=0),o.enabled&&(e=o.acceleration,o.adEnabled&&(i=o.adInverted?-1:1,(a.KeyA||a.ArrowLeft)&&(l[t]-=i*e*n),(a.KeyD||a.ArrowRight)&&(l[t]+=i*e*n)),o.wsEnabled&&(s=o.wsInverted?-1:1,(a.KeyW||a.ArrowUp)&&(l[r]-=s*e*n),(a.KeyS||a.ArrowDown)&&(l[r]+=s*e*n)))},getMovementVector:(ua=new C.Vector3(0,0,0),Lm=new C.Euler(0,0,0,"YXZ"),function(n){var e,t=this.el.getAttribute("rotation"),i=this.velocity;return ua.copy(i),ua.multiplyScalar(n),t&&(e=this.data.fly?t.x:0,Lm.set(C.MathUtils.degToRad(e),C.MathUtils.degToRad(t.y),0),ua.applyEuler(Lm)),ua}),attachVisibilityEventListeners:function(){window.oncontextmenu=this.onContextMenu,window.addEventListener("blur",this.onBlur),window.addEventListener("focus",this.onFocus),document.addEventListener("visibilitychange",this.onVisibilityChange)},removeVisibilityEventListeners:function(){window.removeEventListener("blur",this.onBlur),window.removeEventListener("focus",this.onFocus),document.removeEventListener("visibilitychange",this.onVisibilityChange)},attachKeyEventListeners:function(){window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp)},removeKeyEventListeners:function(){window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp)},onContextMenu:function(){for(var n=Object.keys(this.keys),e=0;e<n.length;e++)delete this.keys[n[e]]},onBlur:function(){this.pause()},onFocus:function(){this.play()},onVisibilityChange:function(){document.hidden?this.onBlur():this.onFocus()},onKeyDown:function(n){var e;OF(n)&&(e=n.code||Ny[n.keyCode],kF.indexOf(e)!==-1&&(this.keys[e]=!0))},onKeyUp:function(n){var e;e=n.code||Ny[n.keyCode],delete this.keys[e]}});var Dm,ou,Bl,Ll=Bt("components:windows-motion-controls:debug"),da=Bt("components:windows-motion-controls:warn"),GF=qt+"controllers/microsoft/",ky={left:"left.glb",right:"right.glb",default:"universal.glb"},Gy="windows-mixed-reality",fa=(tt("windows-motion-controls",{schema:{hand:{default:"right"},pair:{default:0},model:{default:!0}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick","menu"],axisMeshNames:["TOUCHPAD_TOUCH_X","TOUCHPAD_TOUCH_X","THUMBSTICK_X","THUMBSTICK_Y"],buttonMeshNames:{trigger:"SELECT",menu:"MENU",squeeze:"GRASP",thumbstick:"THUMBSTICK_PRESS",touchpad:"TOUCHPAD_PRESS"},pointingPoseMeshName:"POINTING_POSE"},bindMethods:function(){this.onModelError=this.onModelError.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var n=this,e=this.el;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(t){dt(t.detail.id,"down",n)},this.onButtonUp=function(t){dt(t.detail.id,"up",n)},this.onButtonTouchStart=function(t){dt(t.detail.id,"touchstart",n)},this.onButtonTouchEnd=function(t){dt(t.detail.id,"touchend",n)},this.onControllerConnected=function(){n.setModelVisibility(!0)},this.onControllerDisconnected=function(){n.setModelVisibility(!1)},this.controllerPresent=!1,this.previousButtonValues={},this.bindMethods(),this.loadedMeshInfo={buttonMeshes:null,axisMeshes:null},this.rayOrigin={origin:new C.Vector3,direction:new C.Vector3(0,0,-1),createdFromMesh:!1},e.addEventListener("controllerconnected",this.onControllerConnected),e.addEventListener("controllerdisconnected",this.onControllerDisconnected)},addEventListeners:function(){var n=this.el;n.addEventListener("buttonchanged",this.onButtonChanged),n.addEventListener("buttondown",this.onButtonDown),n.addEventListener("buttonup",this.onButtonUp),n.addEventListener("touchstart",this.onButtonTouchStart),n.addEventListener("touchend",this.onButtonTouchEnd),n.addEventListener("axismove",this.onAxisMoved),n.addEventListener("model-error",this.onModelError),n.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var n=this.el;n.removeEventListener("buttonchanged",this.onButtonChanged),n.removeEventListener("buttondown",this.onButtonDown),n.removeEventListener("buttonup",this.onButtonUp),n.removeEventListener("touchstart",this.onButtonTouchStart),n.removeEventListener("touchend",this.onButtonTouchEnd),n.removeEventListener("axismove",this.onAxisMoved),n.removeEventListener("model-error",this.onModelError),n.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){si(this,Gy,{hand:this.data.hand,index:this.data.pair,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},updateControllerModel:function(){if(this.data.model&&!this.rayOrigin.createdFromMesh){var n=this.createControllerModelUrl();this.loadModel(n)}else this.modelReady()},createControllerModelUrl:function(n){var e=this.data.hand;return GF+"default/"+(ky[e]||ky.default)},injectTrackedControls:function(){var n=this.data;this.el.setAttribute("tracked-controls",{idPrefix:Gy,controller:n.pair,hand:n.hand}),this.updateControllerModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelError:function(n){var e=this.createControllerModelUrl(!0);n.detail.src!==e?(da("Failed to load controller model for device, attempting to load default."),this.loadModel(e)):da("Failed to load default controller model.")},loadModel:function(n){this.el.setAttribute("gltf-model","url("+n+")")},onModelLoaded:function(n){var e,t,i,r,s=this.controllerModel=n.detail.model,o=this.loadedMeshInfo;if(n.target===this.el){if(Ll("Processing model"),o.buttonMeshes={},o.axisMeshes={},s){for(e=0;e<this.mapping.buttons.length;e++)(t=this.mapping.buttonMeshNames[this.mapping.buttons[e]])?(i=s.getObjectByName(t))?(r={index:e,value:a(i,"VALUE"),pressed:a(i,"PRESSED"),unpressed:a(i,"UNPRESSED")}).value&&r.pressed&&r.unpressed?o.buttonMeshes[this.mapping.buttons[e]]=r:da("Missing button submesh under mesh with name: "+t+"(VALUE: "+!!r.value+", PRESSED: "+!!r.pressed+", UNPRESSED:"+!!r.unpressed+")"):da("Missing button mesh with name: "+t):Ll("Skipping unknown button at index: "+e+" with mapped name: "+this.mapping.buttons[e]);for(e=0;e<this.mapping.axisMeshNames.length;e++)(t=this.mapping.axisMeshNames[e])?(i=s.getObjectByName(t))?(r={index:e,value:a(i,"VALUE"),min:a(i,"MIN"),max:a(i,"MAX")}).value&&r.min&&r.max?o.axisMeshes[e]=r:da("Missing axis submesh under mesh with name: "+t+"(VALUE: "+!!r.value+", MIN: "+!!r.min+", MAX:"+!!r.max+")"):da("Missing axis mesh with name: "+t):Ll("Skipping unknown axis at index: "+e);this.calculateRayOriginFromMesh(s),this.setModelVisibility()}Ll("Model load complete.")}function a(l,c){for(var h=0,u=l.children.length;h<u;h++){var d=l.children[h];if(d&&d.name===c)return d}}},calculateRayOriginFromMesh:function(){var n=new C.Quaternion;return function(e){var t;if(this.rayOrigin.origin.set(0,0,0),this.rayOrigin.direction.set(0,0,-1),this.rayOrigin.createdFromMesh=!0,t=e.getObjectByName(this.mapping.pointingPoseMeshName)){var i=e.parent;i&&(e.parent=null,e.updateMatrixWorld(!0),e.parent=i),t.getWorldPosition(this.rayOrigin.origin),t.getWorldQuaternion(n),this.rayOrigin.direction.applyQuaternion(n),i&&e.updateMatrixWorld(!0)}else Ll("Mesh does not contain pointing origin data, defaulting to none.");this.modelReady()}}(),lerpAxisTransform:function(){var n=new C.Quaternion;return function(e,t){var i=this.loadedMeshInfo.axisMeshes[e];if(i){var r=i.min,s=i.max,o=i.value,a=.5*t+.5;o.setRotationFromQuaternion(n.copy(r.quaternion).slerp(s.quaternion,a)),o.position.lerpVectors(r.position,s.position,a)}}}(),lerpButtonTransform:function(){var n=new C.Quaternion;return function(e,t){var i=this.loadedMeshInfo.buttonMeshes[e];if(i){var r=i.unpressed,s=i.pressed,o=i.value;o.setRotationFromQuaternion(n.copy(r.quaternion).slerp(s.quaternion,t)),o.position.lerpVectors(r.position,s.position,t)}}}(),modelReady:function(){this.el.emit("controllermodelready",{name:"windows-motion-controls",model:this.data.model,rayOrigin:this.rayOrigin})},onButtonChanged:function(n){var e=this.mapping.buttons[n.detail.id];e&&(this.loadedMeshInfo&&this.loadedMeshInfo.buttonMeshes&&this.lerpButtonTransform(e,n.detail.state.value),this.el.emit(e+"changed",n.detail.state))},onAxisMoved:function(n){var e=this.mapping.axisMeshNames.length;if(this.loadedMeshInfo&&this.loadedMeshInfo.axisMeshes)for(var t=0;t<e;t++)this.lerpAxisTransform(t,n.detail.axis[t]||0);vi(this,this.mapping.axes,n)},setModelVisibility:function(n){var e=this.el.getObject3D("mesh");this.controllerPresent&&(n=n!==void 0?n:this.modelVisible,this.modelVisible=n,e&&(e.visible=n))}}),Dm=new C.Quaternion,ou=new C.Vector3,function(n,e,t){e.position.copy(n.transform.position),e.quaternion.copy(n.transform.orientation),ou.copy(t),Dm.copy(n.transform.orientation),ou.applyQuaternion(Dm),e.position.sub(ou)});function Cn(n,e){this.renderer=n,this.xrHitTestSource=null,n.xr.addEventListener("sessionend",(function(){this.xrHitTestSource=null}).bind(this)),n.xr.addEventListener("sessionstart",(function(){this.sessionStart(e)}).bind(this)),this.renderer.xr.isPresenting&&this.sessionStart(e)}function Pm(n){console.warn(n.message),console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?')}fa.tempFakePose={transform:{orientation:new C.Quaternion,position:new C.Vector3}},Cn.prototype.previousFrameAnchors=new Set,Cn.prototype.anchorToObject3D=new Map,Cn.prototype.sessionStart=function(n){this.session=this.renderer.xr.getSession(),"requestHitTestSource"in this.session?n.space?this.session.requestHitTestSource(n).then((function(e){this.xrHitTestSource=e}).bind(this)).catch(Pm):n.profile&&this.session.requestHitTestSourceForTransientInput(n).then((function(e){this.xrHitTestSource=e,this.transient=!0}).bind(this)).catch(Pm):Pm({message:"No requestHitTestSource on the session."})},Cn.prototype.anchorFromLastHitTestResult=function(n,e){var t=this.lastHitTest;if(t){var i={object3D:n,offset:e};Array.from(this.anchorToObject3D.entries()).forEach((function(r){var s=r[1].object3D,o=r[0];s===n&&(this.anchorToObject3D.delete(o),o.delete())}).bind(this)),t.createAnchor&&t.createAnchor().then((function(r){this.anchorToObject3D.set(r,i)}).bind(this)).catch(function(r){console.warn(r.message),console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?')})}},Cn.prototype.doHit=function(n){if(this.renderer.xr.isPresenting){var e,t,i=this.renderer.xr.getReferenceSpace(),r=n.getViewerPose(i);return this.xrHitTestSource&&r?this.transient?(e=n.getHitTestResultsForTransientInput(this.xrHitTestSource)).length>0&&(t=e[0].results).length>0&&(this.lastHitTest=t[0],t[0].getPose(i)):(e=n.getHitTestResults(this.xrHitTestSource)).length>0&&(this.lastHitTest=e[0],e[0].getPose(i)):void 0}},Cn.updateAnchorPoses=function(n,e){var t=n.trackedAnchors||Cn.prototype.previousFrameAnchors;Cn.prototype.previousFrameAnchors.forEach(function(i){t.has(i)||Cn.prototype.anchorToObject3D.delete(i)}),t.forEach(function(i){var r,s,o,a;try{if(r=n.getPose(i.anchorSpace,e)){if(!(s=Cn.prototype.anchorToObject3D.get(i)))return;o=s.offset,a=s.object3D,fa(r,a,o)}}catch(l){console.error("while updating anchor poses:",l)}}),Cn.prototype.previousFrameAnchors=t},tt("ar-hit-test",{schema:{target:{type:"selector"},enabled:{default:!0},src:{default:"data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=",type:"map"},type:{default:"footprint",oneOf:["footprint","map"]},footprintDepth:{default:.1},mapSize:{type:"vec2",default:{x:.5,y:.5}}},sceneOnly:!0,init:function(){this.hitTest=null,this.imageDataArray=new Uint8ClampedArray(1048576),this.imageData=new ImageData(this.imageDataArray,512,512),this.textureCache=new Map,this.orthoCam=new C.OrthographicCamera,this.orthoCam.layers.set(21),this.textureTarget=new C.WebGLRenderTarget(512,512,{}),this.basicMaterial=new C.MeshBasicMaterial({color:0,side:C.DoubleSide}),this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.context.imageSmoothingEnabled=!1,this.canvas.width=512,this.canvas.height=512,this.canvasTexture=new C.CanvasTexture(this.canvas,{alpha:!0}),this.canvasTexture.flipY=!1;var n=this.el.getAttribute("webxr"),e=n.optionalFeatures;e.includes("hit-test")&&e.includes("anchors")||(e.push("hit-test"),e.push("anchors"),this.el.setAttribute("webxr",n)),this.el.sceneEl.renderer.xr.addEventListener("sessionend",(function(){this.hitTest=null}).bind(this)),this.el.sceneEl.addEventListener("enter-vr",(function(){if(this.el.is("ar-mode")){var t=this.el.sceneEl.renderer,i=this.session=t.xr.getSession();this.hasPosedOnce=!1,this.bboxMesh.visible=!1,Bl||(Bl=new Map),i.requestReferenceSpace("viewer").then((function(a){this.viewerHitTest=this.hitTest=new Cn(t,{space:a}),this.el.emit("ar-hit-test-start")}).bind(this));var r=this;this.el.sceneEl.addEventListener("controllersupdated",function(){var a=this.xrSession&&this.xrSession.inputSources;if(a){for(var l=0;l<a.length;++l)if(a[l].targetRayMode==="tracked-pointer"){r.hitTest=new Cn(t,{space:a[l].targetRaySpace}),Bl.set(a[l],r.hitTest),r.viewerHitTest&&typeof r.viewerHitTest.cancel=="function"&&(r.viewerHitTest.cancel(),r.viewerHitTest=null);break}}});var s="generic-touchscreen",o=new Cn(t,{profile:s});i.addEventListener("selectstart",(function(a){if(this.data.enabled===!0){var l=a.inputSource;this.bboxMesh.visible=!0,this.hasPosedOnce===!0&&(this.el.emit("ar-hit-test-select-start",{inputSource:l,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),l.profiles[0]===s?this.hitTest=o:(this.hitTest=Bl.get(l)||new Cn(t,{space:l.targetRaySpace}),Bl.set(l,this.hitTest)))}}).bind(this)),i.addEventListener("selectend",(function(a){if(this.hitTest&&this.data.enabled===!0){var l,c=a.inputSource;this.hasPosedOnce===!0&&(this.bboxMesh.visible=!1,this.data.target&&(l=this.data.target.object3D)&&(fa.tempFakePose.transform.position.copy(this.bboxMesh.position),fa.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion),fa(fa.tempFakePose,l,this.bboxOffset),l.visible=!0,this.hitTest.anchorFromLastHitTestResult(l,this.bboxOffset)),this.el.emit("ar-hit-test-select",{inputSource:c,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),this.hitTest=null)}else this.hitTest=null}).bind(this))}}).bind(this)),this.bboxOffset=new C.Vector3,this.update=this.update.bind(this),this.makeBBox()},update:function(){this.data.enabled===!1&&(this.hitTest=null,this.bboxMesh.visible=!1),this.data.target&&(this.data.target.object3D?(this.data.target.addEventListener("model-loaded",this.update),this.data.target.object3D.layers.enable(21),this.data.target.object3D.traverse(function(n){n.layers.enable(21)})):this.data.target.addEventListener("loaded",this.update,{once:!0})),this.bboxNeedsUpdate=!0},makeBBox:function(){var n=new C.PlaneGeometry(1,1),e=new C.MeshBasicMaterial({transparent:!0,color:16777215});n.rotateX(-Math.PI/2),n.rotateY(-Math.PI/2),this.bbox=new C.Box3,this.bboxMesh=new C.Mesh(n,e),this.el.setObject3D("ar-hit-test",this.bboxMesh),this.bboxMesh.visible=!1},updateFootprint:function(){var n,e,t,i=this.el.sceneEl.renderer,r=i.xr.enabled;this.bboxMesh.material.map=this.canvasTexture,this.bboxMesh.material.needsUpdate=!0,this.orthoCam.rotation.set(-Math.PI/2,0,-Math.PI/2),this.orthoCam.position.copy(this.bboxMesh.position),this.orthoCam.position.y-=this.bboxMesh.scale.y/2,this.orthoCam.near=.1,this.orthoCam.far=this.orthoCam.near+this.data.footprintDepth*this.bboxMesh.scale.y,this.orthoCam.position.y+=this.orthoCam.far,this.orthoCam.right=this.bboxMesh.scale.z/2,this.orthoCam.left=-this.bboxMesh.scale.z/2,this.orthoCam.top=this.bboxMesh.scale.x/2,this.orthoCam.bottom=-this.bboxMesh.scale.x/2,this.orthoCam.updateProjectionMatrix(),e=i.getRenderTarget(),i.setRenderTarget(this.textureTarget),i.xr.enabled=!1,t=this.el.object3D.background,this.el.object3D.overrideMaterial=this.basicMaterial,this.el.object3D.background=null,i.render(this.el.object3D,this.orthoCam),this.el.object3D.background=t,this.el.object3D.overrideMaterial=null,i.xr.enabled=r,i.setRenderTarget(e),i.readRenderTargetPixels(this.textureTarget,0,0,512,512,this.imageDataArray),this.context.putImageData(this.imageData,0,0),this.context.shadowColor="white",this.context.shadowBlur=10,this.context.drawImage(this.canvas,0,0),n=this.context.getImageData(0,0,512,512);for(var s=0;s<262144;s++)n.data[4*s+3]!==0&&n.data[4*s+3]!==255&&(n.data[4*s+3]=128);this.context.putImageData(n,0,0),this.canvasTexture.needsUpdate=!0},tick:function(){var n,e,t=this.el.sceneEl.frame,i=this.el.sceneEl.renderer;t&&Cn.updateAnchorPoses(t,i.xr.getReferenceSpace()),this.bboxNeedsUpdate&&(this.bboxNeedsUpdate=!1,this.data.target&&this.data.type!=="map"||(this.textureCache.has(this.data.src)?e=this.textureCache.get(this.data.src):(e=new C.TextureLoader().load(this.data.src),this.textureCache.set(this.data.src,e)),this.bboxMesh.material.map=e,this.bboxMesh.material.needsUpdate=!0),this.data.target&&this.data.target.object3D?(this.bbox.setFromObject(this.data.target.object3D),this.bbox.getCenter(this.bboxMesh.position),this.bbox.getSize(this.bboxMesh.scale),this.data.type==="footprint"&&(this.bboxMesh.scale.x*=1.04,this.bboxMesh.scale.z*=1.04,this.updateFootprint()),this.bboxMesh.position.y-=this.bboxMesh.scale.y/2,this.bboxOffset.copy(this.bboxMesh.position),this.bboxOffset.sub(this.data.target.object3D.position)):this.bboxMesh.scale.set(this.data.mapSize.x,1,this.data.mapSize.y)),this.hitTest&&(n=this.hitTest.doHit(t))&&(this.hasPosedOnce!==!0&&(this.hasPosedOnce=!0,this.el.emit("ar-hit-test-achieved")),this.bboxMesh.visible=!0,this.bboxMesh.position.copy(n.transform.position),this.bboxMesh.quaternion.copy(n.transform.orientation))}}),tt("background",{schema:{color:{type:"color",default:"black"},transparent:{default:!1}},sceneOnly:!0,update:function(){var n=this.data,e=this.el.object3D;n.transparent?e.background=null:e.background=new C.Color(n.color)},remove:function(){this.el.object3D.background=null}}),tt("debug",{schema:{default:!0},sceneOnly:!0});var zy="a-dialog-buttons-container",Um="a-dialog-button";function Hy(n,e){var t,i,r,s;return(t=document.createElement("div")).classList.add("a-modal"),t.setAttribute(vn,""),(i=document.createElement("div")).className="a-dialog",i.setAttribute(vn,""),t.appendChild(i),(r=document.createElement("div")).classList.add("a-dialog-text-container"),i.appendChild(r),(s=document.createElement("div")).classList.add("a-dialog-text"),s.innerHTML=n,r.appendChild(s),i.appendChild(e),t}tt("device-orientation-permission-ui",{schema:{enabled:{default:!0},deviceMotionMessage:{default:"This immersive website requires access to your device motion sensors."},httpsMessage:{default:"Access this site over HTTPS to enter VR mode and grant access to the device sensors."},denyButtonText:{default:"Deny"},allowButtonText:{default:"Allow"},cancelButtonText:{default:"Cancel"}},sceneOnly:!0,init:function(){var n=this;this.data.enabled&&(window.isSecureContext||this.showHTTPAlert(),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission?(this.onDeviceMotionDialogAllowClicked=this.onDeviceMotionDialogAllowClicked.bind(this),this.onDeviceMotionDialogDenyClicked=this.onDeviceMotionDialogDenyClicked.bind(this),DeviceOrientationEvent.requestPermission().then(function(){n.el.emit("deviceorientationpermissiongranted"),n.permissionGranted=!0}).catch(function(){var e,t,i,r,s,o,a,l;n.devicePermissionDialogEl=(e=n.data.denyButtonText,t=n.data.allowButtonText,i=n.data.deviceMotionMessage,r=n.onDeviceMotionDialogAllowClicked,s=n.onDeviceMotionDialogDenyClicked,(o=document.createElement("div")).classList.add(zy),(a=document.createElement("button")).classList.add(Um,"a-dialog-deny-button"),a.setAttribute(vn,""),a.innerHTML=e,o.appendChild(a),(l=document.createElement("button")).classList.add(Um,"a-dialog-allow-button"),l.setAttribute(vn,""),l.innerHTML=t,o.appendChild(l),l.addEventListener("click",function(c){c.stopPropagation(),r()}),a.addEventListener("click",function(c){c.stopPropagation(),s()}),Hy(i,o)),n.el.appendChild(n.devicePermissionDialogEl)})):this.permissionGranted=!0)},remove:function(){this.devicePermissionDialogEl&&this.el.removeChild(this.devicePermissionDialogEl)},onDeviceMotionDialogDenyClicked:function(){this.remove()},showHTTPAlert:function(){var n,e,t,i,r,s=this,o=(n=s.data.cancelButtonText,e=s.data.httpsMessage,t=function(){s.el.removeChild(o)},(i=document.createElement("div")).classList.add(zy),(r=document.createElement("button")).classList.add(Um,"a-dialog-ok-button"),r.setAttribute(vn,""),r.innerHTML=n,i.appendChild(r),r.addEventListener("click",function(a){a.stopPropagation(),t()}),Hy(e,i));this.el.appendChild(o)},onDeviceMotionDialogAllowClicked:function(){var n=this;this.el.emit("deviceorientationpermissionrequested"),DeviceOrientationEvent.requestPermission().then(function(e){e==="granted"?(n.el.emit("deviceorientationpermissiongranted"),n.permissionGranted=!0):n.el.emit("deviceorientationpermissionrejected"),n.remove()}).catch(console.error)}}),tt("embedded",{dependencies:["xr-mode-ui"],schema:{default:!0},sceneOnly:!0,update:function(){var n=this.el,e=n.querySelector(".a-enter-vr");this.data===!0?(e&&e.classList.add("embedded"),n.removeFullScreenStyles()):(e&&e.classList.remove("embedded"),n.addFullScreenStyles())}});var zF="https://unpkg.com/aframe-inspector@"+function(){var n=IS.split(".");return n[2]="x",n.join(".")}()+"/dist/aframe-inspector.min.js";tt("inspector",{schema:{url:{default:zF}},sceneOnly:!0,init:function(){this.firstPlay=!0,this.onKeydown=this.onKeydown.bind(this),this.onMessage=this.onMessage.bind(this),this.initOverlay(),window.addEventListener("keydown",this.onKeydown),window.addEventListener("message",this.onMessage)},play:function(){var n;this.firstPlay&&(n=Cc("inspector"))!=="false"&&n&&(this.openInspector(),this.firstPlay=!1)},initOverlay:function(){this.loadingMessageEl=document.createElement("div"),this.loadingMessageEl.classList.add("a-inspector-loader"),this.loadingMessageEl.innerHTML='Loading Inspector<span class="dots"><span>.</span><span>.</span><span>.</span></span>'},remove:function(){this.removeEventListeners()},onKeydown:function(n){n.keyCode===73&&(n.ctrlKey&&n.altKey||n.getModifierState("AltGraph"))&&this.openInspector()},showLoader:function(){document.body.appendChild(this.loadingMessageEl)},hideLoader:function(){document.body.removeChild(this.loadingMessageEl)},onMessage:function(n){n.data==="INJECT_AFRAME_INSPECTOR"&&this.openInspector()},openInspector:function(n){var e,t=this;AFRAME.INSPECTOR||AFRAME.inspectorInjected?AFRAME.INSPECTOR.open(n):(this.showLoader(),(e=document.createElement("script")).src=this.data.url,e.setAttribute("data-name","aframe-inspector"),e.setAttribute(vn,""),e.onload=function(){AFRAME.INSPECTOR.open(n),t.hideLoader(),t.removeEventListeners()},e.onerror=function(){t.loadingMessageEl.innerHTML="Error loading Inspector"},document.head.appendChild(e),AFRAME.inspectorInjected=!0)},removeEventListeners:function(){window.removeEventListener("keydown",this.onKeydown),window.removeEventListener("message",this.onMessage)}}),tt("fog",{schema:{color:{type:"color",default:"#000"},density:{default:25e-5},far:{default:1e3,min:0},near:{default:1,min:0},type:{default:"linear",oneOf:["linear","exponential"]}},sceneOnly:!0,update:function(){var n=this.data,e=this.el,t=this.el.object3D.fog;t&&n.type===t.name?Object.keys(this.schema).forEach(function(i){var r=n[i];i==="color"&&(r=new C.Color(r)),t[i]=r}):e.object3D.fog=function(i){var r;return(r=i.type==="exponential"?new C.FogExp2(i.color,i.density):new C.Fog(i.color,i.near,i.far)).name=i.type,r}(n)},remove:function(){var n=this.el;this.el.object3D.fog&&(n.object3D.fog=null)}}),tt("keyboard-shortcuts",{schema:{enterVR:{default:!0},exitVR:{default:!0}},sceneOnly:!0,init:function(){this.onKeyup=this.onKeyup.bind(this)},play:function(){window.addEventListener("keyup",this.onKeyup,!1)},pause:function(){window.removeEventListener("keyup",this.onKeyup)},onKeyup:function(n){var e=this.el;sv(n)&&(this.data.enterVR&&n.keyCode===70&&e.enterVR(),this.data.exitVR&&n.keyCode===27&&e.exitVR())}});var Dl=Bt("components:pool:warn");tt("pool",{schema:{container:{default:""},mixin:{default:""},size:{default:0},dynamic:{default:!1}},sceneOnly:!0,multiple:!0,initPool:function(){var n;for(this.availableEls=[],this.usedEls=[],this.data.mixin||Dl("No mixin provided for pool component."),this.data.container&&(this.container=document.querySelector(this.data.container),this.container||Dl("Container "+this.data.container+" not found.")),this.container=this.container||this.el,n=0;n<this.data.size;++n)this.createEntity()},update:function(n){var e=this.data;n.mixin===e.mixin&&n.size===e.size||this.initPool()},createEntity:function(){var n;(n=document.createElement("a-entity")).play=this.wrapPlay(n.play),n.setAttribute("mixin",this.data.mixin),n.object3D.visible=!1,n.pause(),this.container.appendChild(n),this.availableEls.push(n);var e=this.usedEls;n.addEventListener("loaded",function(){e.indexOf(n)===-1&&(n.object3DParent=n.object3D.parent,n.object3D.parent.remove(n.object3D))})},wrapPlay:function(n){var e=this.usedEls;return function(){e.indexOf(this)!==-1&&n.call(this)}},requestEntity:function(){var n;if(this.availableEls.length===0){if(this.data.dynamic===!1)return void Dl("Requested entity from empty pool: "+this.attrName);Dl("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: "+this.attrName),this.createEntity()}return n=this.availableEls.shift(),this.usedEls.push(n),n.object3DParent&&(n.object3DParent.add(n.object3D),this.updateRaycasters()),n.object3D.visible=!0,n},returnEntity:function(n){var e=this.usedEls.indexOf(n);if(e!==-1)return this.usedEls.splice(e,1),this.availableEls.push(n),n.object3DParent=n.object3D.parent,n.object3D.parent.remove(n.object3D),this.updateRaycasters(),n.object3D.visible=!1,n.pause(),n;Dl("The returned entity was not previously pooled from "+this.attrName)},updateRaycasters:function(){document.querySelectorAll("[raycaster]").forEach(function(n){n.components.raycaster.setDirty()})}}),tt("real-world-meshing",{schema:{filterLabels:{type:"array"},meshesEnabled:{default:!0},meshMixin:{default:!0},planesEnabled:{default:!0},planeMixin:{default:""}},sceneOnly:!0,init:function(){var n=this.el.getAttribute("webxr"),e=n.requiredFeatures;e.indexOf("mesh-detection")===-1&&(e.push("mesh-detection"),this.el.setAttribute("webxr",n)),e.indexOf("plane-detection")===-1&&(e.push("plane-detection"),this.el.setAttribute("webxr",n)),this.meshEntities=[],this.initWorldMeshEntity=this.initWorldMeshEntity.bind(this)},tick:function(){this.el.is("ar-mode")&&(this.detectMeshes(),this.updateMeshes())},detectMeshes:function(){var n,e,t,i=this.data,r=this.el,s=this.meshEntities,o=!1,a=[],l=this.data.filterLabels;n=(t=r.frame).detectedMeshes,e=t.detectedPlanes;for(var c=0;c<s.length;c++)s[c].present=!1;if(i.meshesEnabled){for(var h of n.values())if(!l.length||l.indexOf(h.semanticLabel)!==-1){for(c=0;c<s.length;c++)if(h===s[c].mesh){o=!0,s[c].present=!0,s[c].lastChangedTime<h.lastChangedTime&&this.updateMeshGeometry(s[c].el,h),s[c].lastChangedTime=h.lastChangedTime;break}o||a.push(h),o=!1}}if(i.planesEnabled){for(h of e.values())if(!l.length||l.indexOf(h.semanticLabel)!==-1){for(c=0;c<s.length;c++)if(h===s[c].mesh){o=!0,s[c].present=!0,s[c].lastChangedTime<h.lastChangedTime&&this.updateMeshGeometry(s[c].el,h),s[c].lastChangedTime=h.lastChangedTime;break}o||a.push(h),o=!1}}this.deleteMeshes(),this.createNewMeshes(a)},updateMeshes:function(){var n=new C.Matrix4;return function(){for(var e,t,i,r=this.el,s=r.frame,o=this.meshEntities,a=r.renderer.xr.getReferenceSpace(),l=0;l<o.length;l++)i=o[l].mesh.meshSpace||o[l].mesh.planeSpace,e=s.getPose(i,a),(t=o[l].el).hasLoaded&&(n.fromArray(e.transform.matrix),n.decompose(t.object3D.position,t.object3D.quaternion,t.object3D.scale))}}(),deleteMeshes:function(){for(var n=this.meshEntities,e=[],t=0;t<n.length;t++)n[t].present?e.push(n[t]):this.el.removeChild(n[t]);this.meshEntities=e},createNewMeshes:function(n){for(var e,t=0;t<n.length;t++)e=document.createElement("a-entity"),this.meshEntities.push({mesh:n[t],el:e}),e.addEventListener("loaded",this.initWorldMeshEntity),this.el.appendChild(e)},initMeshGeometry:function(n){var e,t,i;if(n instanceof XRPlane){t=new C.Shape,i=n.polygon;for(var r=0;r<i.length;++r)r===0?t.moveTo(i[r].x,i[r].z):t.lineTo(i[r].x,i[r].z);return(e=new C.ShapeGeometry(t)).rotateX(Math.PI/2),e}return(e=new C.BufferGeometry).setAttribute("position",new C.BufferAttribute(n.vertices,3)),e.setIndex(new C.BufferAttribute(n.indices,1)),e},initWorldMeshEntity:function(n){for(var e,t,i,r=n.target,s=this.meshEntities,o=0;o<s.length;o++)if(s[o].el===r){i=s[o];break}e=this.initMeshGeometry(i.mesh),t=new C.Mesh(e,new C.MeshBasicMaterial({color:16777215*Math.random(),side:C.DoubleSide})),r.setObject3D("mesh",t),i.mesh instanceof XRPlane&&this.data.planeMixin?r.setAttribute("mixin",this.data.planeMixin):this.data.meshMixin&&r.setAttribute("mixin",this.data.meshMixin),r.setAttribute("data-world-mesh",i.mesh.semanticLabel)},updateMeshGeometry:function(n,e){var t=n.getObject3D("mesh");t.geometry.dispose(),t.geometry=this.initMeshGeometry(e)}}),tt("reflection",{schema:{directionalLight:{type:"selector"}},sceneOnly:!0,init:function(){var n=this;this.cubeRenderTarget=new C.WebGLCubeRenderTarget(16),this.cubeCamera=new C.CubeCamera(.1,1e3,this.cubeRenderTarget),this.lightingEstimationTexture=new C.WebGLCubeRenderTarget(16).texture,this.needsVREnvironmentUpdate=!0;var e=this.el.getAttribute("webxr"),t=e.optionalFeatures;t.includes("light-estimation")||(t.push("light-estimation"),this.el.setAttribute("webxr",e)),this.el.addEventListener("enter-vr",function(){n.el.is("ar-mode")&&n.el.renderer.xr.getSession().requestLightProbe&&n.startLightProbe()}),this.el.addEventListener("exit-vr",function(){n.xrLightProbe&&n.stopLightProbe()}),this.el.object3D.environment=this.cubeRenderTarget.texture},stopLightProbe:function(){this.xrLightProbe=null,this.probeLight&&(this.probeLight.components.light.light.intensity=0),this.needsVREnvironmentUpdate=!0,this.el.object3D.environment=this.cubeRenderTarget.texture},startLightProbe:function(){this.needsLightProbeUpdate=!0},setupLightProbe:function(){var n=this.el.renderer,e=n.xr.getSession(),t=this,i=n.getContext();if(!this.probeLight){var r=document.createElement("a-light");r.setAttribute("type","probe"),r.setAttribute("intensity",0),this.el.appendChild(r),this.probeLight=r}switch(e.preferredReflectionFormat){case"srgba8":i.getExtension("EXT_sRGB");break;case"rgba16f":i.getExtension("OES_texture_half_float")}this.glBinding=new XRWebGLBinding(e,i),i.getExtension("EXT_sRGB"),i.getExtension("OES_texture_half_float"),e.requestLightProbe().then(function(s){t.xrLightProbe=s,s.addEventListener("reflectionchange",t.updateXRCubeMap.bind(t))}).catch(function(s){console.warn("Lighting estimation not supported: "+s.message),console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?')})},updateXRCubeMap:function(){var n=this.el.renderer,e=this.glBinding.getReflectionCubeMap(this.xrLightProbe);e&&(n.properties.get(this.lightingEstimationTexture).__webglTexture=e,this.lightingEstimationTexture.needsPMREMUpdate=!0,this.el.object3D.environment=this.lightingEstimationTexture)},tick:function(){var n=this.el.object3D,e=this.el.renderer,t=this.el.frame;if(t&&this.xrLightProbe){var i=t.getLightEstimate(this.xrLightProbe);i&&function(r,s,o,a){var l=Math.max(r.primaryLightIntensity.x,Math.max(r.primaryLightIntensity.y,r.primaryLightIntensity.z));s.sh.fromArray(r.sphericalHarmonicsCoefficients),s.intensity=3.14,o&&(o.color.setRGB(r.primaryLightIntensity.x/l,r.primaryLightIntensity.y/l,r.primaryLightIntensity.z/l),o.intensity=l,a.copy(r.primaryLightDirection))}(i,this.probeLight.components.light.light,this.data.directionalLight&&this.data.directionalLight.components.light.light,this.data.directionalLight&&this.data.directionalLight.object3D.position)}this.needsVREnvironmentUpdate&&(n.environment=null,this.needsVREnvironmentUpdate=!1,this.cubeCamera.position.set(0,1.6,0),this.cubeCamera.update(e,n),n.environment=this.cubeRenderTarget.texture),this.needsLightProbeUpdate&&t&&(this.setupLightProbe(),this.needsLightProbeUpdate=!1)},remove:function(){this.el.object3D.environment=null,this.probeLight&&this.el.removeChild(this.probeLight)}});var HF=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join(`
`),VF=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join(`
`),QF=(tt("screenshot",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"}},sceneOnly:!0,setup:function(){var n=this.el;if(!this.canvas){var e=n.renderer.getContext();e&&(this.cubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.material=new C.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:HF,fragmentShader:VF,side:C.DoubleSide}),this.quad=new C.Mesh(new C.PlaneGeometry(1,1),this.material),this.quad.visible=!1,this.camera=new C.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4),this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),n.object3D.add(this.quad),this.onKeyDown=this.onKeyDown.bind(this))}},getRenderTarget:function(n,e){return new C.WebGLRenderTarget(n,e,{colorSpace:this.el.sceneEl.renderer.outputColorSpace,minFilter:C.LinearFilter,magFilter:C.LinearFilter,wrapS:C.ClampToEdgeWrapping,wrapT:C.ClampToEdgeWrapping,format:C.RGBAFormat,type:C.UnsignedByteType})},resize:function(n,e){this.quad.scale.set(n,e,1),this.camera.left=-1*n/2,this.camera.right=n/2,this.camera.top=e/2,this.camera.bottom=-1*e/2,this.camera.updateProjectionMatrix(),this.canvas.width=n,this.canvas.height=e},play:function(){window.addEventListener("keydown",this.onKeyDown)},onKeyDown:function(n){var e=n.keyCode===83&&n.ctrlKey&&n.altKey;if(this.data&&e){var t=n.shiftKey?"equirectangular":"perspective";this.capture(t)}},setCapture:function(n){var e,t,i,r,s=this.el;return n==="perspective"?(this.quad.visible=!1,t=this.data.camera&&this.data.camera.components.camera.camera||s.camera,e={width:this.data.width,height:this.data.height}):(t=this.camera,r=new C.WebGLCubeRenderTarget(Math.min(this.cubeMapSize,2048),{format:C.RGBFormat,generateMipmaps:!0,minFilter:C.LinearMipmapLinearFilter,colorSpace:C.SRGBColorSpace}),i=new C.CubeCamera(s.camera.near,s.camera.far,r),s.camera.getWorldPosition(i.position),s.camera.getWorldQuaternion(i.quaternion),i.update(s.renderer,s.object3D),this.quad.material.uniforms.map.value=i.renderTarget.texture,e={width:this.data.width,height:this.data.height},this.quad.visible=!0),{camera:t,size:e,projection:n}},capture:function(n){var e,t=this.el.renderer.xr.enabled,i=this.el.renderer;this.setup(),i.xr.enabled=!1,e=this.setCapture(n),this.renderCapture(e.camera,e.size,e.projection),this.saveCapture(),i.xr.enabled=t},getCanvas:function(n){var e=this.el.renderer.xr.enabled,t=this.el.renderer;this.setup();var i=this.setCapture(n);return t.xr.enabled=!1,this.renderCapture(i.camera,i.size,i.projection),t.xr.enabled=e,this.canvas},renderCapture:function(n,e,t){var i,r,s,o=this.el.renderer.autoClear,a=this.el,l=a.renderer;r=this.getRenderTarget(e.width,e.height),s=new Uint8Array(4*e.width*e.height),this.resize(e.width,e.height),l.autoClear=!0,l.clear(),l.setRenderTarget(r),l.render(a.object3D,n),l.autoClear=o,l.readRenderTargetPixels(r,0,0,e.width,e.height,s),l.setRenderTarget(null),t==="perspective"&&(s=this.flipPixelsVertically(s,e.width,e.height)),i=new ImageData(new Uint8ClampedArray(s),e.width,e.height),this.quad.visible=!1,this.ctx.putImageData(i,0,0)},flipPixelsVertically:function(n,e,t){for(var i=n.slice(0),r=0;r<e;++r)for(var s=0;s<t;++s)i[4*r+s*e*4]=n[4*r+(t-s)*e*4],i[4*r+1+s*e*4]=n[4*r+1+(t-s)*e*4],i[4*r+2+s*e*4]=n[4*r+2+(t-s)*e*4],i[4*r+3+s*e*4]=n[4*r+3+(t-s)*e*4];return i},saveCapture:function(){this.canvas.toBlob(function(n){var e="screenshot-"+document.title.toLowerCase()+"-"+Date.now()+".png",t=document.createElement("a"),i=URL.createObjectURL(n);t.href=i,t.setAttribute("download",e),t.innerHTML="downloading...",t.style.display="none",document.body.appendChild(t),setTimeout(function(){t.click(),document.body.removeChild(t)},1)},"image/png")}}),nt(282)),WF=nt.n(QF),XF=(nt(3729),nt(8132),window.aframeStats),Vy="a-hidden",qF=window.threeStats;tt("stats",{schema:{default:!0},sceneOnly:!0,init:function(){var n=this.el;Cc("stats")!=="false"&&(this.stats=function(e){var t=new qF(e.renderer),i=new XF(e),r=e.isMobile?[]:[t,i];return new(WF())({css:[],values:{fps:{caption:"fps",below:30}},groups:[{caption:"Framerate",values:["fps","raf"]}],plugins:r})}(n),this.statsEl=document.querySelector(".rs-base"),this.hideBound=this.hide.bind(this),this.showBound=this.show.bind(this),n.addEventListener("enter-vr",this.hideBound),n.addEventListener("exit-vr",this.showBound))},update:function(){if(this.stats)return this.data?this.show():this.hide()},remove:function(){this.el.removeEventListener("enter-vr",this.hideBound),this.el.removeEventListener("exit-vr",this.showBound),this.statsEl&&this.statsEl.parentNode.removeChild(this.statsEl)},tick:function(){var n=this.stats;n&&(n("rAF").tick(),n("FPS").frame(),n().update())},hide:function(){this.statsEl.classList.add(Vy)},show:function(){this.statsEl.classList.remove(Vy)}});var to="a-hidden";function Qy(n){n.addEventListener("touchstart",function(){n.classList.remove("resethover")},{passive:!0}),n.addEventListener("touchend",function(){n.classList.add("resethover")},{passive:!0})}tt("xr-mode-ui",{dependencies:["canvas"],schema:{enabled:{default:!0},enterVRButton:{default:""},enterVREnabled:{default:!0},enterARButton:{default:""},enterAREnabled:{default:!0},XRMode:{default:"vr",oneOf:["vr","ar","xr"]}},sceneOnly:!0,init:function(){var n=this,e=this.el;Cc("ui")!=="false"&&(this.insideLoader=!1,this.enterVREl=null,this.enterAREl=null,this.orientationModalEl=null,this.bindMethods(),e.addEventListener("enter-vr",this.updateEnterInterfaces),e.addEventListener("exit-vr",this.updateEnterInterfaces),e.addEventListener("update-vr-devices",this.updateEnterInterfaces),window.addEventListener("message",function(t){t.data.type==="loaderReady"&&(n.insideLoader=!0,n.remove())}),window.addEventListener("orientationchange",this.toggleOrientationModalIfNeeded))},bindMethods:function(){this.onEnterVRButtonClick=this.onEnterVRButtonClick.bind(this),this.onEnterARButtonClick=this.onEnterARButtonClick.bind(this),this.onModalClick=this.onModalClick.bind(this),this.toggleOrientationModalIfNeeded=this.toggleOrientationModalIfNeeded.bind(this),this.updateEnterInterfaces=this.updateEnterInterfaces.bind(this)},onModalClick:function(){this.el.exitVR()},onEnterVRButtonClick:function(){this.el.enterVR()},onEnterARButtonClick:function(){this.el.enterAR()},update:function(){var n,e,t,i=this.data,r=this.el;if(!i.enabled||this.insideLoader||Cc("ui")==="false")return this.remove();this.enterVREl||this.enterAREl||this.orientationModalEl||(this.enterVREl||!i.enterVREnabled||i.XRMode!=="xr"&&i.XRMode!=="vr"||(i.enterVRButton?(this.enterVREl=document.querySelector(i.enterVRButton),this.enterVREl.addEventListener("click",this.onEnterVRButtonClick)):(this.enterVREl=(n=this.onEnterVRButtonClick,(t=document.createElement("div")).classList.add("a-enter-vr"),t.setAttribute(vn,""),(e=document.createElement("button")).className="a-enter-vr-button",e.setAttribute("title","Enter VR mode with a headset or fullscreen without"),e.setAttribute(vn,""),Ms()&&Qy(e),t.appendChild(e),e.addEventListener("click",function(s){n(),s.stopPropagation()}),t),r.appendChild(this.enterVREl))),this.enterAREl||!i.enterAREnabled||i.XRMode!=="xr"&&i.XRMode!=="ar"||(i.enterARButton?(this.enterAREl=document.querySelector(i.enterARButton),this.enterAREl.addEventListener("click",this.onEnterARButtonClick)):(this.enterAREl=function(s,o){var a,l;return(l=document.createElement("div")).classList.add("a-enter-ar"),o&&l.classList.add("xr"),l.setAttribute(vn,""),(a=document.createElement("button")).className="a-enter-ar-button",a.setAttribute("title","Enter AR mode with a headset or handheld device."),a.setAttribute(vn,""),Ms()&&Qy(a),l.appendChild(a),a.addEventListener("click",function(c){s(),c.stopPropagation()}),l}(this.onEnterARButtonClick,i.XRMode==="xr"),r.appendChild(this.enterAREl))),this.orientationModalEl=function(s){var o=document.createElement("div");o.className="a-orientation-modal",o.classList.add(to),o.setAttribute(vn,"");var a=document.createElement("button");return a.setAttribute(vn,""),a.innerHTML="Exit VR",a.addEventListener("click",s),o.appendChild(a),o}(this.onModalClick),r.appendChild(this.orientationModalEl),this.updateEnterInterfaces())},remove:function(){[this.enterVREl,this.enterAREl,this.orientationModalEl].forEach(function(n){n&&n.parentNode&&n.parentNode.removeChild(n)}),this.enterVREl=void 0,this.enterAREl=void 0,this.orientationModalEl=void 0},updateEnterInterfaces:function(){this.toggleEnterVRButtonIfNeeded(),this.toggleEnterARButtonIfNeeded(),this.toggleOrientationModalIfNeeded()},toggleEnterVRButtonIfNeeded:function(){var n=this.el;this.enterVREl&&(n.is("vr-mode")||(n.isMobile||Q0())&&!YA()?this.enterVREl.classList.add(to):(YA()||this.enterVREl.classList.add("fullscreen"),this.enterVREl.classList.remove(to),n.enterVR(!1,!0)))},toggleEnterARButtonIfNeeded:function(){var n=this.el;this.enterAREl&&(n.is("vr-mode")||!V0()?this.enterAREl.classList.add(to):(this.enterAREl.classList.remove(to),n.enterVR(!0,!0)))},toggleOrientationModalIfNeeded:function(){var n=this.el,e=this.orientationModalEl;e&&n.isMobile&&(!rS()&&n.is("vr-mode")?e.classList.remove(to):e.classList.add(to))}}),Nn("box",{schema:{depth:{default:1,min:0},height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"},segmentsDepth:{default:1,min:1,max:20,type:"int"}},init:function(n){this.geometry=new C.BoxGeometry(n.width,n.height,n.depth,n.segmentsWidth,n.segmentsHeight,n.segmentsDepth)}});var Wy=C.MathUtils.degToRad;Nn("circle",{schema:{radius:{default:1,min:0},segments:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(n){this.geometry=new C.CircleGeometry(n.radius,n.segments,Wy(n.thetaStart),Wy(n.thetaLength))}});var Xy=C.MathUtils.degToRad;Nn("cone",{schema:{height:{default:1,min:0},openEnded:{default:!1},radiusBottom:{default:1,min:0},radiusTop:{default:.01,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(n){this.geometry=new C.CylinderGeometry(n.radiusTop,n.radiusBottom,n.height,n.segmentsRadial,n.segmentsHeight,n.openEnded,Xy(n.thetaStart),Xy(n.thetaLength))}});var qy=C.MathUtils.degToRad;Nn("cylinder",{schema:{height:{default:1,min:0},openEnded:{default:!1},radius:{default:1,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(n){this.geometry=new C.CylinderGeometry(n.radius,n.radius,n.height,n.segmentsRadial,n.segmentsHeight,n.openEnded,qy(n.thetaStart),qy(n.thetaLength))}}),Nn("dodecahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(n){this.geometry=new C.DodecahedronGeometry(n.radius,n.detail)}}),Nn("icosahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(n){this.geometry=new C.IcosahedronGeometry(n.radius,n.detail)}}),Nn("octahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(n){this.geometry=new C.OctahedronGeometry(n.radius,n.detail)}}),Nn("plane",{schema:{height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"}},init:function(n){this.geometry=new C.PlaneGeometry(n.width,n.height,n.segmentsWidth,n.segmentsHeight)}});var Yy=C.MathUtils.degToRad;Nn("ring",{schema:{radiusInner:{default:.8,min:0},radiusOuter:{default:1.2,min:0},segmentsPhi:{default:10,min:1,type:"int"},segmentsTheta:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(n){this.geometry=new C.RingGeometry(n.radiusInner,n.radiusOuter,n.segmentsTheta,n.segmentsPhi,Yy(n.thetaStart),Yy(n.thetaLength))}});var au=C.MathUtils.degToRad;Nn("sphere",{schema:{radius:{default:1,min:0},phiLength:{default:360},phiStart:{default:0,min:0},thetaLength:{default:180,min:0},thetaStart:{default:0},segmentsHeight:{default:18,min:2,type:"int"},segmentsWidth:{default:36,min:3,type:"int"}},init:function(n){this.geometry=new C.SphereGeometry(n.radius,n.segmentsWidth,n.segmentsHeight,au(n.phiStart),au(n.phiLength),au(n.thetaStart),au(n.thetaLength))}}),Nn("tetrahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(n){this.geometry=new C.TetrahedronGeometry(n.radius,n.detail)}});var YF=C.MathUtils.degToRad;Nn("torus",{schema:{arc:{default:360},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:36,min:2,type:"int"},segmentsTubular:{default:32,min:3,type:"int"}},init:function(n){this.geometry=new C.TorusGeometry(n.radius,2*n.radiusTubular,n.segmentsRadial,n.segmentsTubular,YF(n.arc))}}),Nn("torusKnot",{schema:{p:{default:2,min:1},q:{default:3,min:1},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:8,min:3,type:"int"},segmentsTubular:{default:100,min:3,type:"int"}},init:function(n){this.geometry=new C.TorusKnotGeometry(n.radius,2*n.radiusTubular,n.segmentsTubular,n.segmentsRadial,n.p,n.q)}});var lu=new C.Quaternion,jF=new C.Vector3(0,0,1),Pl=new C.Vector2,jy=new C.Vector2,cu=new C.Vector2;function $y(n,e){return e.color.set(n.color),e.fog=n.fog,e.wireframe=n.wireframe,e.toneMapped=n.toneMapped,e.wireframeLinewidth=n.wireframeLinewidth,e}function Ky(n,e){return e.color.set(n.color),e.emissive.set(n.emissive),e.emissiveIntensity=n.emissiveIntensity,e.fog=n.fog,e.metalness=n.metalness,e.roughness=n.roughness,e.wireframe=n.wireframe,e.wireframeLinewidth=n.wireframeLinewidth,n.normalMap&&(e.normalScale=n.normalScale),n.ambientOcclusionMap&&(e.aoMapIntensity=n.ambientOcclusionMapIntensity),n.displacementMap&&(e.displacementScale=n.displacementScale,e.displacementBias=n.displacementBias),e}function Jy(n,e){switch(e.color.set(n.color),e.specular.set(n.specular),e.emissive.set(n.emissive),e.emissiveIntensity=n.emissiveIntensity,e.fog=n.fog,e.transparent=n.transparent,e.wireframe=n.wireframe,e.wireframeLinewidth=n.wireframeLinewidth,e.shininess=n.shininess,e.flatShading=n.flatShading,e.wireframe=n.wireframe,e.wireframeLinewidth=n.wireframeLinewidth,e.reflectivity=n.reflectivity,e.refractionRatio=n.refractionRatio,n.combine){case"mix":e.combine=C.MixOperation;break;case"multiply":e.combine=C.MultiplyOperation;break;case"add":e.combine=C.AddOperation}return n.normalMap&&(e.normalScale=n.normalScale),n.ambientOcclusionMap&&(e.aoMapIntensity=n.ambientOcclusionMapIntensity),n.bumpMap&&(e.bumpScale=n.bumpMapScale),n.displacementMap&&(e.displacementScale=n.displacementScale,e.displacementBias=n.displacementBias),e}Nn("triangle",{schema:{vertexA:{type:"vec3",default:{x:0,y:.5,z:0}},vertexB:{type:"vec3",default:{x:-.5,y:-.5,z:0}},vertexC:{type:"vec3",default:{x:.5,y:-.5,z:0}}},init:function(n){var e,t,i,r,s,o,a,l,c;(i=new C.Triangle).a.set(n.vertexA.x,n.vertexA.y,n.vertexA.z),i.b.set(n.vertexB.x,n.vertexB.y,n.vertexB.z),i.c.set(n.vertexC.x,n.vertexC.y,n.vertexC.z),t=i.getNormal(new C.Vector3),lu.setFromUnitVectors(t,jF),r=i.a.clone().applyQuaternion(lu),s=i.b.clone().applyQuaternion(lu),o=i.c.clone().applyQuaternion(lu),Pl.set(Math.min(r.x,s.x,o.x),Math.min(r.y,s.y,o.y)),jy.set(Math.max(r.x,s.x,o.x),Math.max(r.y,s.y,o.y)),cu.set(0,0).subVectors(jy,Pl),r=new C.Vector2().subVectors(r,Pl).divide(cu),s=new C.Vector2().subVectors(s,Pl).divide(cu),o=new C.Vector2().subVectors(o,Pl).divide(cu),e=this.geometry=new C.BufferGeometry,a=[i.a.x,i.a.y,i.a.z,i.b.x,i.b.y,i.b.z,i.c.x,i.c.y,i.c.z],l=[t.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,t.z],c=[r.x,r.y,s.x,s.y,o.x,o.y],e.setAttribute("position",new C.Float32BufferAttribute(a,3)),e.setAttribute("normal",new C.Float32BufferAttribute(l,3)),e.setAttribute("uv",new C.Float32BufferAttribute(c,2))}}),hs("flat",{schema:{color:{type:"color"},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},wireframe:{default:!1},wireframeLinewidth:{default:2},toneMapped:{default:!0}},init:function(n){this.materialData={color:new C.Color},$y(n,this.materialData),this.material=new C.MeshBasicMaterial(this.materialData)},update:function(n){this.updateMaterial(n),Wu(this,n)},updateMaterial:function(n){var e;for(e in $y(n,this.materialData),this.materialData)this.material[e]=this.materialData[e]}}),hs("standard",{schema:{ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},ambientOcclusionTextureOffset:{type:"vec2"},ambientOcclusionTextureRepeat:{type:"vec2",default:{x:1,y:1}},color:{type:"color"},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},emissive:{type:"color",default:"#000"},emissiveIntensity:{default:1},envMap:{default:""},fog:{default:!0},metalness:{default:0,min:0,max:1},metalnessMap:{type:"map"},metalnessTextureOffset:{type:"vec2"},metalnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},roughness:{default:.5,min:0,max:1},roughnessMap:{type:"map"},roughnessTextureOffset:{type:"vec2"},roughnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},sphericalEnvMap:{type:"map"},src:{type:"map"},wireframe:{default:!1},wireframeLinewidth:{default:2}},init:function(n){this.materialData={color:new C.Color,emissive:new C.Color},Ky(n,this.materialData),this.material=new C.MeshStandardMaterial(this.materialData)},update:function(n){this.updateMaterial(n),Wu(this,n),Vi("normal",this,n),Vi("displacement",this,n),Vi("ambientOcclusion",this,n),Vi("metalness",this,n),Vi("roughness",this,n),$A(this,n)},updateMaterial:function(n){var e,t=this.material;for(e in Ky(n,this.materialData),this.materialData)t[e]=this.materialData[e]}}),hs("phong",{schema:{color:{type:"color"},emissive:{type:"color",default:"black"},emissiveIntensity:{default:1},specular:{type:"color",default:"#111111"},transparent:{default:!1},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},envMap:{default:""},sphericalEnvMap:{type:"map"},shininess:{default:30},flatShading:{default:!1},wireframe:{default:!1},wireframeLinewidth:{default:2},combine:{oneOF:["multiply","mix","add"],default:"mix"},reflectivity:{default:.9},refractionRatio:{default:.98},refract:{default:!1},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},bumpMap:{type:"map"},bumpMapScale:{default:1},bumpTextureOffset:{type:"vec2"},bumpTextureRepeat:{type:"vec2",default:{x:1,y:1}}},init:function(n){this.materialData={color:new C.Color,specular:new C.Color,emissive:new C.Color},Jy(n,this.materialData),this.material=new C.MeshPhongMaterial(this.materialData);var e=this.el.sceneEl;Object.defineProperty(this.material,"envMap",{get:function(){return this._envMap||e.object3D.environment},set:function(t){this._envMap=t}})},update:function(n){this.updateMaterial(n),Wu(this,n),Vi("normal",this,n),Vi("displacement",this,n),Vi("ambientOcclusion",this,n),Vi("bump",this,n),$A(this,n)},updateMaterial:function(n){var e;for(e in Jy(n,this.materialData),this.materialData)this.material[e]=this.materialData[e]}}),hs("sdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},opacity:{type:"number",is:"uniform",default:1}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float contour(float width, float value) {","  return smoothstep(0.5 - value, 0.5 + value, width);","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec2 uv = vUV;","  vec4 texColor = texture(map, uv);","  float dist = texColor.a;","  float width = fwidth(dist);","  float alpha = contour(dist, width);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * dist;","  }","  if (isBigEnough <= BIG_ENOUGH) {","    vec4 box = vec4 (uv - duv, uv + duv);","    alpha = (alpha + 0.5 * (","      contour(texture(map, box.xy).a, width)","      + contour(texture(map, box.zw).a, width)","      + contour(texture(map, box.xw).a, width)","      + contour(texture(map, box.zy).a, width)","    )) / 3.0;","  }","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color, opacity * alpha);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join(`
`),init:function(){return this.uniforms=this.initUniforms(),C.UniformsUtils&&(this.uniforms=C.UniformsUtils.merge([C.UniformsLib.fog,this.uniforms])),this.material=new C.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}}),hs("msdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},negate:{type:"boolean",is:"uniform",default:!0},opacity:{type:"number",is:"uniform",default:1}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join(`
`),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform bool negate;","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float median(float r, float g, float b) {","  return max(min(r, g), min(max(r, g), b));","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec3 sampleColor = texture(map, vUV).rgb;","  if (negate) { sampleColor = 1.0 - sampleColor; }","  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;","  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  // Do modified alpha test.","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);","  }","  // Do modified alpha test.","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color.xyz, alpha * opacity);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join(`
`),init:function(){return this.uniforms=this.initUniforms(),C.UniformsUtils&&(this.uniforms=C.UniformsUtils.merge([C.UniformsLib.fog,this.uniforms])),this.material=new C.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}}),hs("shadow",{schema:{opacity:{default:.5},transparent:{default:!0},alphaToCoverage:{default:!0}},init:function(n){this.material=new C.ShadowMaterial},update:function(n){this.material.opacity=n.opacity,this.material.alphaToCoverage=n.alphaToCoverage,this.material.transparent=n.transparent}});var Zy="data-aframe-default-camera";function e_(n){var e=n.primitive,t=Ss[e]&&Ss[e].Geometry,i=new t;if(!t)throw new Error("Unknown geometry `"+e+"`");return i.init(n),i.geometry}gi("camera",{init:function(){this.activeCameraEl=null,this.render=this.render.bind(this),this.unwrapRender=this.unwrapRender.bind(this),this.wrapRender=this.wrapRender.bind(this),this.initialCameraFound=!1,this.numUserCameras=0,this.numUserCamerasChecked=0,this.setupInitialCamera()},setupInitialCamera:function(){var n,e,t=this.sceneEl,i=this;if(!t.camera||t.camera.el.getAttribute("camera").spectator)if((n=t.querySelectorAll("a-camera, :not(a-mixin)[camera]")).length)for(this.numUserCameras=n.length,e=0;e<n.length;e++)n[e].addEventListener("object3dset",function(r){r.detail.type==="camera"&&i.checkUserCamera(this)}),n[e].isANode?n[e].load():n[e].addEventListener("nodeready",function(){this.load()});else this.createDefaultCamera();else t.emit("cameraready",{cameraEl:t.camera.el})},checkUserCamera:function(n){var e,t=this.el.sceneEl;this.numUserCamerasChecked++,this.initialCameraFound||((e=n.getAttribute("camera")).active&&!e.spectator?(this.initialCameraFound=!0,t.camera=n.getObject3D("camera"),t.emit("cameraready",{cameraEl:n})):this.numUserCamerasChecked===this.numUserCameras&&this.createDefaultCamera())},createDefaultCamera:function(){var n,e=this.sceneEl;(n=document.createElement("a-entity")).setAttribute("camera",{active:!0}),n.setAttribute("position",{x:0,y:1.6,z:0}),n.setAttribute("wasd-controls",""),n.setAttribute("look-controls",""),n.setAttribute(vn,""),n.addEventListener("object3dset",function(t){t.detail.type==="camera"&&(e.camera=t.detail.object,e.emit("cameraready",{cameraEl:n}))}),e.appendChild(n)},disableActiveCamera:function(){var n;(n=this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"))[n.length-1].setAttribute("camera","active",!0)},setActiveCamera:function(n){var e,t,i,r,s=this.activeCameraEl,o=this.sceneEl;if((r=n.getObject3D("camera"))&&n!==this.activeCameraEl){var a=o.querySelector("["+Zy+"]");for(n!==(a&&a.querySelector(":not(a-mixin)[camera]"))&&function(l){var c;l.camera&&(c=l.querySelector("["+Zy+"]"))&&l.removeChild(c)}(o),this.activeCameraEl=n,this.activeCameraEl.play(),o.camera=r,s&&s.setAttribute("camera","active",!1),t=o.querySelectorAll(":not(a-mixin)[camera]"),i=0;i<t.length;i++)(e=t[i]).isEntity&&n!==e&&(e.setAttribute("camera","active",!1),e.pause());o.emit("camera-set-active",{cameraEl:n})}},setSpectatorCamera:function(n){var e,t=this.spectatorCameraEl,i=this.sceneEl;n.getObject3D("camera")&&n!==this.spectatorCameraEl&&(t&&t.setAttribute("camera","spectator",!1),e=this.spectatorCameraEl=n,i.addEventListener("enter-vr",this.wrapRender),i.addEventListener("exit-vr",this.unwrapRender),e.setAttribute("camera","active",!1),e.play(),i.emit("camera-set-spectator",{cameraEl:n}))},disableSpectatorCamera:function(){this.spectatorCameraEl=void 0},wrapRender:function(){this.spectatorCameraEl&&!this.originalRender&&(this.originalRender=this.sceneEl.renderer.render,this.sceneEl.renderer.render=this.render)},unwrapRender:function(){this.originalRender&&(this.sceneEl.renderer.render=this.originalRender,this.originalRender=void 0)},render:function(n,e){var t,i,r=this.sceneEl;t=r.renderer.xr.enabled,this.originalRender.call(r.renderer,n,e),this.spectatorCameraEl&&!r.isMobile&&t&&(i=this.spectatorCameraEl.components.camera.camera,r.renderer.xr.enabled=!1,this.originalRender.call(r.renderer,n,i),r.renderer.xr.enabled=t)}}),gi("geometry",{init:function(){this.cache={},this.cacheCount={}},clearCache:function(){this.cache={},this.cacheCount={}},getOrCreateGeometry:function(n){var e,t,i=this.cache;return n.skipCache?e_(n):(e=i[t=this.hash(n)],function(r,s){r[s]=r[s]===void 0?1:r[s]+1}(this.cacheCount,t),e||(e=e_(n),i[t]=e,e))},unuseGeometry:function(n){var e,t=this.cache,i=this.cacheCount;n.skipCache||t[e=this.hash(n)]&&(function(r,s){r[s]--}(i,e),i[e]>0||(t[e].dispose(),delete t[e],delete i[e]))},hash:function(n){return JSON.stringify(n)}}),gi("gltf-model",{schema:{dracoDecoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.5.7/"},basisTranscoderPath:{default:""},meshoptDecoderPath:{default:""}},init:function(){this.update()},update:function(){var n=this.data.dracoDecoderPath,e=this.data.basisTranscoderPath,t=this.data.meshoptDecoderPath;!this.dracoLoader&&n&&(this.dracoLoader=new LM,this.dracoLoader.setDecoderPath(n)),!this.ktx2Loader&&e&&(this.ktx2Loader=new ni,this.ktx2Loader.setTranscoderPath(e).detectSupport(this.el.renderer)),!this.meshoptDecoder&&t&&(this.meshoptDecoder=function(i){return new Promise(function(r,s){var o=document.createElement("script");document.body.appendChild(o),o.onload=r,o.onerror=s,o.async=!0,o.src=i})}(t).then(function(){return window.MeshoptDecoder.ready}).then(function(){return window.MeshoptDecoder}))},getDRACOLoader:function(){return this.dracoLoader},getKTX2Loader:function(){return this.ktx2Loader},getMeshoptDecoder:function(){return this.meshoptDecoder}});var hu="data-aframe-default-light",LS=(gi("light",{schema:{defaultLightsEnabled:{default:!0}},init:function(){this.defaultLights=!1,this.userDefinedLights=!1,this.sceneEl.addEventListener("loaded",this.setupDefaultLights.bind(this))},registerLight:function(n){n.hasAttribute(hu)||(this.removeDefaultLights(),this.userDefinedLights=!0)},removeDefaultLights:function(){var n,e=this.sceneEl;if(this.defaultLights){n=document.querySelectorAll("["+hu+"]");for(var t=0;t<n.length;t++)e.removeChild(n[t]);this.defaultLights=!1}},setupDefaultLights:function(){var n,e,t=this.sceneEl;this.userDefinedLights||this.defaultLights||!this.data.defaultLightsEnabled||((n=document.createElement("a-entity")).setAttribute("light",{color:"#BBB",type:"ambient"}),n.setAttribute(hu,""),n.setAttribute(vn,""),t.appendChild(n),(e=document.createElement("a-entity")).setAttribute("light",{color:"#FFF",intensity:1.884,castShadow:!0}),e.setAttribute("position",{x:-.5,y:1,z:1}),e.setAttribute(hu,""),e.setAttribute(vn,""),t.appendChild(e),this.defaultLights=!0)}}),Bt),$F=LS("components:texture:error"),t_=LS("components:texture:warn"),KF=new C.ImageLoader;gi("material",{init:function(){this.materials={},this.sourceCache={}},clearTextureSourceCache:function(){this.sourceCache={}},loadTexture:function(n,e,t){this.loadTextureSource(n,function(i){var r=ev(i);Yd(r,e),t(r)})},loadTextureSource:function(n,e){var t=this,i=this.sourceCache,r=this.hash(n);function s(o){i[r]=Promise.resolve(o),i[r].then(e)}i[r]?i[r].then(e):n.tagName!=="CANVAS"?s(new Promise(function(o,a){qd(n,function(l){t.loadImage(l,o)},function(l){t.loadVideo(l,o)})})):s(new C.Source(n))},loadCubeMapTexture:function(n,e){var t=this,i=0,r=new C.CubeTexture;function s(a){t.loadTextureSource(n[a],function(l){r.images[a]=l.data,++i==6&&(r.needsUpdate=!0,e(r))})}if(r.colorSpace=C.SRGBColorSpace,n.length===6)for(var o=0;o<n.length;o++)s(o);else t_("Cube map texture requires exactly 6 sources, got only %s sources",n.length)},loadImage:function(n,e){e(typeof n=="string"?function(t){return new Promise(function(i,r){KF.load(t,function(s){i(new C.Source(s))},function(){},function(s){$F("`$s` could not be fetched (Error code: %s; Response: %s)",s.status,s.statusText)})})}(n):new C.Source(n))},loadVideo:function(n,e){var t;typeof n!="string"&&function(i){i.autoplay=i.hasAttribute("autoplay")&&i.getAttribute("autoplay")!=="false",i.controls=i.hasAttribute("controls")&&i.getAttribute("controls")!=="false",i.getAttribute("loop")==="false"&&i.removeAttribute("loop"),i.getAttribute("preload")==="false"&&(i.preload="none"),i.crossOrigin=i.crossOrigin||"anonymous",i.setAttribute("playsinline",""),i.setAttribute("webkit-playsinline","")}(t=n),t=t||function(i){var r=document.createElement("video");return r.setAttribute("playsinline",""),r.setAttribute("webkit-playsinline",""),r.autoplay=!0,r.loop=!0,r.crossOrigin="anonymous",r.addEventListener("error",function(){t_("`%s` is not a valid video",i)},!0),r.src=i,r}(n),e(new C.Source(t))},hash:function(n){return n.tagName&&(n.id||n.src)||n},registerMaterial:function(n){this.materials[n.uuid]=n},unregisterMaterial:function(n){delete this.materials[n.uuid]}}),gi("obb-collider",{schema:{showColliders:{default:!1}},init:function(){this.collisions=[],this.colliderEls=[]},addCollider:function(n){this.colliderEls.push(n),this.data.showColliders?n.components["obb-collider"].showCollider():n.components["obb-collider"].hideCollider(),this.tick=this.detectCollisions},removeCollider:function(n){var e=this.colliderEls,t=e.indexOf(n);n.components["obb-collider"].hideCollider(),t>-1&&e.splice(t,1),e.length===0&&(this.tick=void 0)},registerCollision:function(n,e){var t=this.collisions,i=!1,r=n.obb,s=e.obb,o=n.renderColliderMesh,a=e.renderColliderMesh;o&&o.material.color.set(16711680),a&&a.material.color.set(16711680);for(var l=0;l<t.length;l++)if(t[l].componentA.obb===r&&t[l].componentB.obb===s||t[l].componentA.obb===s&&t[l].componentB.obb===r){i=!0,t[l].detected=!0;break}i||(t.push({componentA:n,componentB:e,detected:!0}),n.el.emit("obbcollisionstarted",{trackedObject3D:n.trackedObject3D,withEl:e.el}),e.el.emit("obbcollisionstarted",{trackedObject3D:e.trackedObject3D,withEl:n.el}))},resetCollisions:function(){for(var n=this.collisions,e=0;e<n.length;e++)n[e].detected=!1},clearCollisions:function(){for(var n,e,t,i,r=this.collisions,s=[],o=0;o<r.length;o++)r[o].detected?s.push(r[o]):(n=r[o].componentA,e=r[o].componentB,t=n.renderColliderMesh,i=e.renderColliderMesh,t&&t.material.color.set(65280),n.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:e.el}),i&&i.material.color.set(65280),e.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:n.el}));this.collisions=s},detectCollisions:function(){var n,e,t,i,r=this.colliderEls;if(!(r.length<2)){this.resetCollisions();for(var s=0;s<r.length;s++)if(t=r[s].components["obb-collider"],(n=r[s].components["obb-collider"].obb).halfSize.x!==0&&n.halfSize.y!==0&&n.halfSize.z!==0)for(var o=s+1;o<r.length;o++)(e=(i=r[o].components["obb-collider"]).obb).halfSize.x!==0&&e.halfSize.y!==0&&e.halfSize.z!==0&&n.intersectsOBB(e)&&this.registerCollision(t,i);this.clearCollisions()}}});var Fm=Bt("components:renderer:warn");function JF(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z-e.z}function ZF(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder-e.renderOrder}function e3(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:e.z-n.z}gi("renderer",{schema:{antialias:{default:"auto",oneOf:["true","false","auto"]},highRefreshRate:{default:W0()},logarithmicDepthBuffer:{default:"auto",oneOf:["true","false","auto"]},maxCanvasWidth:{default:-1},maxCanvasHeight:{default:-1},multiviewStereo:{default:!1},exposure:{default:1,if:{toneMapping:["ACESFilmic","linear","reinhard","cineon","AgX","neutral"]}},toneMapping:{default:"no",oneOf:["no","ACESFilmic","linear","reinhard","cineon","AgX","neutral"]},precision:{default:"high",oneOf:["high","medium","low"]},anisotropy:{default:1},sortTransparentObjects:{default:!1},colorManagement:{default:!0},alpha:{default:!0},stencil:{default:!1},foveationLevel:{default:1}},init:function(){var n=this.data,e=this.el,t=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1),i=e.renderer;i.toneMapping=C[t+"ToneMapping"],C.Texture.DEFAULT_ANISOTROPY=n.anisotropy,C.ColorManagement.enabled=n.colorManagement,i.outputColorSpace=n.colorManagement?C.SRGBColorSpace:C.LinearSRGBColorSpace,e.hasAttribute("antialias")&&Fm('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'),e.hasAttribute("logarithmicDepthBuffer")&&Fm('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'),i.sortObjects=!0,i.setOpaqueSort(JF)},update:function(){var n=this.data,e=this.el.renderer,t=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1);e.toneMapping=C[t+"ToneMapping"],e.toneMappingExposure=n.exposure,e.xr.setFoveation(n.foveationLevel),n.sortObjects&&Fm('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'),n.sortTransparentObjects?e.setTransparentSort(e3):e.setTransparentSort(ZF)},applyColorCorrection:function(n){this.data.colorManagement&&n&&n.isTexture&&n.colorSpace!==C.SRGBColorSpace&&(n.colorSpace=C.SRGBColorSpace,n.needsUpdate=!0)},setWebXRFrameRate:function(n){var e,t=this.data,i=n.supportedFrameRates;i&&n.updateTargetFrameRate&&(e=i.includes(90)?t.highRefreshRate?90:72:t.highRefreshRate?72:60,n.updateTargetFrameRate(e).catch(function(r){console.warn("failed to set target frame rate of "+e+". Error info: "+r)}))}});var t3={basic:C.BasicShadowMap,pcf:C.PCFShadowMap,pcfsoft:C.PCFSoftShadowMap};gi("shadow",{schema:{enabled:{default:!0},autoUpdate:{default:!0},type:{default:"pcf",oneOf:["basic","pcf","pcfsoft"]}},init:function(){var n=this.sceneEl,e=this.data;this.shadowMapEnabled=!1,n.renderer.shadowMap.type=t3[e.type],n.renderer.shadowMap.autoUpdate=e.autoUpdate},update:function(n){n.enabled!==this.data.enabled&&this.setShadowMapEnabled(this.shadowMapEnabled)},setShadowMapEnabled:function(n){var e=this.sceneEl,t=this.sceneEl.renderer;this.shadowMapEnabled=n;var i=this.data.enabled&&this.shadowMapEnabled;t&&i!==t.shadowMap.enabled&&(t.shadowMap.enabled=i,function(r){r.hasLoaded&&r.object3D.traverse(function(s){if(s.material)for(var o=Array.isArray(s.material)?s.material:[s.material],a=0;a<o.length;a++)o[a].needsUpdate=!0})}(e))}}),gi("tracked-controls",{init:function(){this.controllers=[],this.onInputSourcesChange=this.onInputSourcesChange.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.el.addEventListener("enter-vr",this.onEnterVR),this.onExitVR=this.onExitVR.bind(this),this.el.addEventListener("exit-vr",this.onExitVR)},onEnterVR:function(){this.el.xrSession&&this.el.xrSession.addEventListener("inputsourceschange",this.onInputSourcesChange)},onExitVR:function(){this.referenceSpace=void 0,this.controllers=[],this.el.emit("controllersupdated",void 0,!1)},onInputSourcesChange:function(){var n=this,e=this.el.xrSession,t=this.el.sceneEl.systems.webxr.sessionReferenceSpaceType;e.requestReferenceSpace(t).then(function(i){n.referenceSpace=i}).catch(function(i){throw n.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(t,'tracked-controls uses reference space "'+t+'".'),i}),this.controllers=e.inputSources,this.el.emit("controllersupdated",void 0,!1)}});var n3=Bt("systems:webxr:warn"),DS=(gi("webxr",{schema:{referenceSpaceType:{type:"string",default:"local-floor"},requiredFeatures:{type:"array",default:["local-floor"]},optionalFeatures:{type:"array",default:["bounded-floor"]},overlayElement:{type:"selector"}},update:function(){var n=this.data;this.sessionConfiguration={requiredFeatures:n.requiredFeatures,optionalFeatures:n.optionalFeatures},this.sessionReferenceSpaceType=n.referenceSpaceType,n.overlayElement&&(n.overlayElement.classList.remove("a-dom-overlay"),n.optionalFeatures.includes("dom-overlay")||(n.optionalFeatures.push("dom-overlay"),this.el.setAttribute("webxr",n)),this.warnIfFeatureNotRequested("dom-overlay"),this.sessionConfiguration.domOverlay={root:n.overlayElement},n.overlayElement.classList.add("a-dom-overlay"))},wasFeatureRequested:function(n){return n==="viewer"||n==="local"||!(!this.sessionConfiguration.requiredFeatures.includes(n)&&!this.sessionConfiguration.optionalFeatures.includes(n))},warnIfFeatureNotRequested:function(n,e){this.wasFeatureRequested(n)||n3((e?e+" ":"")+'Please add the feature "'+n+`" to a-scene's webxr system options in requiredFeatures/optionalFeatures.`)}}),{});function n_(n){var e=n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();n==="fog"&&(e="material-fog"),n==="visible"&&(e="material-visible"),DS[e]="material."+n}function Tr(){return{defaultComponents:{material:{}},mappings:qn({},DS)}}Object.keys(Yt.material.schema).forEach(n_),Object.keys(ji.standard.schema).forEach(n_);var uu=new C.Vector3,i3=new C.Vector3;tt("pivot",{dependencies:["position"],schema:{type:"vec3"},init:function(){var n=this.data,e=this.el,t=e.object3D.parent,i=e.object3D,r=new C.Group;uu.copy(i.position),i3.copy(i.rotation),t.remove(i),r.add(i),t.add(r),e.object3D=r,i.position.set(-1*n.x,-1*n.y,-1*n.z),r.position.set(n.x+uu.x,n.y+uu.y,n.z+uu.z),r.rotation.copy(i.rotation),i.rotation.set(0,0,0)}}),Pn("a-camera",{defaultComponents:{camera:{},"look-controls":{},"wasd-controls":{},position:{x:0,y:1.6,z:0}},mappings:{active:"camera.active",far:"camera.far",fov:"camera.fov","look-controls-enabled":"look-controls.enabled",near:"camera.near","pointer-lock-enabled":"look-controls.pointerLockEnabled","wasd-controls-enabled":"wasd-controls.enabled","reverse-mouse-drag":"look-controls.reverseMouseDrag",zoom:"camera.zoom"}}),Pn("a-cursor",ti({},Tr(),{defaultComponents:{cursor:{},geometry:{primitive:"ring",radiusOuter:.016,radiusInner:.01,segmentsTheta:32},material:{color:"#000",shader:"flat",opacity:.8},position:{x:0,y:0,z:-1}},mappings:{far:"raycaster.far",fuse:"cursor.fuse","fuse-timeout":"cursor.fuseTimeout",interval:"raycaster.interval",objects:"raycaster.objects"}})),Pn("a-curvedimage",ti({},Tr(),{defaultComponents:{geometry:{height:1,primitive:"cylinder",radius:2,segmentsRadial:48,thetaLength:270,openEnded:!0,thetaStart:0},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0,repeat:"-1 1"}},mappings:{height:"geometry.height","open-ended":"geometry.openEnded",radius:"geometry.radius",segments:"geometry.segmentsRadial",start:"geometry.thetaStart","theta-length":"geometry.thetaLength","theta-start":"geometry.thetaStart",width:"geometry.thetaLength"}})),Pn("a-gltf-model",{mappings:{src:"gltf-model"}}),Pn("a-image",ti({},Tr(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}})),Pn("a-light",{defaultComponents:{light:{}},mappings:{angle:"light.angle",color:"light.color","ground-color":"light.groundColor",decay:"light.decay",distance:"light.distance",intensity:"light.intensity",penumbra:"light.penumbra",type:"light.type",target:"light.target",envmap:"light.envMap","shadow-camera-automatic":"light.shadowCameraAutomatic"}}),Pn("a-link",{defaultComponents:{link:{visualAspectEnabled:!0}},mappings:{href:"link.href",image:"link.image",title:"link.title"}}),Pn("a-obj-model",ti({},Tr(),{defaultComponents:{"obj-model":{}},mappings:{src:"obj-model.obj",mtl:"obj-model.mtl"}}));const PS={},r3=PS;function i_(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}var Nm,du;av.forEach(function(n){var e=Ss[n],t=i_(n),i={};Object.keys(e.schema).forEach(function(o){i[i_(o)]="geometry."+o});var r="a-"+t,s=Pn(r,ti({},Tr(),{defaultComponents:{geometry:{primitive:n}},mappings:i}));PS[r]=s}),Pn("a-sky",ti({},Tr(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",side:"back",shader:"flat",npot:!0},scale:"-1 1 1"},mappings:ti({},r3["a-sphere"].mappings)})),Pn("a-sound",{defaultComponents:{sound:{}},mappings:{src:"sound.src",on:"sound.on",autoplay:"sound.autoplay",loop:"sound.loop",volume:"sound.volume"}}),Nm={text:{anchor:"align",width:5}},du=du||{},Object.keys(Nm).forEach(function(n){(function(e,t){var i=Yt[e].schema;Object.keys(i).forEach(function(r){var s=r.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();t[s]!==void 0&&(s=e+"-"+r),t[s]=e+"."+r})})(n,du)}),Pn("a-text",ti({},null,{defaultComponents:Nm,mappings:du})),Pn("a-video",ti({},Tr(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}})),Pn("a-videosphere",ti({},Tr(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",shader:"flat",side:"back",npot:!0},scale:"-1 1 1"},mappings:{radius:"geometry.radius","segments-height":"geometry.segmentsHeight","segments-width":"geometry.segmentsWidth"}}));var hv=Bt,s3=hv("A-Frame:error"),o3=hv("A-Frame:warn");window.document.currentScript&&window.document.currentScript.parentNode!==window.document.head&&!window.debug&&o3("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."),window.cordova||window.location.protocol!=="file:"||s3("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."),Y0&&(window.logs=hv,nt(7180),nt(9379)),console.log("A-Frame Version: 1.7.0 (Date 2025-03-12, Commit #1b9650f1)"),console.log("THREE Version (https://github.com/supermedium/three.js):",ZM.REVISION),window.AFRAME_ASYNC||(document.readyState!=="complete"?document.addEventListener("readystatechange",function n(){document.readyState==="complete"&&(document.removeEventListener("readystatechange",n),ZA())}):ZA());const a3=globalThis.AFRAME={AComponent:Mc,AEntity:an,ANode:En,ANIME:zu,AScene:SS,components:Yt,coreComponents:Object.keys(Yt),geometries:Ss,registerComponent:tt,registerGeometry:Nn,registerPrimitive:Pn,registerShader:hs,registerSystem:gi,primitives:{getMeshMixin:Tr,primitives:wS},scenes:So,schema:OA,shaders:ji,systems:wr,emitReady:ZA,THREE:ZM,utils:NA,version:IS};gM.A;/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const uv="175",l3=0,r_=1,c3=2,US=1,h3=2,vr=3,ws=0,jn=1,_r=2,ys=0,Qa=1,s_=2,o_=3,a_=4,u3=5,po=100,d3=101,f3=102,p3=103,m3=104,A3=200,g3=201,v3=202,E3=203,rg=204,sg=205,x3=206,y3=207,_3=208,b3=209,C3=210,M3=211,S3=212,w3=213,T3=214,og=0,ag=1,lg=2,Ka=3,cg=4,hg=5,ug=6,dg=7,FS=0,I3=1,R3=2,_s=0,B3=1,L3=2,D3=3,P3=4,U3=5,F3=6,N3=7,NS=300,Ja=301,Za=302,fg=303,pg=304,qf=306,mg=1e3,yo=1001,Ag=1002,Pi=1003,O3=1004,fu=1005,Ai=1006,Om=1007,_o=1008,Hr=1009,OS=1010,kS=1011,Sc=1012,dv=1013,Lo=1014,Ir=1015,Qc=1016,fv=1017,pv=1018,wc=1020,GS=35902,zS=1021,HS=1022,Di=1023,VS=1024,QS=1025,Tc=1026,Ic=1027,WS=1028,mv=1029,XS=1030,Av=1031,gv=1033,qu=33776,Yu=33777,ju=33778,$u=33779,gg=35840,vg=35841,Eg=35842,xg=35843,yg=36196,_g=37492,bg=37496,Cg=37808,Mg=37809,Sg=37810,wg=37811,Tg=37812,Ig=37813,Rg=37814,Bg=37815,Lg=37816,Dg=37817,Pg=37818,Ug=37819,Fg=37820,Ng=37821,Ku=36492,Og=36494,kg=36495,qS=36283,Gg=36284,zg=36285,Hg=36286,k3=3200,G3=3201,z3=0,H3=1,ps="",pi="srgb",el="srgb-linear",tf="linear",Ot="srgb",pa=7680,l_=519,V3=512,Q3=513,W3=514,YS=515,X3=516,q3=517,Y3=518,j3=519,c_=35044,h_="300 es",Rr=2e3,nf=2001;class Fo{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){const i=this._listeners;return i===void 0?!1:i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){const i=this._listeners;if(i===void 0)return;const r=i[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const i=t[e.type];if(i!==void 0){e.target=this;const r=i.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}}const Mn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let u_=1234567;const tc=Math.PI/180,Rc=180/Math.PI;function al(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Mn[n&255]+Mn[n>>8&255]+Mn[n>>16&255]+Mn[n>>24&255]+"-"+Mn[e&255]+Mn[e>>8&255]+"-"+Mn[e>>16&15|64]+Mn[e>>24&255]+"-"+Mn[t&63|128]+Mn[t>>8&255]+"-"+Mn[t>>16&255]+Mn[t>>24&255]+Mn[i&255]+Mn[i>>8&255]+Mn[i>>16&255]+Mn[i>>24&255]).toLowerCase()}function Ct(n,e,t){return Math.max(e,Math.min(t,n))}function vv(n,e){return(n%e+e)%e}function $3(n,e,t,i,r){return i+(n-e)*(r-i)/(t-e)}function K3(n,e,t){return n!==e?(t-n)/(e-n):0}function nc(n,e,t){return(1-t)*n+t*e}function J3(n,e,t,i){return nc(n,e,1-Math.exp(-t*i))}function Z3(n,e=1){return e-Math.abs(vv(n,e*2)-e)}function eN(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function tN(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function nN(n,e){return n+Math.floor(Math.random()*(e-n+1))}function iN(n,e){return n+Math.random()*(e-n)}function rN(n){return n*(.5-Math.random())}function sN(n){n!==void 0&&(u_=n);let e=u_+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function oN(n){return n*tc}function aN(n){return n*Rc}function lN(n){return(n&n-1)===0&&n!==0}function cN(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function hN(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function uN(n,e,t,i,r){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),c=s((e+i)/2),h=o((e+i)/2),u=s((e-i)/2),d=o((e-i)/2),f=s((i-e)/2),A=o((i-e)/2);switch(r){case"XYX":n.set(a*h,l*u,l*d,a*c);break;case"YZY":n.set(l*d,a*h,l*u,a*c);break;case"ZXZ":n.set(l*u,l*d,a*h,a*c);break;case"XZX":n.set(a*h,l*A,l*f,a*c);break;case"YXY":n.set(l*f,a*h,l*A,a*c);break;case"ZYZ":n.set(l*A,l*f,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function Ra(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Bn(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const fi={DEG2RAD:tc,RAD2DEG:Rc,generateUUID:al,clamp:Ct,euclideanModulo:vv,mapLinear:$3,inverseLerp:K3,lerp:nc,damp:J3,pingpong:Z3,smoothstep:eN,smootherstep:tN,randInt:nN,randFloat:iN,randFloatSpread:rN,seededRandom:sN,degToRad:oN,radToDeg:aN,isPowerOfTwo:lN,ceilPowerOfTwo:cN,floorPowerOfTwo:hN,setQuaternionFromProperEuler:uN,normalize:Bn,denormalize:Ra};class zt{constructor(e=0,t=0){zt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Ct(this.x,e.x,t.x),this.y=Ct(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=Ct(this.x,e,t),this.y=Ct(this.y,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Ct(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(Ct(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Et{constructor(e,t,i,r,s,o,a,l,c){Et.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,i,r,s,o,a,l,c)}set(e,t,i,r,s,o,a,l,c){const h=this.elements;return h[0]=e,h[1]=r,h[2]=a,h[3]=t,h[4]=s,h[5]=l,h[6]=i,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],h=i[4],u=i[7],d=i[2],f=i[5],A=i[8],g=r[0],m=r[3],p=r[6],v=r[1],E=r[4],x=r[7],M=r[2],w=r[5],S=r[8];return s[0]=o*g+a*v+l*M,s[3]=o*m+a*E+l*w,s[6]=o*p+a*x+l*S,s[1]=c*g+h*v+u*M,s[4]=c*m+h*E+u*w,s[7]=c*p+h*x+u*S,s[2]=d*g+f*v+A*M,s[5]=d*m+f*E+A*w,s[8]=d*p+f*x+A*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8];return t*o*h-t*a*c-i*s*h+i*a*l+r*s*c-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=h*o-a*c,d=a*l-h*s,f=c*s-o*l,A=t*u+i*d+r*f;if(A===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/A;return e[0]=u*g,e[1]=(r*c-h*i)*g,e[2]=(a*i-r*o)*g,e[3]=d*g,e[4]=(h*t-r*l)*g,e[5]=(r*s-a*t)*g,e[6]=f*g,e[7]=(i*l-c*t)*g,e[8]=(o*t-i*s)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(km.makeScale(e,t)),this}rotate(e){return this.premultiply(km.makeRotation(-e)),this}translate(e,t){return this.premultiply(km.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,i,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const km=new Et;function jS(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}function rf(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function dN(){const n=rf("canvas");return n.style.display="block",n}const d_={};function Ju(n){n in d_||(d_[n]=!0,console.warn(n))}function fN(n,e,t){return new Promise(function(i,r){function s(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:r();break;case n.TIMEOUT_EXPIRED:setTimeout(s,t);break;default:i()}}setTimeout(s,t)})}function pN(n){const e=n.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function mN(n){const e=n.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const f_=new Et().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),p_=new Et().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function AN(){const n={enabled:!0,workingColorSpace:el,spaces:{},convert:function(r,s,o){return this.enabled===!1||s===o||!s||!o||(this.spaces[s].transfer===Ot&&(r.r=Nr(r.r),r.g=Nr(r.g),r.b=Nr(r.b)),this.spaces[s].primaries!==this.spaces[o].primaries&&(r.applyMatrix3(this.spaces[s].toXYZ),r.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===Ot&&(r.r=Wa(r.r),r.g=Wa(r.g),r.b=Wa(r.b))),r},fromWorkingColorSpace:function(r,s){return this.convert(r,this.workingColorSpace,s)},toWorkingColorSpace:function(r,s){return this.convert(r,s,this.workingColorSpace)},getPrimaries:function(r){return this.spaces[r].primaries},getTransfer:function(r){return r===ps?tf:this.spaces[r].transfer},getLuminanceCoefficients:function(r,s=this.workingColorSpace){return r.fromArray(this.spaces[s].luminanceCoefficients)},define:function(r){Object.assign(this.spaces,r)},_getMatrix:function(r,s,o){return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(r){return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(r=this.workingColorSpace){return this.spaces[r].workingColorSpaceConfig.unpackColorSpace}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],i=[.3127,.329];return n.define({[el]:{primaries:e,whitePoint:i,transfer:tf,toXYZ:f_,fromXYZ:p_,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:pi},outputColorSpaceConfig:{drawingBufferColorSpace:pi}},[pi]:{primaries:e,whitePoint:i,transfer:Ot,toXYZ:f_,fromXYZ:p_,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:pi}}}),n}const Rt=AN();function Nr(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Wa(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let ma;class gN{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let i;if(e instanceof HTMLCanvasElement)i=e;else{ma===void 0&&(ma=rf("canvas")),ma.width=e.width,ma.height=e.height;const r=ma.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),i=ma}return i.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=rf("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),s=r.data;for(let o=0;o<s.length;o++)s[o]=Nr(s[o]/255)*255;return i.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(Nr(t[i]/255)*255):t[i]=Nr(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let vN=0;class Ev{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:vN++}),this.uuid=al(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(Gm(r[o].image)):s.push(Gm(r[o]))}else s=Gm(r);i.url=s}return t||(e.images[this.uuid]=i),i}}function Gm(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?gN.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let EN=0;class zn extends Fo{constructor(e=zn.DEFAULT_IMAGE,t=zn.DEFAULT_MAPPING,i=yo,r=yo,s=Ai,o=_o,a=Di,l=Hr,c=zn.DEFAULT_ANISOTROPY,h=ps){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:EN++}),this.uuid=al(),this.name="",this.source=new Ev(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new zt(0,0),this.repeat=new zt(1,1),this.center=new zt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Et,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==NS)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case mg:e.x=e.x-Math.floor(e.x);break;case yo:e.x=e.x<0?0:1;break;case Ag:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case mg:e.y=e.y-Math.floor(e.y);break;case yo:e.y=e.y<0?0:1;break;case Ag:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}zn.DEFAULT_IMAGE=null;zn.DEFAULT_MAPPING=NS;zn.DEFAULT_ANISOTROPY=1;class jt{constructor(e=0,t=0,i=0,r=1){jt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*i+o[11]*r+o[15]*s,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,s;const l=e.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],A=l[9],g=l[2],m=l[6],p=l[10];if(Math.abs(h-d)<.01&&Math.abs(u-g)<.01&&Math.abs(A-m)<.01){if(Math.abs(h+d)<.1&&Math.abs(u+g)<.1&&Math.abs(A+m)<.1&&Math.abs(c+f+p-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const E=(c+1)/2,x=(f+1)/2,M=(p+1)/2,w=(h+d)/4,S=(u+g)/4,B=(A+m)/4;return E>x&&E>M?E<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(E),r=w/i,s=S/i):x>M?x<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(x),i=w/r,s=B/r):M<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(M),i=S/s,r=B/s),this.set(i,r,s,t),this}let v=Math.sqrt((m-A)*(m-A)+(u-g)*(u-g)+(d-h)*(d-h));return Math.abs(v)<.001&&(v=1),this.x=(m-A)/v,this.y=(u-g)/v,this.z=(d-h)/v,this.w=Math.acos((c+f+p-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Ct(this.x,e.x,t.x),this.y=Ct(this.y,e.y,t.y),this.z=Ct(this.z,e.z,t.z),this.w=Ct(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=Ct(this.x,e,t),this.y=Ct(this.y,e,t),this.z=Ct(this.z,e,t),this.w=Ct(this.w,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Ct(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class xN extends Fo{constructor(e=1,t=1,i={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new jt(0,0,e,t),this.scissorTest=!1,this.viewport=new jt(0,0,e,t);const r={width:e,height:t,depth:1};i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Ai,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},i);const s=new zn(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);s.flipY=!1,s.generateMipmaps=i.generateMipmaps,s.internalFormat=i.internalFormat,this.textures=[];const o=i.count;for(let a=0;a<o;a++)this.textures[a]=s.clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this._depthTexture=i.depthTexture,this.samples=i.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let r=0,s=this.textures.length;r<s;r++)this.textures[r].image.width=e,this.textures[r].image.height=t,this.textures[r].image.depth=i;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,i=e.textures.length;t<i;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const r=Object.assign({},e.textures[t].image);this.textures[t].source=new Ev(r)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Do extends xN{constructor(e=1,t=1,i={}){super(e,t,i),this.isWebGLRenderTarget=!0}}class $S extends zn{constructor(e=null,t=1,i=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=Pi,this.minFilter=Pi,this.wrapR=yo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class yN extends zn{constructor(e=null,t=1,i=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=Pi,this.minFilter=Pi,this.wrapR=yo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Vr{constructor(e=0,t=0,i=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=r}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],c=i[r+1],h=i[r+2],u=i[r+3];const d=s[o+0],f=s[o+1],A=s[o+2],g=s[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=u;return}if(a===1){e[t+0]=d,e[t+1]=f,e[t+2]=A,e[t+3]=g;return}if(u!==g||l!==d||c!==f||h!==A){let m=1-a;const p=l*d+c*f+h*A+u*g,v=p>=0?1:-1,E=1-p*p;if(E>Number.EPSILON){const M=Math.sqrt(E),w=Math.atan2(M,p*v);m=Math.sin(m*w)/M,a=Math.sin(a*w)/M}const x=a*v;if(l=l*m+d*x,c=c*m+f*x,h=h*m+A*x,u=u*m+g*x,m===1-a){const M=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=M,c*=M,h*=M,u*=M}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=u}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],h=i[r+3],u=s[o],d=s[o+1],f=s[o+2],A=s[o+3];return e[t]=a*A+h*u+l*f-c*d,e[t+1]=l*A+h*d+c*u-a*f,e[t+2]=c*A+h*f+a*d-l*u,e[t+3]=h*A-a*u-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),h=a(r/2),u=a(s/2),d=l(i/2),f=l(r/2),A=l(s/2);switch(o){case"XYZ":this._x=d*h*u+c*f*A,this._y=c*f*u-d*h*A,this._z=c*h*A+d*f*u,this._w=c*h*u-d*f*A;break;case"YXZ":this._x=d*h*u+c*f*A,this._y=c*f*u-d*h*A,this._z=c*h*A-d*f*u,this._w=c*h*u+d*f*A;break;case"ZXY":this._x=d*h*u-c*f*A,this._y=c*f*u+d*h*A,this._z=c*h*A+d*f*u,this._w=c*h*u-d*f*A;break;case"ZYX":this._x=d*h*u-c*f*A,this._y=c*f*u+d*h*A,this._z=c*h*A-d*f*u,this._w=c*h*u+d*f*A;break;case"YZX":this._x=d*h*u+c*f*A,this._y=c*f*u+d*h*A,this._z=c*h*A-d*f*u,this._w=c*h*u-d*f*A;break;case"XZY":this._x=d*h*u-c*f*A,this._y=c*f*u-d*h*A,this._z=c*h*A+d*f*u,this._w=c*h*u+d*f*A;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],h=t[6],u=t[10],d=i+a+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(o-r)*f}else if(i>a&&i>u){const f=2*Math.sqrt(1+i-a-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+o)/f,this._z=(s+c)/f}else if(a>u){const f=2*Math.sqrt(1+a-i-u);this._w=(s-c)/f,this._x=(r+o)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-i-a);this._w=(o-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ct(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,h=t._w;return this._x=i*h+o*a+r*c-s*l,this._y=r*h+o*l+s*a-i*c,this._z=s*h+o*c+i*l-r*a,this._w=o*h-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-t;return this._w=f*o+t*this._w,this._x=f*i+t*this._x,this._y=f*r+t*this._y,this._z=f*s+t*this._z,this.normalize(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),u=Math.sin((1-t)*h)/c,d=Math.sin(t*h)/c;return this._w=o*u+this._w*d,this._x=i*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),i=Math.random(),r=Math.sqrt(1-i),s=Math.sqrt(i);return this.set(r*Math.sin(e),r*Math.cos(e),s*Math.sin(t),s*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ye{constructor(e=0,t=0,i=0){ye.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(m_.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(m_.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=2*(o*r-a*i),h=2*(a*t-s*r),u=2*(s*i-o*t);return this.x=t+l*c+o*u-a*h,this.y=i+l*h+a*c-s*u,this.z=r+l*u+s*h-o*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Ct(this.x,e.x,t.x),this.y=Ct(this.y,e.y,t.y),this.z=Ct(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=Ct(this.x,e,t),this.y=Ct(this.y,e,t),this.z=Ct(this.z,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Ct(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return zm.copy(this).projectOnVector(e),this.sub(zm)}reflect(e){return this.sub(zm.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(Ct(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,i=Math.sqrt(1-t*t);return this.x=i*Math.cos(e),this.y=t,this.z=i*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const zm=new ye,m_=new Vr;class Wc{constructor(e=new ye(1/0,1/0,1/0),t=new ye(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t+=3)this.expandByPoint(Ci.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,i=e.count;t<i;t++)this.expandByPoint(Ci.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=Ci.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0){const s=i.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=s.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Ci):Ci.fromBufferAttribute(s,o),Ci.applyMatrix4(e.matrixWorld),this.expandByPoint(Ci);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),pu.copy(e.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),pu.copy(i.boundingBox)),pu.applyMatrix4(e.matrixWorld),this.union(pu)}const r=e.children;for(let s=0,o=r.length;s<o;s++)this.expandByObject(r[s],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Ci),Ci.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ul),mu.subVectors(this.max,Ul),Aa.subVectors(e.a,Ul),ga.subVectors(e.b,Ul),va.subVectors(e.c,Ul),ns.subVectors(ga,Aa),is.subVectors(va,ga),no.subVectors(Aa,va);let t=[0,-ns.z,ns.y,0,-is.z,is.y,0,-no.z,no.y,ns.z,0,-ns.x,is.z,0,-is.x,no.z,0,-no.x,-ns.y,ns.x,0,-is.y,is.x,0,-no.y,no.x,0];return!Hm(t,Aa,ga,va,mu)||(t=[1,0,0,0,1,0,0,0,1],!Hm(t,Aa,ga,va,mu))?!1:(Au.crossVectors(ns,is),t=[Au.x,Au.y,Au.z],Hm(t,Aa,ga,va,mu))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ci).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ci).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(dr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),dr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),dr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),dr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),dr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),dr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),dr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),dr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(dr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const dr=[new ye,new ye,new ye,new ye,new ye,new ye,new ye,new ye],Ci=new ye,pu=new Wc,Aa=new ye,ga=new ye,va=new ye,ns=new ye,is=new ye,no=new ye,Ul=new ye,mu=new ye,Au=new ye,io=new ye;function Hm(n,e,t,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){io.fromArray(n,s);const a=r.x*Math.abs(io.x)+r.y*Math.abs(io.y)+r.z*Math.abs(io.z),l=e.dot(io),c=t.dot(io),h=i.dot(io);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const _N=new Wc,Fl=new ye,Vm=new ye;class xv{constructor(e=new ye,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):_N.setFromPoints(e).getCenter(i);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,i.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Fl.subVectors(e,this.center);const t=Fl.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),r=(i-this.radius)*.5;this.center.addScaledVector(Fl,r/i),this.radius+=r}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Vm.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Fl.copy(e.center).add(Vm)),this.expandByPoint(Fl.copy(e.center).sub(Vm))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const fr=new ye,Qm=new ye,gu=new ye,rs=new ye,Wm=new ye,vu=new ye,Xm=new ye;class KS{constructor(e=new ye,t=new ye(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,fr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=fr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(fr.copy(this.origin).addScaledVector(this.direction,t),fr.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){Qm.copy(e).add(t).multiplyScalar(.5),gu.copy(t).sub(e).normalize(),rs.copy(this.origin).sub(Qm);const s=e.distanceTo(t)*.5,o=-this.direction.dot(gu),a=rs.dot(this.direction),l=-rs.dot(gu),c=rs.lengthSq(),h=Math.abs(1-o*o);let u,d,f,A;if(h>0)if(u=o*l-a,d=o*a-l,A=s*h,u>=0)if(d>=-A)if(d<=A){const g=1/h;u*=g,d*=g,f=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d<=-A?(u=Math.max(0,-(-o*s+a)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=A?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(o*s+a)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=o>0?-s:s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;return i&&i.copy(this.origin).addScaledVector(this.direction,u),r&&r.copy(Qm).addScaledVector(gu,d),f}intersectSphere(e,t){fr.subVectors(e.center,this.origin);const i=fr.dot(this.direction),r=fr.dot(fr)-i*i,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,s,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(i=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(i=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),h>=0?(s=(e.min.y-d.y)*h,o=(e.max.y-d.y)*h):(s=(e.max.y-d.y)*h,o=(e.min.y-d.y)*h),i>o||s>r||((s>i||isNaN(i))&&(i=s),(o<r||isNaN(r))&&(r=o),u>=0?(a=(e.min.z-d.z)*u,l=(e.max.z-d.z)*u):(a=(e.max.z-d.z)*u,l=(e.min.z-d.z)*u),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,t)}intersectsBox(e){return this.intersectBox(e,fr)!==null}intersectTriangle(e,t,i,r,s){Wm.subVectors(t,e),vu.subVectors(i,e),Xm.crossVectors(Wm,vu);let o=this.direction.dot(Xm),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;rs.subVectors(this.origin,e);const l=a*this.direction.dot(vu.crossVectors(rs,vu));if(l<0)return null;const c=a*this.direction.dot(Wm.cross(rs));if(c<0||l+c>o)return null;const h=-a*rs.dot(Xm);return h<0?null:this.at(h/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class $t{constructor(e,t,i,r,s,o,a,l,c,h,u,d,f,A,g,m){$t.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,i,r,s,o,a,l,c,h,u,d,f,A,g,m)}set(e,t,i,r,s,o,a,l,c,h,u,d,f,A,g,m){const p=this.elements;return p[0]=e,p[4]=t,p[8]=i,p[12]=r,p[1]=s,p[5]=o,p[9]=a,p[13]=l,p[2]=c,p[6]=h,p[10]=u,p[14]=d,p[3]=f,p[7]=A,p[11]=g,p[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new $t().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/Ea.setFromMatrixColumn(e,0).length(),s=1/Ea.setFromMatrixColumn(e,1).length(),o=1/Ea.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),h=Math.cos(s),u=Math.sin(s);if(e.order==="XYZ"){const d=o*h,f=o*u,A=a*h,g=a*u;t[0]=l*h,t[4]=-l*u,t[8]=c,t[1]=f+A*c,t[5]=d-g*c,t[9]=-a*l,t[2]=g-d*c,t[6]=A+f*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*h,f=l*u,A=c*h,g=c*u;t[0]=d+g*a,t[4]=A*a-f,t[8]=o*c,t[1]=o*u,t[5]=o*h,t[9]=-a,t[2]=f*a-A,t[6]=g+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*h,f=l*u,A=c*h,g=c*u;t[0]=d-g*a,t[4]=-o*u,t[8]=A+f*a,t[1]=f+A*a,t[5]=o*h,t[9]=g-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*h,f=o*u,A=a*h,g=a*u;t[0]=l*h,t[4]=A*c-f,t[8]=d*c+g,t[1]=l*u,t[5]=g*c+d,t[9]=f*c-A,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,f=o*c,A=a*l,g=a*c;t[0]=l*h,t[4]=g-d*u,t[8]=A*u+f,t[1]=u,t[5]=o*h,t[9]=-a*h,t[2]=-c*h,t[6]=f*u+A,t[10]=d-g*u}else if(e.order==="XZY"){const d=o*l,f=o*c,A=a*l,g=a*c;t[0]=l*h,t[4]=-u,t[8]=c*h,t[1]=d*u+g,t[5]=o*h,t[9]=f*u-A,t[2]=A*u-f,t[6]=a*h,t[10]=g*u+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(bN,e,CN)}lookAt(e,t,i){const r=this.elements;return Zn.subVectors(e,t),Zn.lengthSq()===0&&(Zn.z=1),Zn.normalize(),ss.crossVectors(i,Zn),ss.lengthSq()===0&&(Math.abs(i.z)===1?Zn.x+=1e-4:Zn.z+=1e-4,Zn.normalize(),ss.crossVectors(i,Zn)),ss.normalize(),Eu.crossVectors(Zn,ss),r[0]=ss.x,r[4]=Eu.x,r[8]=Zn.x,r[1]=ss.y,r[5]=Eu.y,r[9]=Zn.y,r[2]=ss.z,r[6]=Eu.z,r[10]=Zn.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],h=i[1],u=i[5],d=i[9],f=i[13],A=i[2],g=i[6],m=i[10],p=i[14],v=i[3],E=i[7],x=i[11],M=i[15],w=r[0],S=r[4],B=r[8],y=r[12],_=r[1],L=r[5],Q=r[9],O=r[13],X=r[2],te=r[6],W=r[10],Z=r[14],q=r[3],re=r[7],ue=r[11],_e=r[15];return s[0]=o*w+a*_+l*X+c*q,s[4]=o*S+a*L+l*te+c*re,s[8]=o*B+a*Q+l*W+c*ue,s[12]=o*y+a*O+l*Z+c*_e,s[1]=h*w+u*_+d*X+f*q,s[5]=h*S+u*L+d*te+f*re,s[9]=h*B+u*Q+d*W+f*ue,s[13]=h*y+u*O+d*Z+f*_e,s[2]=A*w+g*_+m*X+p*q,s[6]=A*S+g*L+m*te+p*re,s[10]=A*B+g*Q+m*W+p*ue,s[14]=A*y+g*O+m*Z+p*_e,s[3]=v*w+E*_+x*X+M*q,s[7]=v*S+E*L+x*te+M*re,s[11]=v*B+E*Q+x*W+M*ue,s[15]=v*y+E*O+x*Z+M*_e,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],h=e[2],u=e[6],d=e[10],f=e[14],A=e[3],g=e[7],m=e[11],p=e[15];return A*(+s*l*u-r*c*u-s*a*d+i*c*d+r*a*f-i*l*f)+g*(+t*l*f-t*c*d+s*o*d-r*o*f+r*c*h-s*l*h)+m*(+t*c*u-t*a*f-s*o*u+i*o*f+s*a*h-i*c*h)+p*(-r*a*h-t*l*u+t*a*d+r*o*u-i*o*d+i*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=e[9],d=e[10],f=e[11],A=e[12],g=e[13],m=e[14],p=e[15],v=u*m*c-g*d*c+g*l*f-a*m*f-u*l*p+a*d*p,E=A*d*c-h*m*c-A*l*f+o*m*f+h*l*p-o*d*p,x=h*g*c-A*u*c+A*a*f-o*g*f-h*a*p+o*u*p,M=A*u*l-h*g*l-A*a*d+o*g*d+h*a*m-o*u*m,w=t*v+i*E+r*x+s*M;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/w;return e[0]=v*S,e[1]=(g*d*s-u*m*s-g*r*f+i*m*f+u*r*p-i*d*p)*S,e[2]=(a*m*s-g*l*s+g*r*c-i*m*c-a*r*p+i*l*p)*S,e[3]=(u*l*s-a*d*s-u*r*c+i*d*c+a*r*f-i*l*f)*S,e[4]=E*S,e[5]=(h*m*s-A*d*s+A*r*f-t*m*f-h*r*p+t*d*p)*S,e[6]=(A*l*s-o*m*s-A*r*c+t*m*c+o*r*p-t*l*p)*S,e[7]=(o*d*s-h*l*s+h*r*c-t*d*c-o*r*f+t*l*f)*S,e[8]=x*S,e[9]=(A*u*s-h*g*s-A*i*f+t*g*f+h*i*p-t*u*p)*S,e[10]=(o*g*s-A*a*s+A*i*c-t*g*c-o*i*p+t*a*p)*S,e[11]=(h*a*s-o*u*s-h*i*c+t*u*c+o*i*f-t*a*f)*S,e[12]=M*S,e[13]=(h*g*r-A*u*r+A*i*d-t*g*d-h*i*m+t*u*m)*S,e[14]=(A*a*r-o*g*r-A*i*l+t*g*l+o*i*m-t*a*m)*S,e[15]=(o*u*r-h*a*r+h*i*l-t*u*l-o*i*d+t*a*d)*S,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,c=s*o,h=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,h*a+i,h*l-r*o,0,c*l-r*a,h*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,s,o){return this.set(1,i,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,h=o+o,u=a+a,d=s*c,f=s*h,A=s*u,g=o*h,m=o*u,p=a*u,v=l*c,E=l*h,x=l*u,M=i.x,w=i.y,S=i.z;return r[0]=(1-(g+p))*M,r[1]=(f+x)*M,r[2]=(A-E)*M,r[3]=0,r[4]=(f-x)*w,r[5]=(1-(d+p))*w,r[6]=(m+v)*w,r[7]=0,r[8]=(A+E)*S,r[9]=(m-v)*S,r[10]=(1-(d+g))*S,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=Ea.set(r[0],r[1],r[2]).length();const o=Ea.set(r[4],r[5],r[6]).length(),a=Ea.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],Mi.copy(this);const c=1/s,h=1/o,u=1/a;return Mi.elements[0]*=c,Mi.elements[1]*=c,Mi.elements[2]*=c,Mi.elements[4]*=h,Mi.elements[5]*=h,Mi.elements[6]*=h,Mi.elements[8]*=u,Mi.elements[9]*=u,Mi.elements[10]*=u,t.setFromRotationMatrix(Mi),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o,a=Rr){const l=this.elements,c=2*s/(t-e),h=2*s/(i-r),u=(t+e)/(t-e),d=(i+r)/(i-r);let f,A;if(a===Rr)f=-(o+s)/(o-s),A=-2*o*s/(o-s);else if(a===nf)f=-o/(o-s),A=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=c,l[4]=0,l[8]=u,l[12]=0,l[1]=0,l[5]=h,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=f,l[14]=A,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,i,r,s,o,a=Rr){const l=this.elements,c=1/(t-e),h=1/(i-r),u=1/(o-s),d=(t+e)*c,f=(i+r)*h;let A,g;if(a===Rr)A=(o+s)*u,g=-2*u;else if(a===nf)A=s*u,g=-1*u;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-f,l[2]=0,l[6]=0,l[10]=g,l[14]=-A,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}const Ea=new ye,Mi=new $t,bN=new ye(0,0,0),CN=new ye(1,1,1),ss=new ye,Eu=new ye,Zn=new ye,A_=new $t,g_=new Vr;class Oi{constructor(e=0,t=0,i=0,r=Oi.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],h=r[9],u=r[2],d=r[6],f=r[10];switch(t){case"XYZ":this._y=Math.asin(Ct(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Ct(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ct(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Ct(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Ct(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-u,s)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-Ct(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return A_.makeRotationFromQuaternion(e),this.setFromRotationMatrix(A_,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return g_.setFromEuler(this),this.setFromQuaternion(g_,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Oi.DEFAULT_ORDER="XYZ";class yv{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let MN=0;const v_=new ye,xa=new Vr,pr=new $t,xu=new ye,Nl=new ye,SN=new ye,wN=new Vr,E_=new ye(1,0,0),x_=new ye(0,1,0),y_=new ye(0,0,1),__={type:"added"},TN={type:"removed"},ya={type:"childadded",child:null},qm={type:"childremoved",child:null};class ri extends Fo{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:MN++}),this.uuid=al(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ri.DEFAULT_UP.clone();const e=new ye,t=new Oi,i=new Vr,r=new ye(1,1,1);function s(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new $t},normalMatrix:{value:new Et}}),this.matrix=new $t,this.matrixWorld=new $t,this.matrixAutoUpdate=ri.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=ri.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new yv,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return xa.setFromAxisAngle(e,t),this.quaternion.multiply(xa),this}rotateOnWorldAxis(e,t){return xa.setFromAxisAngle(e,t),this.quaternion.premultiply(xa),this}rotateX(e){return this.rotateOnAxis(E_,e)}rotateY(e){return this.rotateOnAxis(x_,e)}rotateZ(e){return this.rotateOnAxis(y_,e)}translateOnAxis(e,t){return v_.copy(e).applyQuaternion(this.quaternion),this.position.add(v_.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(E_,e)}translateY(e){return this.translateOnAxis(x_,e)}translateZ(e){return this.translateOnAxis(y_,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(pr.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?xu.copy(e):xu.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),Nl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?pr.lookAt(Nl,xu,this.up):pr.lookAt(xu,Nl,this.up),this.quaternion.setFromRotationMatrix(pr),r&&(pr.extractRotation(r.matrixWorld),xa.setFromRotationMatrix(pr),this.quaternion.premultiply(xa.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(__),ya.child=e,this.dispatchEvent(ya),ya.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(TN),qm.child=e,this.dispatchEvent(qm),qm.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),pr.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),pr.multiply(e.parent.matrixWorld)),e.applyMatrix4(pr),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(__),ya.child=e,this.dispatchEvent(ya),ya.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,i=[]){this[e]===t&&i.push(this);const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].getObjectsByProperty(e,t,i);return i}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Nl,e,SN),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Nl,wN,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(r.type="BatchedMesh",r.perObjectFrustumCulled=this.perObjectFrustumCulled,r.sortObjects=this.sortObjects,r.drawRanges=this._drawRanges,r.reservedRanges=this._reservedRanges,r.visibility=this._visibility,r.active=this._active,r.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),r.maxInstanceCount=this._maxInstanceCount,r.maxVertexCount=this._maxVertexCount,r.maxIndexCount=this._maxIndexCount,r.geometryInitialized=this._geometryInitialized,r.geometryCount=this._geometryCount,r.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(r.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(r.boundingSphere={center:r.boundingSphere.center.toArray(),radius:r.boundingSphere.radius}),this.boundingBox!==null&&(r.boundingBox={min:r.boundingBox.min.toArray(),max:r.boundingBox.max.toArray()}));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const u=l[c];s(e.shapes,u)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),h=o(e.images),u=o(e.shapes),d=o(e.skeletons),f=o(e.animations),A=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),h.length>0&&(i.images=h),u.length>0&&(i.shapes=u),d.length>0&&(i.skeletons=d),f.length>0&&(i.animations=f),A.length>0&&(i.nodes=A)}return i.object=r,i;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const r=e.children[i];this.add(r.clone())}return this}}ri.DEFAULT_UP=new ye(0,1,0);ri.DEFAULT_MATRIX_AUTO_UPDATE=!0;ri.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Si=new ye,mr=new ye,Ym=new ye,Ar=new ye,_a=new ye,ba=new ye,b_=new ye,jm=new ye,$m=new ye,Km=new ye,Jm=new jt,Zm=new jt,eA=new jt;class Bi{constructor(e=new ye,t=new ye,i=new ye){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),Si.subVectors(e,t),r.cross(Si);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){Si.subVectors(r,t),mr.subVectors(i,t),Ym.subVectors(e,t);const o=Si.dot(Si),a=Si.dot(mr),l=Si.dot(Ym),c=mr.dot(mr),h=mr.dot(Ym),u=o*c-a*a;if(u===0)return s.set(0,0,0),null;const d=1/u,f=(c*l-a*h)*d,A=(o*h-a*l)*d;return s.set(1-f-A,A,f)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,Ar)===null?!1:Ar.x>=0&&Ar.y>=0&&Ar.x+Ar.y<=1}static getInterpolation(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,Ar)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(s,Ar.x),l.addScaledVector(o,Ar.y),l.addScaledVector(a,Ar.z),l)}static getInterpolatedAttribute(e,t,i,r,s,o){return Jm.setScalar(0),Zm.setScalar(0),eA.setScalar(0),Jm.fromBufferAttribute(e,t),Zm.fromBufferAttribute(e,i),eA.fromBufferAttribute(e,r),o.setScalar(0),o.addScaledVector(Jm,s.x),o.addScaledVector(Zm,s.y),o.addScaledVector(eA,s.z),o}static isFrontFacing(e,t,i,r){return Si.subVectors(i,t),mr.subVectors(e,t),Si.cross(mr).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Si.subVectors(this.c,this.b),mr.subVectors(this.a,this.b),Si.cross(mr).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Bi.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Bi.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,i,r,s){return Bi.getInterpolation(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return Bi.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Bi.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,s=this.c;let o,a;_a.subVectors(r,i),ba.subVectors(s,i),jm.subVectors(e,i);const l=_a.dot(jm),c=ba.dot(jm);if(l<=0&&c<=0)return t.copy(i);$m.subVectors(e,r);const h=_a.dot($m),u=ba.dot($m);if(h>=0&&u<=h)return t.copy(r);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),t.copy(i).addScaledVector(_a,o);Km.subVectors(e,s);const f=_a.dot(Km),A=ba.dot(Km);if(A>=0&&f<=A)return t.copy(s);const g=f*c-l*A;if(g<=0&&c>=0&&A<=0)return a=c/(c-A),t.copy(i).addScaledVector(ba,a);const m=h*A-f*u;if(m<=0&&u-h>=0&&f-A>=0)return b_.subVectors(s,r),a=(u-h)/(u-h+(f-A)),t.copy(r).addScaledVector(b_,a);const p=1/(m+g+d);return o=g*p,a=d*p,t.copy(i).addScaledVector(_a,o).addScaledVector(ba,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const JS={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},os={h:0,s:0,l:0},yu={h:0,s:0,l:0};function tA(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class kt{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,i)}set(e,t,i){if(t===void 0&&i===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,i);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=pi){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Rt.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=Rt.workingColorSpace){return this.r=e,this.g=t,this.b=i,Rt.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=Rt.workingColorSpace){if(e=vv(e,1),t=Ct(t,0,1),i=Ct(i,0,1),t===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+t):i+t-i*t,o=2*i-s;this.r=tA(o,s,e+1/3),this.g=tA(o,s,e),this.b=tA(o,s,e-1/3)}return Rt.toWorkingColorSpace(this,r),this}setStyle(e,t=pi){function i(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=pi){const i=JS[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Nr(e.r),this.g=Nr(e.g),this.b=Nr(e.b),this}copyLinearToSRGB(e){return this.r=Wa(e.r),this.g=Wa(e.g),this.b=Wa(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=pi){return Rt.fromWorkingColorSpace(Sn.copy(this),e),Math.round(Ct(Sn.r*255,0,255))*65536+Math.round(Ct(Sn.g*255,0,255))*256+Math.round(Ct(Sn.b*255,0,255))}getHexString(e=pi){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Rt.workingColorSpace){Rt.fromWorkingColorSpace(Sn.copy(this),t);const i=Sn.r,r=Sn.g,s=Sn.b,o=Math.max(i,r,s),a=Math.min(i,r,s);let l,c;const h=(a+o)/2;if(a===o)l=0,c=0;else{const u=o-a;switch(c=h<=.5?u/(o+a):u/(2-o-a),o){case i:l=(r-s)/u+(r<s?6:0);break;case r:l=(s-i)/u+2;break;case s:l=(i-r)/u+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=Rt.workingColorSpace){return Rt.fromWorkingColorSpace(Sn.copy(this),t),e.r=Sn.r,e.g=Sn.g,e.b=Sn.b,e}getStyle(e=pi){Rt.fromWorkingColorSpace(Sn.copy(this),e);const t=Sn.r,i=Sn.g,r=Sn.b;return e!==pi?`color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(r*255)})`}offsetHSL(e,t,i){return this.getHSL(os),this.setHSL(os.h+e,os.s+t,os.l+i)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(os),e.getHSL(yu);const i=nc(os.h,yu.h,t),r=nc(os.s,yu.s,t),s=nc(os.l,yu.l,t);return this.setHSL(i,r,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,i=this.g,r=this.b,s=e.elements;return this.r=s[0]*t+s[3]*i+s[6]*r,this.g=s[1]*t+s[4]*i+s[7]*r,this.b=s[2]*t+s[5]*i+s[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Sn=new kt;kt.NAMES=JS;let IN=0;class Yf extends Fo{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:IN++}),this.uuid=al(),this.name="",this.type="Material",this.blending=Qa,this.side=ws,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=rg,this.blendDst=sg,this.blendEquation=po,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new kt(0,0,0),this.blendAlpha=0,this.depthFunc=Ka,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=l_,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=pa,this.stencilZFail=pa,this.stencilZPass=pa,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Qa&&(i.blending=this.blending),this.side!==ws&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==rg&&(i.blendSrc=this.blendSrc),this.blendDst!==sg&&(i.blendDst=this.blendDst),this.blendEquation!==po&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==Ka&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==l_&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==pa&&(i.stencilFail=this.stencilFail),this.stencilZFail!==pa&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==pa&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function r(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(i.textures=s),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const r=t.length;i=new Array(r);for(let s=0;s!==r;++s)i[s]=t[s].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class ZS extends Yf{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new kt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Oi,this.combine=FS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Zt=new ye,_u=new zt;let RN=0;class Zi{constructor(e,t,i=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:RN++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i,this.usage=c_,this.updateRanges=[],this.gpuType=Ir,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[i+r];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)_u.fromBufferAttribute(this,t),_u.applyMatrix3(e),this.setXY(t,_u.x,_u.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Zt.fromBufferAttribute(this,t),Zt.applyMatrix3(e),this.setXYZ(t,Zt.x,Zt.y,Zt.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Zt.fromBufferAttribute(this,t),Zt.applyMatrix4(e),this.setXYZ(t,Zt.x,Zt.y,Zt.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Zt.fromBufferAttribute(this,t),Zt.applyNormalMatrix(e),this.setXYZ(t,Zt.x,Zt.y,Zt.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Zt.fromBufferAttribute(this,t),Zt.transformDirection(e),this.setXYZ(t,Zt.x,Zt.y,Zt.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let i=this.array[e*this.itemSize+t];return this.normalized&&(i=Ra(i,this.array)),i}setComponent(e,t,i){return this.normalized&&(i=Bn(i,this.array)),this.array[e*this.itemSize+t]=i,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Ra(t,this.array)),t}setX(e,t){return this.normalized&&(t=Bn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Ra(t,this.array)),t}setY(e,t){return this.normalized&&(t=Bn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Ra(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Bn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Ra(t,this.array)),t}setW(e,t){return this.normalized&&(t=Bn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=Bn(t,this.array),i=Bn(i,this.array)),this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,r){return e*=this.itemSize,this.normalized&&(t=Bn(t,this.array),i=Bn(i,this.array),r=Bn(r,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.normalized&&(t=Bn(t,this.array),i=Bn(i,this.array),r=Bn(r,this.array),s=Bn(s,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==c_&&(e.usage=this.usage),e}}class ew extends Zi{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class tw extends Zi{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class wo extends Zi{constructor(e,t,i){super(new Float32Array(e),t,i)}}let BN=0;const hi=new $t,nA=new ri,Ca=new ye,ei=new Wc,Ol=new Wc,pn=new ye;class No extends Fo{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:BN++}),this.uuid=al(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(jS(e)?tw:ew)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const s=new Et().getNormalMatrix(e);i.applyNormalMatrix(s),i.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return hi.makeRotationFromQuaternion(e),this.applyMatrix4(hi),this}rotateX(e){return hi.makeRotationX(e),this.applyMatrix4(hi),this}rotateY(e){return hi.makeRotationY(e),this.applyMatrix4(hi),this}rotateZ(e){return hi.makeRotationZ(e),this.applyMatrix4(hi),this}translate(e,t,i){return hi.makeTranslation(e,t,i),this.applyMatrix4(hi),this}scale(e,t,i){return hi.makeScale(e,t,i),this.applyMatrix4(hi),this}lookAt(e){return nA.lookAt(e),nA.updateMatrix(),this.applyMatrix4(nA.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ca).negate(),this.translate(Ca.x,Ca.y,Ca.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const i=[];for(let r=0,s=e.length;r<s;r++){const o=e[r];i.push(o.x,o.y,o.z||0)}this.setAttribute("position",new wo(i,3))}else{const i=Math.min(e.length,t.count);for(let r=0;r<i;r++){const s=e[r];t.setXYZ(r,s.x,s.y,s.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Wc);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new ye(-1/0,-1/0,-1/0),new ye(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,r=t.length;i<r;i++){const s=t[i];ei.setFromBufferAttribute(s),this.morphTargetsRelative?(pn.addVectors(this.boundingBox.min,ei.min),this.boundingBox.expandByPoint(pn),pn.addVectors(this.boundingBox.max,ei.max),this.boundingBox.expandByPoint(pn)):(this.boundingBox.expandByPoint(ei.min),this.boundingBox.expandByPoint(ei.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new xv);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new ye,1/0);return}if(e){const i=this.boundingSphere.center;if(ei.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];Ol.setFromBufferAttribute(a),this.morphTargetsRelative?(pn.addVectors(ei.min,Ol.min),ei.expandByPoint(pn),pn.addVectors(ei.max,Ol.max),ei.expandByPoint(pn)):(ei.expandByPoint(Ol.min),ei.expandByPoint(Ol.max))}ei.getCenter(i);let r=0;for(let s=0,o=e.count;s<o;s++)pn.fromBufferAttribute(e,s),r=Math.max(r,i.distanceToSquared(pn));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)pn.fromBufferAttribute(a,c),l&&(Ca.fromBufferAttribute(e,c),pn.add(Ca)),r=Math.max(r,i.distanceToSquared(pn))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=t.position,r=t.normal,s=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Zi(new Float32Array(4*i.count),4));const o=this.getAttribute("tangent"),a=[],l=[];for(let B=0;B<i.count;B++)a[B]=new ye,l[B]=new ye;const c=new ye,h=new ye,u=new ye,d=new zt,f=new zt,A=new zt,g=new ye,m=new ye;function p(B,y,_){c.fromBufferAttribute(i,B),h.fromBufferAttribute(i,y),u.fromBufferAttribute(i,_),d.fromBufferAttribute(s,B),f.fromBufferAttribute(s,y),A.fromBufferAttribute(s,_),h.sub(c),u.sub(c),f.sub(d),A.sub(d);const L=1/(f.x*A.y-A.x*f.y);isFinite(L)&&(g.copy(h).multiplyScalar(A.y).addScaledVector(u,-f.y).multiplyScalar(L),m.copy(u).multiplyScalar(f.x).addScaledVector(h,-A.x).multiplyScalar(L),a[B].add(g),a[y].add(g),a[_].add(g),l[B].add(m),l[y].add(m),l[_].add(m))}let v=this.groups;v.length===0&&(v=[{start:0,count:e.count}]);for(let B=0,y=v.length;B<y;++B){const _=v[B],L=_.start,Q=_.count;for(let O=L,X=L+Q;O<X;O+=3)p(e.getX(O+0),e.getX(O+1),e.getX(O+2))}const E=new ye,x=new ye,M=new ye,w=new ye;function S(B){M.fromBufferAttribute(r,B),w.copy(M);const y=a[B];E.copy(y),E.sub(M.multiplyScalar(M.dot(y))).normalize(),x.crossVectors(w,y);const L=x.dot(l[B])<0?-1:1;o.setXYZW(B,E.x,E.y,E.z,L)}for(let B=0,y=v.length;B<y;++B){const _=v[B],L=_.start,Q=_.count;for(let O=L,X=L+Q;O<X;O+=3)S(e.getX(O+0)),S(e.getX(O+1)),S(e.getX(O+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new Zi(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let d=0,f=i.count;d<f;d++)i.setXYZ(d,0,0,0);const r=new ye,s=new ye,o=new ye,a=new ye,l=new ye,c=new ye,h=new ye,u=new ye;if(e)for(let d=0,f=e.count;d<f;d+=3){const A=e.getX(d+0),g=e.getX(d+1),m=e.getX(d+2);r.fromBufferAttribute(t,A),s.fromBufferAttribute(t,g),o.fromBufferAttribute(t,m),h.subVectors(o,s),u.subVectors(r,s),h.cross(u),a.fromBufferAttribute(i,A),l.fromBufferAttribute(i,g),c.fromBufferAttribute(i,m),a.add(h),l.add(h),c.add(h),i.setXYZ(A,a.x,a.y,a.z),i.setXYZ(g,l.x,l.y,l.z),i.setXYZ(m,c.x,c.y,c.z)}else for(let d=0,f=t.count;d<f;d+=3)r.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),h.subVectors(o,s),u.subVectors(r,s),h.cross(u),i.setXYZ(d+0,h.x,h.y,h.z),i.setXYZ(d+1,h.x,h.y,h.z),i.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)pn.fromBufferAttribute(e,t),pn.normalize(),e.setXYZ(t,pn.x,pn.y,pn.z)}toNonIndexed(){function e(a,l){const c=a.array,h=a.itemSize,u=a.normalized,d=new c.constructor(l.length*h);let f=0,A=0;for(let g=0,m=l.length;g<m;g++){a.isInterleavedBufferAttribute?f=l[g]*a.data.stride+a.offset:f=l[g]*h;for(let p=0;p<h;p++)d[A++]=c[f++]}return new Zi(d,h,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new No,i=this.index.array,r=this.attributes;for(const a in r){const l=r[a],c=e(l,i);t.setAttribute(a,c)}const s=this.morphAttributes;for(const a in s){const l=[],c=s[a];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=e(d,i);l.push(f)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const l in i){const c=i[l];e.data.attributes[l]=c.toJSON(e.data)}const r={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u];h.push(f.toJSON(e.data))}h.length>0&&(r[l]=h,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone());const r=e.attributes;for(const c in r){const h=r[c];this.setAttribute(c,h.clone(t))}const s=e.morphAttributes;for(const c in s){const h=[],u=s[c];for(let d=0,f=u.length;d<f;d++)h.push(u[d].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,h=o.length;c<h;c++){const u=o[c];this.addGroup(u.start,u.count,u.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const C_=new $t,ro=new KS,bu=new xv,M_=new ye,Cu=new ye,Mu=new ye,Su=new ye,iA=new ye,wu=new ye,S_=new ye,Tu=new ye;class Br extends ri{constructor(e=new No,t=new ZS){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const i=this.geometry,r=i.attributes.position,s=i.morphAttributes.position,o=i.morphTargetsRelative;t.fromBufferAttribute(r,e);const a=this.morphTargetInfluences;if(s&&a){wu.set(0,0,0);for(let l=0,c=s.length;l<c;l++){const h=a[l],u=s[l];h!==0&&(iA.fromBufferAttribute(u,e),o?wu.addScaledVector(iA,h):wu.addScaledVector(iA.sub(t),h))}t.add(wu)}return t}raycast(e,t){const i=this.geometry,r=this.material,s=this.matrixWorld;r!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),bu.copy(i.boundingSphere),bu.applyMatrix4(s),ro.copy(e.ray).recast(e.near),!(bu.containsPoint(ro.origin)===!1&&(ro.intersectSphere(bu,M_)===null||ro.origin.distanceToSquared(M_)>(e.far-e.near)**2))&&(C_.copy(s).invert(),ro.copy(e.ray).applyMatrix4(C_),!(i.boundingBox!==null&&ro.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(e,t,ro)))}_computeIntersections(e,t,i){let r;const s=this.geometry,o=this.material,a=s.index,l=s.attributes.position,c=s.attributes.uv,h=s.attributes.uv1,u=s.attributes.normal,d=s.groups,f=s.drawRange;if(a!==null)if(Array.isArray(o))for(let A=0,g=d.length;A<g;A++){const m=d[A],p=o[m.materialIndex],v=Math.max(m.start,f.start),E=Math.min(a.count,Math.min(m.start+m.count,f.start+f.count));for(let x=v,M=E;x<M;x+=3){const w=a.getX(x),S=a.getX(x+1),B=a.getX(x+2);r=Iu(this,p,e,i,c,h,u,w,S,B),r&&(r.faceIndex=Math.floor(x/3),r.face.materialIndex=m.materialIndex,t.push(r))}}else{const A=Math.max(0,f.start),g=Math.min(a.count,f.start+f.count);for(let m=A,p=g;m<p;m+=3){const v=a.getX(m),E=a.getX(m+1),x=a.getX(m+2);r=Iu(this,o,e,i,c,h,u,v,E,x),r&&(r.faceIndex=Math.floor(m/3),t.push(r))}}else if(l!==void 0)if(Array.isArray(o))for(let A=0,g=d.length;A<g;A++){const m=d[A],p=o[m.materialIndex],v=Math.max(m.start,f.start),E=Math.min(l.count,Math.min(m.start+m.count,f.start+f.count));for(let x=v,M=E;x<M;x+=3){const w=x,S=x+1,B=x+2;r=Iu(this,p,e,i,c,h,u,w,S,B),r&&(r.faceIndex=Math.floor(x/3),r.face.materialIndex=m.materialIndex,t.push(r))}}else{const A=Math.max(0,f.start),g=Math.min(l.count,f.start+f.count);for(let m=A,p=g;m<p;m+=3){const v=m,E=m+1,x=m+2;r=Iu(this,o,e,i,c,h,u,v,E,x),r&&(r.faceIndex=Math.floor(m/3),t.push(r))}}}}function LN(n,e,t,i,r,s,o,a){let l;if(e.side===jn?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,e.side===ws,a),l===null)return null;Tu.copy(a),Tu.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(Tu);return c<t.near||c>t.far?null:{distance:c,point:Tu.clone(),object:n}}function Iu(n,e,t,i,r,s,o,a,l,c){n.getVertexPosition(a,Cu),n.getVertexPosition(l,Mu),n.getVertexPosition(c,Su);const h=LN(n,e,t,i,Cu,Mu,Su,S_);if(h){const u=new ye;Bi.getBarycoord(S_,Cu,Mu,Su,u),r&&(h.uv=Bi.getInterpolatedAttribute(r,a,l,c,u,new zt)),s&&(h.uv1=Bi.getInterpolatedAttribute(s,a,l,c,u,new zt)),o&&(h.normal=Bi.getInterpolatedAttribute(o,a,l,c,u,new ye),h.normal.dot(i.direction)>0&&h.normal.multiplyScalar(-1));const d={a,b:l,c,normal:new ye,materialIndex:0};Bi.getNormal(Cu,Mu,Su,d.normal),h.face=d,h.barycoord=u}return h}class Xc extends No{constructor(e=1,t=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],h=[],u=[];let d=0,f=0;A("z","y","x",-1,-1,i,t,e,o,s,0),A("z","y","x",1,-1,i,t,-e,o,s,1),A("x","z","y",1,1,e,i,t,r,o,2),A("x","z","y",1,-1,e,i,-t,r,o,3),A("x","y","z",1,-1,e,t,i,r,s,4),A("x","y","z",-1,-1,e,t,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new wo(c,3)),this.setAttribute("normal",new wo(h,3)),this.setAttribute("uv",new wo(u,2));function A(g,m,p,v,E,x,M,w,S,B,y){const _=x/S,L=M/B,Q=x/2,O=M/2,X=w/2,te=S+1,W=B+1;let Z=0,q=0;const re=new ye;for(let ue=0;ue<W;ue++){const _e=ue*L-O;for(let Be=0;Be<te;Be++){const ze=Be*_-Q;re[g]=ze*v,re[m]=_e*E,re[p]=X,c.push(re.x,re.y,re.z),re[g]=0,re[m]=0,re[p]=w>0?1:-1,h.push(re.x,re.y,re.z),u.push(Be/S),u.push(1-ue/B),Z+=1}}for(let ue=0;ue<B;ue++)for(let _e=0;_e<S;_e++){const Be=d+_e+te*ue,ze=d+_e+te*(ue+1),le=d+(_e+1)+te*(ue+1),Ee=d+(_e+1)+te*ue;l.push(Be,ze,Ee),l.push(ze,le,Ee),q+=6}a.addGroup(f,q,y),f+=q,d+=Z}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Xc(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function tl(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][i]=null):e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function Dn(n){const e={};for(let t=0;t<n.length;t++){const i=tl(n[t]);for(const r in i)e[r]=i[r]}return e}function DN(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function nw(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:Rt.workingColorSpace}const PN={clone:tl,merge:Dn};var UN=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,FN=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Ts extends Yf{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=UN,this.fragmentShader=FN,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=tl(e.uniforms),this.uniformsGroups=DN(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const i={};for(const r in this.extensions)this.extensions[r]===!0&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}class iw extends ri{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new $t,this.projectionMatrix=new $t,this.projectionMatrixInverse=new $t,this.coordinateSystem=Rr}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const as=new ye,w_=new zt,T_=new zt;class Ri extends iw{constructor(e=50,t=1,i=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Rc*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(tc*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Rc*2*Math.atan(Math.tan(tc*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,i){as.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(as.x,as.y).multiplyScalar(-e/as.z),as.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(as.x,as.y).multiplyScalar(-e/as.z)}getViewSize(e,t){return this.getViewBounds(e,w_,T_),t.subVectors(T_,w_)}setViewOffset(e,t,i,r,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(tc*.5*this.fov)/this.zoom,i=2*t,r=this.aspect*i,s=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;s+=o.offsetX*r/l,t-=o.offsetY*i/c,r*=o.width/l,i*=o.height/c}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-i,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ma=-90,Sa=1;class NN extends ri{constructor(e,t,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new Ri(Ma,Sa,e,t);r.layers=this.layers,this.add(r);const s=new Ri(Ma,Sa,e,t);s.layers=this.layers,this.add(s);const o=new Ri(Ma,Sa,e,t);o.layers=this.layers,this.add(o);const a=new Ri(Ma,Sa,e,t);a.layers=this.layers,this.add(a);const l=new Ri(Ma,Sa,e,t);l.layers=this.layers,this.add(l);const c=new Ri(Ma,Sa,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[i,r,s,o,a,l]=t;for(const c of t)this.remove(c);if(e===Rr)i.up.set(0,1,0),i.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===nf)i.up.set(0,-1,0),i.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:r}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,o,a,l,c,h]=this.children,u=e.getRenderTarget(),d=e.getActiveCubeFace(),f=e.getActiveMipmapLevel(),A=e.xr.enabled;e.xr.enabled=!1;const g=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0,r),e.render(t,s),e.setRenderTarget(i,1,r),e.render(t,o),e.setRenderTarget(i,2,r),e.render(t,a),e.setRenderTarget(i,3,r),e.render(t,l),e.setRenderTarget(i,4,r),e.render(t,c),i.texture.generateMipmaps=g,e.setRenderTarget(i,5,r),e.render(t,h),e.setRenderTarget(u,d,f),e.xr.enabled=A,i.texture.needsPMREMUpdate=!0}}class rw extends zn{constructor(e=[],t=Ja,i,r,s,o,a,l,c,h){super(e,t,i,r,s,o,a,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class ON extends Do{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const i={width:e,height:e,depth:1},r=[i,i,i,i,i,i];this.texture=new rw(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Ai}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Xc(5,5,5),s=new Ts({name:"CubemapFromEquirect",uniforms:tl(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:jn,blending:ys});s.uniforms.tEquirect.value=t;const o=new Br(r,s),a=t.minFilter;return t.minFilter===_o&&(t.minFilter=Ai),new NN(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t=!0,i=!0,r=!0){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,r);e.setRenderTarget(s)}}class Ru extends ri{constructor(){super(),this.isGroup=!0,this.type="Group"}}const kN={type:"move"};class rA{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ru,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ru,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ye,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ye),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ru,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ye,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ye),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const i of e.hand.values())this._getHandJoint(t,i)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let r=null,s=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const g of e.hand.values()){const m=t.getJointPose(g,i),p=this._getHandJoint(c,g);m!==null&&(p.matrix.fromArray(m.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale),p.matrixWorldNeedsUpdate=!0,p.jointRadius=m.radius),p.visible=m!==null}const h=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],d=h.position.distanceTo(u.position),f=.02,A=.005;c.inputState.pinching&&d>f+A?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=f-A&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,i),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(r=t.getPose(e.targetRaySpace,i),r===null&&s!==null&&(r=s),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(kN)))}return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const i=new Ru;i.matrixAutoUpdate=!1,i.visible=!1,e.joints[t.jointName]=i,e.add(i)}return e.joints[t.jointName]}}class GN extends ri{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Oi,this.environmentIntensity=1,this.environmentRotation=new Oi,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}const sA=new ye,zN=new ye,HN=new Et;class ho{constructor(e=new ye(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=sA.subVectors(i,t).cross(zN.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const i=e.delta(sA),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(e.start).addScaledVector(i,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||HN.getNormalMatrix(e),r=this.coplanarPoint(sA).applyMatrix4(e),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const so=new xv,Bu=new ye;class sw{constructor(e=new ho,t=new ho,i=new ho,r=new ho,s=new ho,o=new ho){this.planes=[e,t,i,r,s,o]}set(e,t,i,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e,t=Rr){const i=this.planes,r=e.elements,s=r[0],o=r[1],a=r[2],l=r[3],c=r[4],h=r[5],u=r[6],d=r[7],f=r[8],A=r[9],g=r[10],m=r[11],p=r[12],v=r[13],E=r[14],x=r[15];if(i[0].setComponents(l-s,d-c,m-f,x-p).normalize(),i[1].setComponents(l+s,d+c,m+f,x+p).normalize(),i[2].setComponents(l+o,d+h,m+A,x+v).normalize(),i[3].setComponents(l-o,d-h,m-A,x-v).normalize(),i[4].setComponents(l-a,d-u,m-g,x-E).normalize(),t===Rr)i[5].setComponents(l+a,d+u,m+g,x+E).normalize();else if(t===nf)i[5].setComponents(a,u,g,E).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),so.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),so.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(so)}intersectsSprite(e){return so.center.set(0,0,0),so.radius=.7071067811865476,so.applyMatrix4(e.matrixWorld),this.intersectsSphere(so)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(Bu.x=r.normal.x>0?e.max.x:e.min.x,Bu.y=r.normal.y>0?e.max.y:e.min.y,Bu.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Bu)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class VN extends zn{constructor(e,t,i,r,s=Ai,o=Ai,a,l,c){super(e,t,i,r,s,o,a,l,c),this.isVideoTexture=!0,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,e.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class ow extends zn{constructor(e,t,i=Lo,r,s,o,a=Pi,l=Pi,c,h=Tc){if(h!==Tc&&h!==Ic)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super(null,r,s,o,a,l,h,i,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new Ev(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class jf extends No{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(i),l=Math.floor(r),c=a+1,h=l+1,u=e/a,d=t/l,f=[],A=[],g=[],m=[];for(let p=0;p<h;p++){const v=p*d-o;for(let E=0;E<c;E++){const x=E*u-s;A.push(x,-v,0),g.push(0,0,1),m.push(E/a),m.push(1-p/l)}}for(let p=0;p<l;p++)for(let v=0;v<a;v++){const E=v+c*p,x=v+c*(p+1),M=v+1+c*(p+1),w=v+1+c*p;f.push(E,x,w),f.push(x,M,w)}this.setIndex(f),this.setAttribute("position",new wo(A,3)),this.setAttribute("normal",new wo(g,3)),this.setAttribute("uv",new wo(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new jf(e.width,e.height,e.widthSegments,e.heightSegments)}}class QN extends Yf{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=k3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class WN extends Yf{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class XN extends iw{constructor(e=-1,t=1,i=1,r=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=i-e,o=i+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class qN extends Ri{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e,this.index=0}}const I_=new $t;class YN{constructor(e,t,i=0,r=1/0){this.ray=new KS(e,t),this.near=i,this.far=r,this.camera=null,this.layers=new yv,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return I_.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(I_),this}intersectObject(e,t=!0,i=[]){return Vg(e,this,i,t),i.sort(R_),i}intersectObjects(e,t=!0,i=[]){for(let r=0,s=e.length;r<s;r++)Vg(e[r],this,i,t);return i.sort(R_),i}}function R_(n,e){return n.distance-e.distance}function Vg(n,e,t,i){let r=!0;if(n.layers.test(e.layers)&&n.raycast(e,t)===!1&&(r=!1),r===!0&&i===!0){const s=n.children;for(let o=0,a=s.length;o<a;o++)Vg(s[o],e,t,!0)}}function B_(n,e,t,i){const r=jN(i);switch(t){case zS:return n*e;case VS:return n*e;case QS:return n*e*2;case WS:return n*e/r.components*r.byteLength;case mv:return n*e/r.components*r.byteLength;case XS:return n*e*2/r.components*r.byteLength;case Av:return n*e*2/r.components*r.byteLength;case HS:return n*e*3/r.components*r.byteLength;case Di:return n*e*4/r.components*r.byteLength;case gv:return n*e*4/r.components*r.byteLength;case qu:case Yu:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case ju:case $u:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case vg:case xg:return Math.max(n,16)*Math.max(e,8)/4;case gg:case Eg:return Math.max(n,8)*Math.max(e,8)/2;case yg:case _g:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case bg:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case Cg:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case Mg:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case Sg:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case wg:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case Tg:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case Ig:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case Rg:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case Bg:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case Lg:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case Dg:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case Pg:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case Ug:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case Fg:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case Ng:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case Ku:case Og:case kg:return Math.ceil(n/4)*Math.ceil(e/4)*16;case qS:case Gg:return Math.ceil(n/4)*Math.ceil(e/4)*8;case zg:case Hg:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function jN(n){switch(n){case Hr:case OS:return{byteLength:1,components:1};case Sc:case kS:case Qc:return{byteLength:2,components:1};case fv:case pv:return{byteLength:2,components:4};case Lo:case dv:case Ir:return{byteLength:4,components:1};case GS:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:uv}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=uv);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function aw(){let n=null,e=!1,t=null,i=null;function r(s,o){t(s,o),i=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function $N(n){const e=new WeakMap;function t(a,l){const c=a.array,h=a.usage,u=c.byteLength,d=n.createBuffer();n.bindBuffer(l,d),n.bufferData(l,c,h),a.onUploadCallback();let f;if(c instanceof Float32Array)f=n.FLOAT;else if(c instanceof Uint16Array)a.isFloat16BufferAttribute?f=n.HALF_FLOAT:f=n.UNSIGNED_SHORT;else if(c instanceof Int16Array)f=n.SHORT;else if(c instanceof Uint32Array)f=n.UNSIGNED_INT;else if(c instanceof Int32Array)f=n.INT;else if(c instanceof Int8Array)f=n.BYTE;else if(c instanceof Uint8Array)f=n.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)f=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:d,type:f,bytesPerElement:c.BYTES_PER_ELEMENT,version:a.version,size:u}}function i(a,l,c){const h=l.array,u=l.updateRanges;if(n.bindBuffer(c,a),u.length===0)n.bufferSubData(c,0,h);else{u.sort((f,A)=>f.start-A.start);let d=0;for(let f=1;f<u.length;f++){const A=u[d],g=u[f];g.start<=A.start+A.count+1?A.count=Math.max(A.count,g.start+g.count-A.start):(++d,u[d]=g)}u.length=d+1;for(let f=0,A=u.length;f<A;f++){const g=u[f];n.bufferSubData(c,g.start*h.BYTES_PER_ELEMENT,h,g.start,g.count)}l.clearUpdateRanges()}l.onUploadCallback()}function r(a){return a.isInterleavedBufferAttribute&&(a=a.data),e.get(a)}function s(a){a.isInterleavedBufferAttribute&&(a=a.data);const l=e.get(a);l&&(n.deleteBuffer(l.buffer),e.delete(a))}function o(a,l){if(a.isInterleavedBufferAttribute&&(a=a.data),a.isGLBufferAttribute){const h=e.get(a);(!h||h.version<a.version)&&e.set(a,{buffer:a.buffer,type:a.type,bytesPerElement:a.elementSize,version:a.version});return}const c=e.get(a);if(c===void 0)e.set(a,t(a,l));else if(c.version<a.version){if(c.size!==a.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");i(c.buffer,a,l),c.version=a.version}}return{get:r,remove:s,update:o}}var KN=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,JN=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,ZN=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,eO=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,tO=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,nO=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,iO=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,rO=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,sO=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,oO=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,aO=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,lO=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,cO=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,hO=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,uO=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,dO=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,fO=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,pO=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,mO=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,AO=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,gO=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,vO=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,EO=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,xO=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,yO=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,_O=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,bO=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,CO=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,MO=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,SO=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,wO="gl_FragColor = linearToOutputTexel( gl_FragColor );",TO=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,IO=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,RO=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,BO=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,LO=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,DO=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,PO=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,UO=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,FO=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,NO=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,OO=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,kO=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,GO=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,zO=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,HO=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,VO=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,QO=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,WO=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,XO=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,qO=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,YO=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,jO=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,$O=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,KO=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,JO=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,ZO=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,ek=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,tk=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,nk=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,ik=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,rk=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,sk=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,ok=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ak=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,lk=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,ck=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,hk=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,uk=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,dk=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,fk=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,pk=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,mk=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Ak=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,gk=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,vk=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Ek=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,xk=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,yk=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,_k=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,bk=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Ck=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Mk=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,Sk=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,wk=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Tk=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Ik=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Rk=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Bk=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Lk=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,Dk=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Pk=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Uk=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Fk=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Nk=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Ok=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,kk=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Gk=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,zk=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Hk=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Vk=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Qk=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,Wk=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,Xk=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,qk=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Yk=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,jk=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const $k=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Kk=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Jk=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Zk=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,eG=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,tG=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,nG=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,iG=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,rG=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,sG=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,oG=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,aG=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,lG=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,cG=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,hG=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,uG=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dG=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fG=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,pG=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,mG=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,AG=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,gG=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vG=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,EG=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xG=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,yG=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_G=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,bG=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,CG=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,MG=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,SG=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,wG=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,TG=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,IG=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,xt={alphahash_fragment:KN,alphahash_pars_fragment:JN,alphamap_fragment:ZN,alphamap_pars_fragment:eO,alphatest_fragment:tO,alphatest_pars_fragment:nO,aomap_fragment:iO,aomap_pars_fragment:rO,batching_pars_vertex:sO,batching_vertex:oO,begin_vertex:aO,beginnormal_vertex:lO,bsdfs:cO,iridescence_fragment:hO,bumpmap_pars_fragment:uO,clipping_planes_fragment:dO,clipping_planes_pars_fragment:fO,clipping_planes_pars_vertex:pO,clipping_planes_vertex:mO,color_fragment:AO,color_pars_fragment:gO,color_pars_vertex:vO,color_vertex:EO,common:xO,cube_uv_reflection_fragment:yO,defaultnormal_vertex:_O,displacementmap_pars_vertex:bO,displacementmap_vertex:CO,emissivemap_fragment:MO,emissivemap_pars_fragment:SO,colorspace_fragment:wO,colorspace_pars_fragment:TO,envmap_fragment:IO,envmap_common_pars_fragment:RO,envmap_pars_fragment:BO,envmap_pars_vertex:LO,envmap_physical_pars_fragment:VO,envmap_vertex:DO,fog_vertex:PO,fog_pars_vertex:UO,fog_fragment:FO,fog_pars_fragment:NO,gradientmap_pars_fragment:OO,lightmap_pars_fragment:kO,lights_lambert_fragment:GO,lights_lambert_pars_fragment:zO,lights_pars_begin:HO,lights_toon_fragment:QO,lights_toon_pars_fragment:WO,lights_phong_fragment:XO,lights_phong_pars_fragment:qO,lights_physical_fragment:YO,lights_physical_pars_fragment:jO,lights_fragment_begin:$O,lights_fragment_maps:KO,lights_fragment_end:JO,logdepthbuf_fragment:ZO,logdepthbuf_pars_fragment:ek,logdepthbuf_pars_vertex:tk,logdepthbuf_vertex:nk,map_fragment:ik,map_pars_fragment:rk,map_particle_fragment:sk,map_particle_pars_fragment:ok,metalnessmap_fragment:ak,metalnessmap_pars_fragment:lk,morphinstance_vertex:ck,morphcolor_vertex:hk,morphnormal_vertex:uk,morphtarget_pars_vertex:dk,morphtarget_vertex:fk,normal_fragment_begin:pk,normal_fragment_maps:mk,normal_pars_fragment:Ak,normal_pars_vertex:gk,normal_vertex:vk,normalmap_pars_fragment:Ek,clearcoat_normal_fragment_begin:xk,clearcoat_normal_fragment_maps:yk,clearcoat_pars_fragment:_k,iridescence_pars_fragment:bk,opaque_fragment:Ck,packing:Mk,premultiplied_alpha_fragment:Sk,project_vertex:wk,dithering_fragment:Tk,dithering_pars_fragment:Ik,roughnessmap_fragment:Rk,roughnessmap_pars_fragment:Bk,shadowmap_pars_fragment:Lk,shadowmap_pars_vertex:Dk,shadowmap_vertex:Pk,shadowmask_pars_fragment:Uk,skinbase_vertex:Fk,skinning_pars_vertex:Nk,skinning_vertex:Ok,skinnormal_vertex:kk,specularmap_fragment:Gk,specularmap_pars_fragment:zk,tonemapping_fragment:Hk,tonemapping_pars_fragment:Vk,transmission_fragment:Qk,transmission_pars_fragment:Wk,uv_pars_fragment:Xk,uv_pars_vertex:qk,uv_vertex:Yk,worldpos_vertex:jk,background_vert:$k,background_frag:Kk,backgroundCube_vert:Jk,backgroundCube_frag:Zk,cube_vert:eG,cube_frag:tG,depth_vert:nG,depth_frag:iG,distanceRGBA_vert:rG,distanceRGBA_frag:sG,equirect_vert:oG,equirect_frag:aG,linedashed_vert:lG,linedashed_frag:cG,meshbasic_vert:hG,meshbasic_frag:uG,meshlambert_vert:dG,meshlambert_frag:fG,meshmatcap_vert:pG,meshmatcap_frag:mG,meshnormal_vert:AG,meshnormal_frag:gG,meshphong_vert:vG,meshphong_frag:EG,meshphysical_vert:xG,meshphysical_frag:yG,meshtoon_vert:_G,meshtoon_frag:bG,points_vert:CG,points_frag:MG,shadow_vert:SG,shadow_frag:wG,sprite_vert:TG,sprite_frag:IG},je={common:{diffuse:{value:new kt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Et},alphaMap:{value:null},alphaMapTransform:{value:new Et},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Et}},envmap:{envMap:{value:null},envMapRotation:{value:new Et},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Et}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Et}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Et},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Et},normalScale:{value:new zt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Et},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Et}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Et}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Et}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new kt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new kt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Et},alphaTest:{value:0},uvTransform:{value:new Et}},sprite:{diffuse:{value:new kt(16777215)},opacity:{value:1},center:{value:new zt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Et},alphaMap:{value:null},alphaMapTransform:{value:new Et},alphaTest:{value:0}}},Xi={basic:{uniforms:Dn([je.common,je.specularmap,je.envmap,je.aomap,je.lightmap,je.fog]),vertexShader:xt.meshbasic_vert,fragmentShader:xt.meshbasic_frag},lambert:{uniforms:Dn([je.common,je.specularmap,je.envmap,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.fog,je.lights,{emissive:{value:new kt(0)}}]),vertexShader:xt.meshlambert_vert,fragmentShader:xt.meshlambert_frag},phong:{uniforms:Dn([je.common,je.specularmap,je.envmap,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.fog,je.lights,{emissive:{value:new kt(0)},specular:{value:new kt(1118481)},shininess:{value:30}}]),vertexShader:xt.meshphong_vert,fragmentShader:xt.meshphong_frag},standard:{uniforms:Dn([je.common,je.envmap,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.roughnessmap,je.metalnessmap,je.fog,je.lights,{emissive:{value:new kt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:xt.meshphysical_vert,fragmentShader:xt.meshphysical_frag},toon:{uniforms:Dn([je.common,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.gradientmap,je.fog,je.lights,{emissive:{value:new kt(0)}}]),vertexShader:xt.meshtoon_vert,fragmentShader:xt.meshtoon_frag},matcap:{uniforms:Dn([je.common,je.bumpmap,je.normalmap,je.displacementmap,je.fog,{matcap:{value:null}}]),vertexShader:xt.meshmatcap_vert,fragmentShader:xt.meshmatcap_frag},points:{uniforms:Dn([je.points,je.fog]),vertexShader:xt.points_vert,fragmentShader:xt.points_frag},dashed:{uniforms:Dn([je.common,je.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:xt.linedashed_vert,fragmentShader:xt.linedashed_frag},depth:{uniforms:Dn([je.common,je.displacementmap]),vertexShader:xt.depth_vert,fragmentShader:xt.depth_frag},normal:{uniforms:Dn([je.common,je.bumpmap,je.normalmap,je.displacementmap,{opacity:{value:1}}]),vertexShader:xt.meshnormal_vert,fragmentShader:xt.meshnormal_frag},sprite:{uniforms:Dn([je.sprite,je.fog]),vertexShader:xt.sprite_vert,fragmentShader:xt.sprite_frag},background:{uniforms:{uvTransform:{value:new Et},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:xt.background_vert,fragmentShader:xt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Et}},vertexShader:xt.backgroundCube_vert,fragmentShader:xt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:xt.cube_vert,fragmentShader:xt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:xt.equirect_vert,fragmentShader:xt.equirect_frag},distanceRGBA:{uniforms:Dn([je.common,je.displacementmap,{referencePosition:{value:new ye},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:xt.distanceRGBA_vert,fragmentShader:xt.distanceRGBA_frag},shadow:{uniforms:Dn([je.lights,je.fog,{color:{value:new kt(0)},opacity:{value:1}}]),vertexShader:xt.shadow_vert,fragmentShader:xt.shadow_frag}};Xi.physical={uniforms:Dn([Xi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Et},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Et},clearcoatNormalScale:{value:new zt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Et},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Et},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Et},sheen:{value:0},sheenColor:{value:new kt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Et},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Et},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Et},transmissionSamplerSize:{value:new zt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Et},attenuationDistance:{value:0},attenuationColor:{value:new kt(0)},specularColor:{value:new kt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Et},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Et},anisotropyVector:{value:new zt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Et}}]),vertexShader:xt.meshphysical_vert,fragmentShader:xt.meshphysical_frag};const Lu={r:0,b:0,g:0},oo=new Oi,RG=new $t;function BG(n,e,t,i,r,s,o){const a=new kt(0);let l=s===!0?0:1,c,h,u=null,d=0,f=null;function A(E){let x=E.isScene===!0?E.background:null;return x&&x.isTexture&&(x=(E.backgroundBlurriness>0?t:e).get(x)),x}function g(E){let x=!1;const M=A(E);M===null?p(a,l):M&&M.isColor&&(p(M,1),x=!0);const w=n.xr.getEnvironmentBlendMode();w==="additive"?i.buffers.color.setClear(0,0,0,1,o):w==="alpha-blend"&&i.buffers.color.setClear(0,0,0,0,o),(n.autoClear||x)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function m(E,x){const M=A(x);M&&(M.isCubeTexture||M.mapping===qf)?(h===void 0&&(h=new Br(new Xc(1,1,1),new Ts({name:"BackgroundCubeMaterial",uniforms:tl(Xi.backgroundCube.uniforms),vertexShader:Xi.backgroundCube.vertexShader,fragmentShader:Xi.backgroundCube.fragmentShader,side:jn,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(w,S,B){this.matrixWorld.copyPosition(B.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(h)),oo.copy(x.backgroundRotation),oo.x*=-1,oo.y*=-1,oo.z*=-1,M.isCubeTexture&&M.isRenderTargetTexture===!1&&(oo.y*=-1,oo.z*=-1),h.material.uniforms.envMap.value=M,h.material.uniforms.flipEnvMap.value=M.isCubeTexture&&M.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=x.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(RG.makeRotationFromEuler(oo)),h.material.toneMapped=Rt.getTransfer(M.colorSpace)!==Ot,(u!==M||d!==M.version||f!==n.toneMapping)&&(h.material.needsUpdate=!0,u=M,d=M.version,f=n.toneMapping),h.layers.enableAll(),E.unshift(h,h.geometry,h.material,0,0,null)):M&&M.isTexture&&(c===void 0&&(c=new Br(new jf(2,2),new Ts({name:"BackgroundMaterial",uniforms:tl(Xi.background.uniforms),vertexShader:Xi.background.vertexShader,fragmentShader:Xi.background.fragmentShader,side:ws,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(c)),c.material.uniforms.t2D.value=M,c.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,c.material.toneMapped=Rt.getTransfer(M.colorSpace)!==Ot,M.matrixAutoUpdate===!0&&M.updateMatrix(),c.material.uniforms.uvTransform.value.copy(M.matrix),(u!==M||d!==M.version||f!==n.toneMapping)&&(c.material.needsUpdate=!0,u=M,d=M.version,f=n.toneMapping),c.layers.enableAll(),E.unshift(c,c.geometry,c.material,0,0,null))}function p(E,x){E.getRGB(Lu,nw(n)),i.buffers.color.setClear(Lu.r,Lu.g,Lu.b,x,o)}function v(){h!==void 0&&(h.geometry.dispose(),h.material.dispose(),h=void 0),c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0)}return{getClearColor:function(){return a},setClearColor:function(E,x=1){a.set(E),l=x,p(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(E){l=E,p(a,l)},render:g,addToRenderList:m,dispose:v}}function LG(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),i={},r=d(null);let s=r,o=!1;function a(_,L,Q,O,X){let te=!1;const W=u(O,Q,L);s!==W&&(s=W,c(s.object)),te=f(_,O,Q,X),te&&A(_,O,Q,X),X!==null&&e.update(X,n.ELEMENT_ARRAY_BUFFER),(te||o)&&(o=!1,x(_,L,Q,O),X!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(X).buffer))}function l(){return n.createVertexArray()}function c(_){return n.bindVertexArray(_)}function h(_){return n.deleteVertexArray(_)}function u(_,L,Q){const O=Q.wireframe===!0;let X=i[_.id];X===void 0&&(X={},i[_.id]=X);let te=X[L.id];te===void 0&&(te={},X[L.id]=te);let W=te[O];return W===void 0&&(W=d(l()),te[O]=W),W}function d(_){const L=[],Q=[],O=[];for(let X=0;X<t;X++)L[X]=0,Q[X]=0,O[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:Q,attributeDivisors:O,object:_,attributes:{},index:null}}function f(_,L,Q,O){const X=s.attributes,te=L.attributes;let W=0;const Z=Q.getAttributes();for(const q in Z)if(Z[q].location>=0){const ue=X[q];let _e=te[q];if(_e===void 0&&(q==="instanceMatrix"&&_.instanceMatrix&&(_e=_.instanceMatrix),q==="instanceColor"&&_.instanceColor&&(_e=_.instanceColor)),ue===void 0||ue.attribute!==_e||_e&&ue.data!==_e.data)return!0;W++}return s.attributesNum!==W||s.index!==O}function A(_,L,Q,O){const X={},te=L.attributes;let W=0;const Z=Q.getAttributes();for(const q in Z)if(Z[q].location>=0){let ue=te[q];ue===void 0&&(q==="instanceMatrix"&&_.instanceMatrix&&(ue=_.instanceMatrix),q==="instanceColor"&&_.instanceColor&&(ue=_.instanceColor));const _e={};_e.attribute=ue,ue&&ue.data&&(_e.data=ue.data),X[q]=_e,W++}s.attributes=X,s.attributesNum=W,s.index=O}function g(){const _=s.newAttributes;for(let L=0,Q=_.length;L<Q;L++)_[L]=0}function m(_){p(_,0)}function p(_,L){const Q=s.newAttributes,O=s.enabledAttributes,X=s.attributeDivisors;Q[_]=1,O[_]===0&&(n.enableVertexAttribArray(_),O[_]=1),X[_]!==L&&(n.vertexAttribDivisor(_,L),X[_]=L)}function v(){const _=s.newAttributes,L=s.enabledAttributes;for(let Q=0,O=L.length;Q<O;Q++)L[Q]!==_[Q]&&(n.disableVertexAttribArray(Q),L[Q]=0)}function E(_,L,Q,O,X,te,W){W===!0?n.vertexAttribIPointer(_,L,Q,X,te):n.vertexAttribPointer(_,L,Q,O,X,te)}function x(_,L,Q,O){g();const X=O.attributes,te=Q.getAttributes(),W=L.defaultAttributeValues;for(const Z in te){const q=te[Z];if(q.location>=0){let re=X[Z];if(re===void 0&&(Z==="instanceMatrix"&&_.instanceMatrix&&(re=_.instanceMatrix),Z==="instanceColor"&&_.instanceColor&&(re=_.instanceColor)),re!==void 0){const ue=re.normalized,_e=re.itemSize,Be=e.get(re);if(Be===void 0)continue;const ze=Be.buffer,le=Be.type,Ee=Be.bytesPerElement,Ue=le===n.INT||le===n.UNSIGNED_INT||re.gpuType===dv;if(re.isInterleavedBufferAttribute){const pe=re.data,oe=pe.stride,we=re.offset;if(pe.isInstancedInterleavedBuffer){for(let Me=0;Me<q.locationSize;Me++)p(q.location+Me,pe.meshPerAttribute);_.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=pe.meshPerAttribute*pe.count)}else for(let Me=0;Me<q.locationSize;Me++)m(q.location+Me);n.bindBuffer(n.ARRAY_BUFFER,ze);for(let Me=0;Me<q.locationSize;Me++)E(q.location+Me,_e/q.locationSize,le,ue,oe*Ee,(we+_e/q.locationSize*Me)*Ee,Ue)}else{if(re.isInstancedBufferAttribute){for(let pe=0;pe<q.locationSize;pe++)p(q.location+pe,re.meshPerAttribute);_.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=re.meshPerAttribute*re.count)}else for(let pe=0;pe<q.locationSize;pe++)m(q.location+pe);n.bindBuffer(n.ARRAY_BUFFER,ze);for(let pe=0;pe<q.locationSize;pe++)E(q.location+pe,_e/q.locationSize,le,ue,_e*Ee,_e/q.locationSize*pe*Ee,Ue)}}else if(W!==void 0){const ue=W[Z];if(ue!==void 0)switch(ue.length){case 2:n.vertexAttrib2fv(q.location,ue);break;case 3:n.vertexAttrib3fv(q.location,ue);break;case 4:n.vertexAttrib4fv(q.location,ue);break;default:n.vertexAttrib1fv(q.location,ue)}}}}v()}function M(){B();for(const _ in i){const L=i[_];for(const Q in L){const O=L[Q];for(const X in O)h(O[X].object),delete O[X];delete L[Q]}delete i[_]}}function w(_){if(i[_.id]===void 0)return;const L=i[_.id];for(const Q in L){const O=L[Q];for(const X in O)h(O[X].object),delete O[X];delete L[Q]}delete i[_.id]}function S(_){for(const L in i){const Q=i[L];if(Q[_.id]===void 0)continue;const O=Q[_.id];for(const X in O)h(O[X].object),delete O[X];delete Q[_.id]}}function B(){y(),o=!0,s!==r&&(s=r,c(s.object))}function y(){r.geometry=null,r.program=null,r.wireframe=!1}return{setup:a,reset:B,resetDefaultState:y,dispose:M,releaseStatesOfGeometry:w,releaseStatesOfProgram:S,initAttributes:g,enableAttribute:m,disableUnusedAttributes:v}}function DG(n,e,t){let i;function r(c){i=c}function s(c,h){n.drawArrays(i,c,h),t.update(h,i,1)}function o(c,h,u){u!==0&&(n.drawArraysInstanced(i,c,h,u),t.update(h,i,u))}function a(c,h,u){if(u===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i,c,0,h,0,u);let f=0;for(let A=0;A<u;A++)f+=h[A];t.update(f,i,1)}function l(c,h,u,d){if(u===0)return;const f=e.get("WEBGL_multi_draw");if(f===null)for(let A=0;A<c.length;A++)o(c[A],h[A],d[A]);else{f.multiDrawArraysInstancedWEBGL(i,c,0,h,0,d,0,u);let A=0;for(let g=0;g<u;g++)A+=h[g]*d[g];t.update(A,i,1)}}this.setMode=r,this.render=s,this.renderInstances=o,this.renderMultiDraw=a,this.renderMultiDrawInstances=l}function PG(n,e,t,i){let r;function s(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");r=n.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function o(S){return!(S!==Di&&i.convert(S)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function a(S){const B=S===Qc&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(S!==Hr&&i.convert(S)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&S!==Ir&&!B)}function l(S){if(S==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";S="mediump"}return S==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=t.precision!==void 0?t.precision:"highp";const h=l(c);h!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",h,"instead."),c=h);const u=t.logarithmicDepthBuffer===!0,d=t.reverseDepthBuffer===!0&&e.has("EXT_clip_control"),f=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),A=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=n.getParameter(n.MAX_TEXTURE_SIZE),m=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),p=n.getParameter(n.MAX_VERTEX_ATTRIBS),v=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),E=n.getParameter(n.MAX_VARYING_VECTORS),x=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),M=A>0,w=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:l,textureFormatReadable:o,textureTypeReadable:a,precision:c,logarithmicDepthBuffer:u,reverseDepthBuffer:d,maxTextures:f,maxVertexTextures:A,maxTextureSize:g,maxCubemapSize:m,maxAttributes:p,maxVertexUniforms:v,maxVaryings:E,maxFragmentUniforms:x,vertexTextures:M,maxSamples:w}}function UG(n){const e=this;let t=null,i=0,r=!1,s=!1;const o=new ho,a=new Et,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d){const f=u.length!==0||d||i!==0||r;return r=d,i=u.length,f},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(u,d){t=h(u,d,0)},this.setState=function(u,d,f){const A=u.clippingPlanes,g=u.clipIntersection,m=u.clipShadows,p=n.get(u);if(!r||A===null||A.length===0||s&&!m)s?h(null):c();else{const v=s?0:i,E=v*4;let x=p.clippingState||null;l.value=x,x=h(A,d,E,f);for(let M=0;M!==E;++M)x[M]=t[M];p.clippingState=x,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=v}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function h(u,d,f,A){const g=u!==null?u.length:0;let m=null;if(g!==0){if(m=l.value,A!==!0||m===null){const p=f+g*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(m===null||m.length<p)&&(m=new Float32Array(p));for(let E=0,x=f;E!==g;++E,x+=4)o.copy(u[E]).applyMatrix4(v,a),o.normal.toArray(m,x),m[x+3]=o.constant}l.value=m,l.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,m}}function FG(n){let e=new WeakMap;function t(o,a){return a===fg?o.mapping=Ja:a===pg&&(o.mapping=Za),o}function i(o){if(o&&o.isTexture){const a=o.mapping;if(a===fg||a===pg)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new ON(l.height);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",r),t(c.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:i,dispose:s}}const Oa=4,L_=[.125,.215,.35,.446,.526,.582],mo=20,oA=new XN,D_=new kt;let aA=null,lA=0,cA=0,hA=!1;const uo=(1+Math.sqrt(5))/2,wa=1/uo,P_=[new ye(-uo,wa,0),new ye(uo,wa,0),new ye(-wa,0,uo),new ye(wa,0,uo),new ye(0,uo,-wa),new ye(0,uo,wa),new ye(-1,1,-1),new ye(1,1,-1),new ye(-1,1,1),new ye(1,1,1)],NG=new ye;class U_{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100,s={}){const{size:o=256,position:a=NG}=s;aA=this._renderer.getRenderTarget(),lA=this._renderer.getActiveCubeFace(),cA=this._renderer.getActiveMipmapLevel(),hA=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(o);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(e,i,r,l,a),t>0&&this._blur(l,0,0,t),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=O_(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=N_(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(aA,lA,cA),this._renderer.xr.enabled=hA,e.scissorTest=!1,Du(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Ja||e.mapping===Za?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),aA=this._renderer.getRenderTarget(),lA=this._renderer.getActiveCubeFace(),cA=this._renderer.getActiveMipmapLevel(),hA=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:Ai,minFilter:Ai,generateMipmaps:!1,type:Qc,format:Di,colorSpace:el,depthBuffer:!1},r=F_(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=F_(e,t,i);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=OG(s)),this._blurMaterial=kG(s,e,t)}return r}_compileMaterial(e){const t=new Br(this._lodPlanes[0],e);this._renderer.compile(t,oA)}_sceneToCubeUV(e,t,i,r,s){const l=new Ri(90,1,t,i),c=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],u=this._renderer,d=u.autoClear,f=u.toneMapping;u.getClearColor(D_),u.toneMapping=_s,u.autoClear=!1;const A=new ZS({name:"PMREM.Background",side:jn,depthWrite:!1,depthTest:!1}),g=new Br(new Xc,A);let m=!1;const p=e.background;p?p.isColor&&(A.color.copy(p),e.background=null,m=!0):(A.color.copy(D_),m=!0);for(let v=0;v<6;v++){const E=v%3;E===0?(l.up.set(0,c[v],0),l.position.set(s.x,s.y,s.z),l.lookAt(s.x+h[v],s.y,s.z)):E===1?(l.up.set(0,0,c[v]),l.position.set(s.x,s.y,s.z),l.lookAt(s.x,s.y+h[v],s.z)):(l.up.set(0,c[v],0),l.position.set(s.x,s.y,s.z),l.lookAt(s.x,s.y,s.z+h[v]));const x=this._cubeSize;Du(r,E*x,v>2?x:0,x,x),u.setRenderTarget(r),m&&u.render(g,l),u.render(e,l)}g.geometry.dispose(),g.material.dispose(),u.toneMapping=f,u.autoClear=d,e.background=p}_textureToCubeUV(e,t){const i=this._renderer,r=e.mapping===Ja||e.mapping===Za;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=O_()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=N_());const s=r?this._cubemapMaterial:this._equirectMaterial,o=new Br(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;Du(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,oA)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let s=1;s<r;s++){const o=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),a=P_[(r-s-1)%P_.length];this._blur(e,s-1,s,o,a)}t.autoClear=i}_blur(e,t,i,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,r,"latitudinal",s),this._halfBlur(o,e,i,i,r,"longitudinal",s)}_halfBlur(e,t,i,r,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,u=new Br(this._lodPlanes[r],c),d=c.uniforms,f=this._sizeLods[i]-1,A=isFinite(s)?Math.PI/(2*f):2*Math.PI/(2*mo-1),g=s/A,m=isFinite(s)?1+Math.floor(h*g):mo;m>mo&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${mo}`);const p=[];let v=0;for(let S=0;S<mo;++S){const B=S/g,y=Math.exp(-B*B/2);p.push(y),S===0?v+=y:S<m&&(v+=2*y)}for(let S=0;S<p.length;S++)p[S]=p[S]/v;d.envMap.value=e.texture,d.samples.value=m,d.weights.value=p,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:E}=this;d.dTheta.value=A,d.mipInt.value=E-i;const x=this._sizeLods[r],M=3*x*(r>E-Oa?r-E+Oa:0),w=4*(this._cubeSize-x);Du(t,M,w,3*x,2*x),l.setRenderTarget(t),l.render(u,oA)}}function OG(n){const e=[],t=[],i=[];let r=n;const s=n-Oa+1+L_.length;for(let o=0;o<s;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-Oa?l=L_[o-n+Oa-1]:o===0&&(l=0),i.push(l);const c=1/(a-2),h=-c,u=1+c,d=[h,h,u,h,u,u,h,h,u,u,h,u],f=6,A=6,g=3,m=2,p=1,v=new Float32Array(g*A*f),E=new Float32Array(m*A*f),x=new Float32Array(p*A*f);for(let w=0;w<f;w++){const S=w%3*2/3-1,B=w>2?0:-1,y=[S,B,0,S+2/3,B,0,S+2/3,B+1,0,S,B,0,S+2/3,B+1,0,S,B+1,0];v.set(y,g*A*w),E.set(d,m*A*w);const _=[w,w,w,w,w,w];x.set(_,p*A*w)}const M=new No;M.setAttribute("position",new Zi(v,g)),M.setAttribute("uv",new Zi(E,m)),M.setAttribute("faceIndex",new Zi(x,p)),e.push(M),r>Oa&&r--}return{lodPlanes:e,sizeLods:t,sigmas:i}}function F_(n,e,t){const i=new Do(n,e,t);return i.texture.mapping=qf,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function Du(n,e,t,i,r){n.viewport.set(e,t,i,r),n.scissor.set(e,t,i,r)}function kG(n,e,t){const i=new Float32Array(mo),r=new ye(0,1,0);return new Ts({name:"SphericalGaussianBlur",defines:{n:mo,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:_v(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ys,depthTest:!1,depthWrite:!1})}function N_(){return new Ts({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_v(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ys,depthTest:!1,depthWrite:!1})}function O_(){return new Ts({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_v(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ys,depthTest:!1,depthWrite:!1})}function _v(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function GG(n){let e=new WeakMap,t=null;function i(a){if(a&&a.isTexture){const l=a.mapping,c=l===fg||l===pg,h=l===Ja||l===Za;if(c||h){let u=e.get(a);const d=u!==void 0?u.texture.pmremVersion:0;if(a.isRenderTargetTexture&&a.pmremVersion!==d)return t===null&&(t=new U_(n)),u=c?t.fromEquirectangular(a,u):t.fromCubemap(a,u),u.texture.pmremVersion=a.pmremVersion,e.set(a,u),u.texture;if(u!==void 0)return u.texture;{const f=a.image;return c&&f&&f.height>0||h&&f&&r(f)?(t===null&&(t=new U_(n)),u=c?t.fromEquirectangular(a):t.fromCubemap(a),u.texture.pmremVersion=a.pmremVersion,e.set(a,u),a.addEventListener("dispose",s),u.texture):null}}}return a}function r(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function s(a){const l=a.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:o}}function zG(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return e[i]=r,r}return{has:function(i){return t(i)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(i){const r=t(i);return r===null&&Ju("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function HG(n,e,t,i){const r={},s=new WeakMap;function o(u){const d=u.target;d.index!==null&&e.remove(d.index);for(const A in d.attributes)e.remove(d.attributes[A]);d.removeEventListener("dispose",o),delete r[d.id];const f=s.get(d);f&&(e.remove(f),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(u,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(u){const d=u.attributes;for(const f in d)e.update(d[f],n.ARRAY_BUFFER)}function c(u){const d=[],f=u.index,A=u.attributes.position;let g=0;if(f!==null){const v=f.array;g=f.version;for(let E=0,x=v.length;E<x;E+=3){const M=v[E+0],w=v[E+1],S=v[E+2];d.push(M,w,w,S,S,M)}}else if(A!==void 0){const v=A.array;g=A.version;for(let E=0,x=v.length/3-1;E<x;E+=3){const M=E+0,w=E+1,S=E+2;d.push(M,w,w,S,S,M)}}else return;const m=new(jS(d)?tw:ew)(d,1);m.version=g;const p=s.get(u);p&&e.remove(p),s.set(u,m)}function h(u){const d=s.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return s.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function VG(n,e,t){let i;function r(d){i=d}let s,o;function a(d){s=d.type,o=d.bytesPerElement}function l(d,f){n.drawElements(i,f,s,d*o),t.update(f,i,1)}function c(d,f,A){A!==0&&(n.drawElementsInstanced(i,f,s,d*o,A),t.update(f,i,A))}function h(d,f,A){if(A===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i,f,0,s,d,0,A);let m=0;for(let p=0;p<A;p++)m+=f[p];t.update(m,i,1)}function u(d,f,A,g){if(A===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let p=0;p<d.length;p++)c(d[p]/o,f[p],g[p]);else{m.multiDrawElementsInstancedWEBGL(i,f,0,s,d,0,g,0,A);let p=0;for(let v=0;v<A;v++)p+=f[v]*g[v];t.update(p,i,1)}}this.setMode=r,this.setIndex=a,this.render=l,this.renderInstances=c,this.renderMultiDraw=h,this.renderMultiDrawInstances=u}function QG(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(s/3);break;case n.LINES:t.lines+=a*(s/2);break;case n.LINE_STRIP:t.lines+=a*(s-1);break;case n.LINE_LOOP:t.lines+=a*s;break;case n.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:i}}function WG(n,e,t){const i=new WeakMap,r=new jt;function s(o,a,l){const c=o.morphTargetInfluences,h=a.morphAttributes.position||a.morphAttributes.normal||a.morphAttributes.color,u=h!==void 0?h.length:0;let d=i.get(a);if(d===void 0||d.count!==u){let y=function(){S.dispose(),i.delete(a),a.removeEventListener("dispose",y)};d!==void 0&&d.texture.dispose();const f=a.morphAttributes.position!==void 0,A=a.morphAttributes.normal!==void 0,g=a.morphAttributes.color!==void 0,m=a.morphAttributes.position||[],p=a.morphAttributes.normal||[],v=a.morphAttributes.color||[];let E=0;f===!0&&(E=1),A===!0&&(E=2),g===!0&&(E=3);let x=a.attributes.position.count*E,M=1;x>e.maxTextureSize&&(M=Math.ceil(x/e.maxTextureSize),x=e.maxTextureSize);const w=new Float32Array(x*M*4*u),S=new $S(w,x,M,u);S.type=Ir,S.needsUpdate=!0;const B=E*4;for(let _=0;_<u;_++){const L=m[_],Q=p[_],O=v[_],X=x*M*4*_;for(let te=0;te<L.count;te++){const W=te*B;f===!0&&(r.fromBufferAttribute(L,te),w[X+W+0]=r.x,w[X+W+1]=r.y,w[X+W+2]=r.z,w[X+W+3]=0),A===!0&&(r.fromBufferAttribute(Q,te),w[X+W+4]=r.x,w[X+W+5]=r.y,w[X+W+6]=r.z,w[X+W+7]=0),g===!0&&(r.fromBufferAttribute(O,te),w[X+W+8]=r.x,w[X+W+9]=r.y,w[X+W+10]=r.z,w[X+W+11]=O.itemSize===4?r.w:1)}}d={count:u,texture:S,size:new zt(x,M)},i.set(a,d),a.addEventListener("dispose",y)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)l.getUniforms().setValue(n,"morphTexture",o.morphTexture,t);else{let f=0;for(let g=0;g<c.length;g++)f+=c[g];const A=a.morphTargetsRelative?1:1-f;l.getUniforms().setValue(n,"morphTargetBaseInfluence",A),l.getUniforms().setValue(n,"morphTargetInfluences",c)}l.getUniforms().setValue(n,"morphTargetsTexture",d.texture,t),l.getUniforms().setValue(n,"morphTargetsTextureSize",d.size)}return{update:s}}function XG(n,e,t,i){let r=new WeakMap;function s(l){const c=i.render.frame,h=l.geometry,u=e.get(l,h);if(r.get(u)!==c&&(e.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),r.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),r.set(l,c))),l.isSkinnedMesh){const d=l.skeleton;r.get(d)!==c&&(d.update(),r.set(d,c))}return u}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}const lw=new zn,k_=new ow(1,1),cw=new $S,hw=new yN,uw=new rw,G_=[],z_=[],H_=new Float32Array(16),V_=new Float32Array(9),Q_=new Float32Array(4);function ll(n,e,t){const i=n[0];if(i<=0||i>0)return n;const r=e*t;let s=G_[r];if(s===void 0&&(s=new Float32Array(r),G_[r]=s),e!==0){i.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function un(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function dn(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function $f(n,e){let t=z_[e];t===void 0&&(t=new Int32Array(e),z_[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function qG(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function YG(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(un(t,e))return;n.uniform2fv(this.addr,e),dn(t,e)}}function jG(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(un(t,e))return;n.uniform3fv(this.addr,e),dn(t,e)}}function $G(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(un(t,e))return;n.uniform4fv(this.addr,e),dn(t,e)}}function KG(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(un(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),dn(t,e)}else{if(un(t,i))return;Q_.set(i),n.uniformMatrix2fv(this.addr,!1,Q_),dn(t,i)}}function JG(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(un(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),dn(t,e)}else{if(un(t,i))return;V_.set(i),n.uniformMatrix3fv(this.addr,!1,V_),dn(t,i)}}function ZG(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(un(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),dn(t,e)}else{if(un(t,i))return;H_.set(i),n.uniformMatrix4fv(this.addr,!1,H_),dn(t,i)}}function ez(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function tz(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(un(t,e))return;n.uniform2iv(this.addr,e),dn(t,e)}}function nz(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(un(t,e))return;n.uniform3iv(this.addr,e),dn(t,e)}}function iz(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(un(t,e))return;n.uniform4iv(this.addr,e),dn(t,e)}}function rz(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function sz(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(un(t,e))return;n.uniform2uiv(this.addr,e),dn(t,e)}}function oz(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(un(t,e))return;n.uniform3uiv(this.addr,e),dn(t,e)}}function az(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(un(t,e))return;n.uniform4uiv(this.addr,e),dn(t,e)}}function lz(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r);let s;this.type===n.SAMPLER_2D_SHADOW?(k_.compareFunction=YS,s=k_):s=lw,t.setTexture2D(e||s,r)}function cz(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(e||hw,r)}function hz(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTextureCube(e||uw,r)}function uz(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(e||cw,r)}function dz(n){switch(n){case 5126:return qG;case 35664:return YG;case 35665:return jG;case 35666:return $G;case 35674:return KG;case 35675:return JG;case 35676:return ZG;case 5124:case 35670:return ez;case 35667:case 35671:return tz;case 35668:case 35672:return nz;case 35669:case 35673:return iz;case 5125:return rz;case 36294:return sz;case 36295:return oz;case 36296:return az;case 35678:case 36198:case 36298:case 36306:case 35682:return lz;case 35679:case 36299:case 36307:return cz;case 35680:case 36300:case 36308:case 36293:return hz;case 36289:case 36303:case 36311:case 36292:return uz}}function fz(n,e){n.uniform1fv(this.addr,e)}function pz(n,e){const t=ll(e,this.size,2);n.uniform2fv(this.addr,t)}function mz(n,e){const t=ll(e,this.size,3);n.uniform3fv(this.addr,t)}function Az(n,e){const t=ll(e,this.size,4);n.uniform4fv(this.addr,t)}function gz(n,e){const t=ll(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function vz(n,e){const t=ll(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Ez(n,e){const t=ll(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function xz(n,e){n.uniform1iv(this.addr,e)}function yz(n,e){n.uniform2iv(this.addr,e)}function _z(n,e){n.uniform3iv(this.addr,e)}function bz(n,e){n.uniform4iv(this.addr,e)}function Cz(n,e){n.uniform1uiv(this.addr,e)}function Mz(n,e){n.uniform2uiv(this.addr,e)}function Sz(n,e){n.uniform3uiv(this.addr,e)}function wz(n,e){n.uniform4uiv(this.addr,e)}function Tz(n,e,t){const i=this.cache,r=e.length,s=$f(t,r);un(i,s)||(n.uniform1iv(this.addr,s),dn(i,s));for(let o=0;o!==r;++o)t.setTexture2D(e[o]||lw,s[o])}function Iz(n,e,t){const i=this.cache,r=e.length,s=$f(t,r);un(i,s)||(n.uniform1iv(this.addr,s),dn(i,s));for(let o=0;o!==r;++o)t.setTexture3D(e[o]||hw,s[o])}function Rz(n,e,t){const i=this.cache,r=e.length,s=$f(t,r);un(i,s)||(n.uniform1iv(this.addr,s),dn(i,s));for(let o=0;o!==r;++o)t.setTextureCube(e[o]||uw,s[o])}function Bz(n,e,t){const i=this.cache,r=e.length,s=$f(t,r);un(i,s)||(n.uniform1iv(this.addr,s),dn(i,s));for(let o=0;o!==r;++o)t.setTexture2DArray(e[o]||cw,s[o])}function Lz(n){switch(n){case 5126:return fz;case 35664:return pz;case 35665:return mz;case 35666:return Az;case 35674:return gz;case 35675:return vz;case 35676:return Ez;case 5124:case 35670:return xz;case 35667:case 35671:return yz;case 35668:case 35672:return _z;case 35669:case 35673:return bz;case 5125:return Cz;case 36294:return Mz;case 36295:return Sz;case 36296:return wz;case 35678:case 36198:case 36298:case 36306:case 35682:return Tz;case 35679:case 36299:case 36307:return Iz;case 35680:case 36300:case 36308:case 36293:return Rz;case 36289:case 36303:case 36311:case 36292:return Bz}}class Dz{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.type=t.type,this.setValue=dz(t.type)}}class Pz{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=Lz(t.type)}}class Uz{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,i){const r=this.seq;for(let s=0,o=r.length;s!==o;++s){const a=r[s];a.setValue(e,t[a.id],i)}}}const uA=/(\w+)(\])?(\[|\.)?/g;function W_(n,e){n.seq.push(e),n.map[e.id]=e}function Fz(n,e,t){const i=n.name,r=i.length;for(uA.lastIndex=0;;){const s=uA.exec(i),o=uA.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){W_(t,c===void 0?new Dz(a,n,e):new Pz(a,n,e));break}else{let u=t.map[a];u===void 0&&(u=new Uz(a),W_(t,u)),t=u}}}class Zu{constructor(e,t){this.seq=[],this.map={};const i=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<i;++r){const s=e.getActiveUniform(t,r),o=e.getUniformLocation(t,s.name);Fz(s,o,this)}}setValue(e,t,i,r){const s=this.map[t];s!==void 0&&s.setValue(e,i,r)}setOptional(e,t,i){const r=t[i];r!==void 0&&this.setValue(e,i,r)}static upload(e,t,i,r){for(let s=0,o=t.length;s!==o;++s){const a=t[s],l=i[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,r)}}static seqWithValue(e,t){const i=[];for(let r=0,s=e.length;r!==s;++r){const o=e[r];o.id in t&&i.push(o)}return i}}function X_(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}const Nz=37297;let Oz=0;function kz(n,e){const t=n.split(`
`),i=[],r=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=r;o<s;o++){const a=o+1;i.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return i.join(`
`)}const q_=new Et;function Gz(n){Rt._getMatrix(q_,Rt.workingColorSpace,n);const e=`mat3( ${q_.elements.map(t=>t.toFixed(4))} )`;switch(Rt.getTransfer(n)){case tf:return[e,"LinearTransferOETF"];case Ot:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",n),[e,"LinearTransferOETF"]}}function Y_(n,e,t){const i=n.getShaderParameter(e,n.COMPILE_STATUS),r=n.getShaderInfoLog(e).trim();if(i&&r==="")return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+r+`

`+kz(n.getShaderSource(e),o)}else return r}function zz(n,e){const t=Gz(e);return[`vec4 ${n}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function Hz(n,e){let t;switch(e){case B3:t="Linear";break;case L3:t="Reinhard";break;case D3:t="Cineon";break;case P3:t="ACESFilmic";break;case F3:t="AgX";break;case N3:t="Neutral";break;case U3:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const Pu=new ye;function Vz(){Rt.getLuminanceCoefficients(Pu);const n=Pu.x.toFixed(4),e=Pu.y.toFixed(4),t=Pu.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function Qz(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Vl).join(`
`)}function Wz(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function Xz(n,e){const t={},i=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const s=n.getActiveAttrib(e,r),o=s.name;let a=1;s.type===n.FLOAT_MAT2&&(a=2),s.type===n.FLOAT_MAT3&&(a=3),s.type===n.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Vl(n){return n!==""}function j_(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function $_(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const qz=/^[ \t]*#include +<([\w\d./]+)>/gm;function Qg(n){return n.replace(qz,jz)}const Yz=new Map;function jz(n,e){let t=xt[e];if(t===void 0){const i=Yz.get(e);if(i!==void 0)t=xt[i],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,i);else throw new Error("Can not resolve #include <"+e+">")}return Qg(t)}const $z=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function K_(n){return n.replace($z,Kz)}function Kz(n,e,t,i){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function J_(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Jz(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===US?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===h3?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===vr&&(e="SHADOWMAP_TYPE_VSM"),e}function Zz(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Ja:case Za:e="ENVMAP_TYPE_CUBE";break;case qf:e="ENVMAP_TYPE_CUBE_UV";break}return e}function eH(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Za:e="ENVMAP_MODE_REFRACTION";break}return e}function tH(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case FS:e="ENVMAP_BLENDING_MULTIPLY";break;case I3:e="ENVMAP_BLENDING_MIX";break;case R3:e="ENVMAP_BLENDING_ADD";break}return e}function nH(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:i,maxMip:t}}function iH(n,e,t,i){const r=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=Jz(t),c=Zz(t),h=eH(t),u=tH(t),d=nH(t),f=Qz(t),A=Wz(s),g=r.createProgram();let m,p,v=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(m=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A].filter(Vl).join(`
`),m.length>0&&(m+=`
`),p=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A].filter(Vl).join(`
`),p.length>0&&(p+=`
`)):(m=[J_(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Vl).join(`
`),p=[J_(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,A,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==_s?"#define TONE_MAPPING":"",t.toneMapping!==_s?xt.tonemapping_pars_fragment:"",t.toneMapping!==_s?Hz("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",xt.colorspace_pars_fragment,zz("linearToOutputTexel",t.outputColorSpace),Vz(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Vl).join(`
`)),o=Qg(o),o=j_(o,t),o=$_(o,t),a=Qg(a),a=j_(a,t),a=$_(a,t),o=K_(o),a=K_(a),t.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,m=[f,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,p=["#define varying in",t.glslVersion===h_?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===h_?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+p);const E=v+m+o,x=v+p+a,M=X_(r,r.VERTEX_SHADER,E),w=X_(r,r.FRAGMENT_SHADER,x);r.attachShader(g,M),r.attachShader(g,w),t.index0AttributeName!==void 0?r.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(g,0,"position"),r.linkProgram(g);function S(L){if(n.debug.checkShaderErrors){const Q=r.getProgramInfoLog(g).trim(),O=r.getShaderInfoLog(M).trim(),X=r.getShaderInfoLog(w).trim();let te=!0,W=!0;if(r.getProgramParameter(g,r.LINK_STATUS)===!1)if(te=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(r,g,M,w);else{const Z=Y_(r,M,"vertex"),q=Y_(r,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(g,r.VALIDATE_STATUS)+`

Material Name: `+L.name+`
Material Type: `+L.type+`

Program Info Log: `+Q+`
`+Z+`
`+q)}else Q!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Q):(O===""||X==="")&&(W=!1);W&&(L.diagnostics={runnable:te,programLog:Q,vertexShader:{log:O,prefix:m},fragmentShader:{log:X,prefix:p}})}r.deleteShader(M),r.deleteShader(w),B=new Zu(r,g),y=Xz(r,g)}let B;this.getUniforms=function(){return B===void 0&&S(this),B};let y;this.getAttributes=function(){return y===void 0&&S(this),y};let _=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return _===!1&&(_=r.getProgramParameter(g,Nz)),_},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(g),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=Oz++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=M,this.fragmentShader=w,this}let rH=0;class sH{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,r=this._getShaderStage(t),s=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let i=t.get(e);return i===void 0&&(i=new Set,t.set(e,i)),i}_getShaderStage(e){const t=this.shaderCache;let i=t.get(e);return i===void 0&&(i=new oH(e),t.set(e,i)),i}}class oH{constructor(e){this.id=rH++,this.code=e,this.usedTimes=0}}function aH(n,e,t,i,r,s,o){const a=new yv,l=new sH,c=new Set,h=[],u=r.logarithmicDepthBuffer,d=r.vertexTextures;let f=r.precision;const A={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(y){return c.add(y),y===0?"uv":`uv${y}`}function m(y,_,L,Q,O){const X=Q.fog,te=O.geometry,W=y.isMeshStandardMaterial?Q.environment:null,Z=(y.isMeshStandardMaterial?t:e).get(y.envMap||W),q=Z&&Z.mapping===qf?Z.image.height:null,re=A[y.type];y.precision!==null&&(f=r.getMaxPrecision(y.precision),f!==y.precision&&console.warn("THREE.WebGLProgram.getParameters:",y.precision,"not supported, using",f,"instead."));const ue=te.morphAttributes.position||te.morphAttributes.normal||te.morphAttributes.color,_e=ue!==void 0?ue.length:0;let Be=0;te.morphAttributes.position!==void 0&&(Be=1),te.morphAttributes.normal!==void 0&&(Be=2),te.morphAttributes.color!==void 0&&(Be=3);let ze,le,Ee,Ue;if(re){const Qe=Xi[re];ze=Qe.vertexShader,le=Qe.fragmentShader}else ze=y.vertexShader,le=y.fragmentShader,l.update(y),Ee=l.getVertexShaderID(y),Ue=l.getFragmentShaderID(y);const pe=n.getRenderTarget(),oe=n.state.buffers.depth.getReversed(),we=O.isInstancedMesh===!0,Me=O.isBatchedMesh===!0,Ve=!!y.map,me=!!y.matcap,Ae=!!Z,V=!!y.aoMap,j=!!y.lightMap,Te=!!y.bumpMap,Re=!!y.normalMap,b=!!y.displacementMap,I=!!y.emissiveMap,U=!!y.metalnessMap,R=!!y.roughnessMap,T=y.anisotropy>0,G=y.clearcoat>0,J=y.dispersion>0,de=y.iridescence>0,N=y.sheen>0,P=y.transmission>0,$=T&&!!y.anisotropyMap,se=G&&!!y.clearcoatMap,ve=G&&!!y.clearcoatNormalMap,ie=G&&!!y.clearcoatRoughnessMap,Se=de&&!!y.iridescenceMap,be=de&&!!y.iridescenceThicknessMap,Ie=N&&!!y.sheenColorMap,Fe=N&&!!y.sheenRoughnessMap,Le=!!y.specularMap,Ge=!!y.specularColorMap,Ze=!!y.specularIntensityMap,F=P&&!!y.transmissionMap,ae=P&&!!y.thicknessMap,ne=!!y.gradientMap,ce=!!y.alphaMap,ge=y.alphaTest>0,xe=!!y.alphaHash,We=!!y.extensions;let ke=_s;y.toneMapped&&(pe===null||pe.isXRRenderTarget===!0)&&(ke=n.toneMapping);const He={shaderID:re,shaderType:y.type,shaderName:y.name,vertexShader:ze,fragmentShader:le,defines:y.defines,customVertexShaderID:Ee,customFragmentShaderID:Ue,isRawShaderMaterial:y.isRawShaderMaterial===!0,glslVersion:y.glslVersion,precision:f,batching:Me,batchingColor:Me&&O._colorsTexture!==null,instancing:we,instancingColor:we&&O.instanceColor!==null,instancingMorph:we&&O.morphTexture!==null,supportsVertexTextures:d,outputColorSpace:pe===null?n.outputColorSpace:pe.isXRRenderTarget===!0?pe.texture.colorSpace:el,alphaToCoverage:!!y.alphaToCoverage,map:Ve,matcap:me,envMap:Ae,envMapMode:Ae&&Z.mapping,envMapCubeUVHeight:q,aoMap:V,lightMap:j,bumpMap:Te,normalMap:Re,displacementMap:d&&b,emissiveMap:I,normalMapObjectSpace:Re&&y.normalMapType===H3,normalMapTangentSpace:Re&&y.normalMapType===z3,metalnessMap:U,roughnessMap:R,anisotropy:T,anisotropyMap:$,clearcoat:G,clearcoatMap:se,clearcoatNormalMap:ve,clearcoatRoughnessMap:ie,dispersion:J,iridescence:de,iridescenceMap:Se,iridescenceThicknessMap:be,sheen:N,sheenColorMap:Ie,sheenRoughnessMap:Fe,specularMap:Le,specularColorMap:Ge,specularIntensityMap:Ze,transmission:P,transmissionMap:F,thicknessMap:ae,gradientMap:ne,opaque:y.transparent===!1&&y.blending===Qa&&y.alphaToCoverage===!1,alphaMap:ce,alphaTest:ge,alphaHash:xe,combine:y.combine,mapUv:Ve&&g(y.map.channel),aoMapUv:V&&g(y.aoMap.channel),lightMapUv:j&&g(y.lightMap.channel),bumpMapUv:Te&&g(y.bumpMap.channel),normalMapUv:Re&&g(y.normalMap.channel),displacementMapUv:b&&g(y.displacementMap.channel),emissiveMapUv:I&&g(y.emissiveMap.channel),metalnessMapUv:U&&g(y.metalnessMap.channel),roughnessMapUv:R&&g(y.roughnessMap.channel),anisotropyMapUv:$&&g(y.anisotropyMap.channel),clearcoatMapUv:se&&g(y.clearcoatMap.channel),clearcoatNormalMapUv:ve&&g(y.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:ie&&g(y.clearcoatRoughnessMap.channel),iridescenceMapUv:Se&&g(y.iridescenceMap.channel),iridescenceThicknessMapUv:be&&g(y.iridescenceThicknessMap.channel),sheenColorMapUv:Ie&&g(y.sheenColorMap.channel),sheenRoughnessMapUv:Fe&&g(y.sheenRoughnessMap.channel),specularMapUv:Le&&g(y.specularMap.channel),specularColorMapUv:Ge&&g(y.specularColorMap.channel),specularIntensityMapUv:Ze&&g(y.specularIntensityMap.channel),transmissionMapUv:F&&g(y.transmissionMap.channel),thicknessMapUv:ae&&g(y.thicknessMap.channel),alphaMapUv:ce&&g(y.alphaMap.channel),vertexTangents:!!te.attributes.tangent&&(Re||T),vertexColors:y.vertexColors,vertexAlphas:y.vertexColors===!0&&!!te.attributes.color&&te.attributes.color.itemSize===4,pointsUvs:O.isPoints===!0&&!!te.attributes.uv&&(Ve||ce),fog:!!X,useFog:y.fog===!0,fogExp2:!!X&&X.isFogExp2,flatShading:y.flatShading===!0,sizeAttenuation:y.sizeAttenuation===!0,logarithmicDepthBuffer:u,reverseDepthBuffer:oe,skinning:O.isSkinnedMesh===!0,morphTargets:te.morphAttributes.position!==void 0,morphNormals:te.morphAttributes.normal!==void 0,morphColors:te.morphAttributes.color!==void 0,morphTargetsCount:_e,morphTextureStride:Be,numDirLights:_.directional.length,numPointLights:_.point.length,numSpotLights:_.spot.length,numSpotLightMaps:_.spotLightMap.length,numRectAreaLights:_.rectArea.length,numHemiLights:_.hemi.length,numDirLightShadows:_.directionalShadowMap.length,numPointLightShadows:_.pointShadowMap.length,numSpotLightShadows:_.spotShadowMap.length,numSpotLightShadowsWithMaps:_.numSpotLightShadowsWithMaps,numLightProbes:_.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:y.dithering,shadowMapEnabled:n.shadowMap.enabled&&L.length>0,shadowMapType:n.shadowMap.type,toneMapping:ke,decodeVideoTexture:Ve&&y.map.isVideoTexture===!0&&Rt.getTransfer(y.map.colorSpace)===Ot,decodeVideoTextureEmissive:I&&y.emissiveMap.isVideoTexture===!0&&Rt.getTransfer(y.emissiveMap.colorSpace)===Ot,premultipliedAlpha:y.premultipliedAlpha,doubleSided:y.side===_r,flipSided:y.side===jn,useDepthPacking:y.depthPacking>=0,depthPacking:y.depthPacking||0,index0AttributeName:y.index0AttributeName,extensionClipCullDistance:We&&y.extensions.clipCullDistance===!0&&i.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(We&&y.extensions.multiDraw===!0||Me)&&i.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:y.customProgramCacheKey()};return He.vertexUv1s=c.has(1),He.vertexUv2s=c.has(2),He.vertexUv3s=c.has(3),c.clear(),He}function p(y){const _=[];if(y.shaderID?_.push(y.shaderID):(_.push(y.customVertexShaderID),_.push(y.customFragmentShaderID)),y.defines!==void 0)for(const L in y.defines)_.push(L),_.push(y.defines[L]);return y.isRawShaderMaterial===!1&&(v(_,y),E(_,y),_.push(n.outputColorSpace)),_.push(y.customProgramCacheKey),_.join()}function v(y,_){y.push(_.precision),y.push(_.outputColorSpace),y.push(_.envMapMode),y.push(_.envMapCubeUVHeight),y.push(_.mapUv),y.push(_.alphaMapUv),y.push(_.lightMapUv),y.push(_.aoMapUv),y.push(_.bumpMapUv),y.push(_.normalMapUv),y.push(_.displacementMapUv),y.push(_.emissiveMapUv),y.push(_.metalnessMapUv),y.push(_.roughnessMapUv),y.push(_.anisotropyMapUv),y.push(_.clearcoatMapUv),y.push(_.clearcoatNormalMapUv),y.push(_.clearcoatRoughnessMapUv),y.push(_.iridescenceMapUv),y.push(_.iridescenceThicknessMapUv),y.push(_.sheenColorMapUv),y.push(_.sheenRoughnessMapUv),y.push(_.specularMapUv),y.push(_.specularColorMapUv),y.push(_.specularIntensityMapUv),y.push(_.transmissionMapUv),y.push(_.thicknessMapUv),y.push(_.combine),y.push(_.fogExp2),y.push(_.sizeAttenuation),y.push(_.morphTargetsCount),y.push(_.morphAttributeCount),y.push(_.numDirLights),y.push(_.numPointLights),y.push(_.numSpotLights),y.push(_.numSpotLightMaps),y.push(_.numHemiLights),y.push(_.numRectAreaLights),y.push(_.numDirLightShadows),y.push(_.numPointLightShadows),y.push(_.numSpotLightShadows),y.push(_.numSpotLightShadowsWithMaps),y.push(_.numLightProbes),y.push(_.shadowMapType),y.push(_.toneMapping),y.push(_.numClippingPlanes),y.push(_.numClipIntersection),y.push(_.depthPacking)}function E(y,_){a.disableAll(),_.supportsVertexTextures&&a.enable(0),_.instancing&&a.enable(1),_.instancingColor&&a.enable(2),_.instancingMorph&&a.enable(3),_.matcap&&a.enable(4),_.envMap&&a.enable(5),_.normalMapObjectSpace&&a.enable(6),_.normalMapTangentSpace&&a.enable(7),_.clearcoat&&a.enable(8),_.iridescence&&a.enable(9),_.alphaTest&&a.enable(10),_.vertexColors&&a.enable(11),_.vertexAlphas&&a.enable(12),_.vertexUv1s&&a.enable(13),_.vertexUv2s&&a.enable(14),_.vertexUv3s&&a.enable(15),_.vertexTangents&&a.enable(16),_.anisotropy&&a.enable(17),_.alphaHash&&a.enable(18),_.batching&&a.enable(19),_.dispersion&&a.enable(20),_.batchingColor&&a.enable(21),y.push(a.mask),a.disableAll(),_.fog&&a.enable(0),_.useFog&&a.enable(1),_.flatShading&&a.enable(2),_.logarithmicDepthBuffer&&a.enable(3),_.reverseDepthBuffer&&a.enable(4),_.skinning&&a.enable(5),_.morphTargets&&a.enable(6),_.morphNormals&&a.enable(7),_.morphColors&&a.enable(8),_.premultipliedAlpha&&a.enable(9),_.shadowMapEnabled&&a.enable(10),_.doubleSided&&a.enable(11),_.flipSided&&a.enable(12),_.useDepthPacking&&a.enable(13),_.dithering&&a.enable(14),_.transmission&&a.enable(15),_.sheen&&a.enable(16),_.opaque&&a.enable(17),_.pointsUvs&&a.enable(18),_.decodeVideoTexture&&a.enable(19),_.decodeVideoTextureEmissive&&a.enable(20),_.alphaToCoverage&&a.enable(21),y.push(a.mask)}function x(y){const _=A[y.type];let L;if(_){const Q=Xi[_];L=PN.clone(Q.uniforms)}else L=y.uniforms;return L}function M(y,_){let L;for(let Q=0,O=h.length;Q<O;Q++){const X=h[Q];if(X.cacheKey===_){L=X,++L.usedTimes;break}}return L===void 0&&(L=new iH(n,_,y,s),h.push(L)),L}function w(y){if(--y.usedTimes===0){const _=h.indexOf(y);h[_]=h[h.length-1],h.pop(),y.destroy()}}function S(y){l.remove(y)}function B(){l.dispose()}return{getParameters:m,getProgramCacheKey:p,getUniforms:x,acquireProgram:M,releaseProgram:w,releaseShaderCache:S,programs:h,dispose:B}}function lH(){let n=new WeakMap;function e(o){return n.has(o)}function t(o){let a=n.get(o);return a===void 0&&(a={},n.set(o,a)),a}function i(o){n.delete(o)}function r(o,a,l){n.get(o)[a]=l}function s(){n=new WeakMap}return{has:e,get:t,remove:i,update:r,dispose:s}}function cH(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function Z_(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function eb(){const n=[];let e=0;const t=[],i=[],r=[];function s(){e=0,t.length=0,i.length=0,r.length=0}function o(u,d,f,A,g,m){let p=n[e];return p===void 0?(p={id:u.id,object:u,geometry:d,material:f,groupOrder:A,renderOrder:u.renderOrder,z:g,group:m},n[e]=p):(p.id=u.id,p.object=u,p.geometry=d,p.material=f,p.groupOrder=A,p.renderOrder=u.renderOrder,p.z=g,p.group=m),e++,p}function a(u,d,f,A,g,m){const p=o(u,d,f,A,g,m);f.transmission>0?i.push(p):f.transparent===!0?r.push(p):t.push(p)}function l(u,d,f,A,g,m){const p=o(u,d,f,A,g,m);f.transmission>0?i.unshift(p):f.transparent===!0?r.unshift(p):t.unshift(p)}function c(u,d){t.length>1&&t.sort(u||cH),i.length>1&&i.sort(d||Z_),r.length>1&&r.sort(d||Z_)}function h(){for(let u=e,d=n.length;u<d;u++){const f=n[u];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:t,transmissive:i,transparent:r,init:s,push:a,unshift:l,finish:h,sort:c}}function hH(){let n=new WeakMap;function e(i,r){const s=n.get(i);let o;return s===void 0?(o=new eb,n.set(i,[o])):r>=s.length?(o=new eb,s.push(o)):o=s[r],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function uH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new ye,color:new kt};break;case"SpotLight":t={position:new ye,direction:new ye,color:new kt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new ye,color:new kt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new ye,skyColor:new kt,groundColor:new kt};break;case"RectAreaLight":t={color:new kt,position:new ye,halfWidth:new ye,halfHeight:new ye};break}return n[e.id]=t,t}}}function dH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new zt};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new zt};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new zt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let fH=0;function pH(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function mH(n){const e=new uH,t=dH(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)i.probe.push(new ye);const r=new ye,s=new $t,o=new $t;function a(c){let h=0,u=0,d=0;for(let y=0;y<9;y++)i.probe[y].set(0,0,0);let f=0,A=0,g=0,m=0,p=0,v=0,E=0,x=0,M=0,w=0,S=0;c.sort(pH);for(let y=0,_=c.length;y<_;y++){const L=c[y],Q=L.color,O=L.intensity,X=L.distance,te=L.shadow&&L.shadow.map?L.shadow.map.texture:null;if(L.isAmbientLight)h+=Q.r*O,u+=Q.g*O,d+=Q.b*O;else if(L.isLightProbe){for(let W=0;W<9;W++)i.probe[W].addScaledVector(L.sh.coefficients[W],O);S++}else if(L.isDirectionalLight){const W=e.get(L);if(W.color.copy(L.color).multiplyScalar(L.intensity),L.castShadow){const Z=L.shadow,q=t.get(L);q.shadowIntensity=Z.intensity,q.shadowBias=Z.bias,q.shadowNormalBias=Z.normalBias,q.shadowRadius=Z.radius,q.shadowMapSize=Z.mapSize,i.directionalShadow[f]=q,i.directionalShadowMap[f]=te,i.directionalShadowMatrix[f]=L.shadow.matrix,v++}i.directional[f]=W,f++}else if(L.isSpotLight){const W=e.get(L);W.position.setFromMatrixPosition(L.matrixWorld),W.color.copy(Q).multiplyScalar(O),W.distance=X,W.coneCos=Math.cos(L.angle),W.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),W.decay=L.decay,i.spot[g]=W;const Z=L.shadow;if(L.map&&(i.spotLightMap[M]=L.map,M++,Z.updateMatrices(L),L.castShadow&&w++),i.spotLightMatrix[g]=Z.matrix,L.castShadow){const q=t.get(L);q.shadowIntensity=Z.intensity,q.shadowBias=Z.bias,q.shadowNormalBias=Z.normalBias,q.shadowRadius=Z.radius,q.shadowMapSize=Z.mapSize,i.spotShadow[g]=q,i.spotShadowMap[g]=te,x++}g++}else if(L.isRectAreaLight){const W=e.get(L);W.color.copy(Q).multiplyScalar(O),W.halfWidth.set(L.width*.5,0,0),W.halfHeight.set(0,L.height*.5,0),i.rectArea[m]=W,m++}else if(L.isPointLight){const W=e.get(L);if(W.color.copy(L.color).multiplyScalar(L.intensity),W.distance=L.distance,W.decay=L.decay,L.castShadow){const Z=L.shadow,q=t.get(L);q.shadowIntensity=Z.intensity,q.shadowBias=Z.bias,q.shadowNormalBias=Z.normalBias,q.shadowRadius=Z.radius,q.shadowMapSize=Z.mapSize,q.shadowCameraNear=Z.camera.near,q.shadowCameraFar=Z.camera.far,i.pointShadow[A]=q,i.pointShadowMap[A]=te,i.pointShadowMatrix[A]=L.shadow.matrix,E++}i.point[A]=W,A++}else if(L.isHemisphereLight){const W=e.get(L);W.skyColor.copy(L.color).multiplyScalar(O),W.groundColor.copy(L.groundColor).multiplyScalar(O),i.hemi[p]=W,p++}}m>0&&(n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=je.LTC_FLOAT_1,i.rectAreaLTC2=je.LTC_FLOAT_2):(i.rectAreaLTC1=je.LTC_HALF_1,i.rectAreaLTC2=je.LTC_HALF_2)),i.ambient[0]=h,i.ambient[1]=u,i.ambient[2]=d;const B=i.hash;(B.directionalLength!==f||B.pointLength!==A||B.spotLength!==g||B.rectAreaLength!==m||B.hemiLength!==p||B.numDirectionalShadows!==v||B.numPointShadows!==E||B.numSpotShadows!==x||B.numSpotMaps!==M||B.numLightProbes!==S)&&(i.directional.length=f,i.spot.length=g,i.rectArea.length=m,i.point.length=A,i.hemi.length=p,i.directionalShadow.length=v,i.directionalShadowMap.length=v,i.pointShadow.length=E,i.pointShadowMap.length=E,i.spotShadow.length=x,i.spotShadowMap.length=x,i.directionalShadowMatrix.length=v,i.pointShadowMatrix.length=E,i.spotLightMatrix.length=x+M-w,i.spotLightMap.length=M,i.numSpotLightShadowsWithMaps=w,i.numLightProbes=S,B.directionalLength=f,B.pointLength=A,B.spotLength=g,B.rectAreaLength=m,B.hemiLength=p,B.numDirectionalShadows=v,B.numPointShadows=E,B.numSpotShadows=x,B.numSpotMaps=M,B.numLightProbes=S,i.version=fH++)}function l(c,h){let u=0,d=0,f=0,A=0,g=0;const m=h.matrixWorldInverse;for(let p=0,v=c.length;p<v;p++){const E=c[p];if(E.isDirectionalLight){const x=i.directional[u];x.direction.setFromMatrixPosition(E.matrixWorld),r.setFromMatrixPosition(E.target.matrixWorld),x.direction.sub(r),x.direction.transformDirection(m),u++}else if(E.isSpotLight){const x=i.spot[f];x.position.setFromMatrixPosition(E.matrixWorld),x.position.applyMatrix4(m),x.direction.setFromMatrixPosition(E.matrixWorld),r.setFromMatrixPosition(E.target.matrixWorld),x.direction.sub(r),x.direction.transformDirection(m),f++}else if(E.isRectAreaLight){const x=i.rectArea[A];x.position.setFromMatrixPosition(E.matrixWorld),x.position.applyMatrix4(m),o.identity(),s.copy(E.matrixWorld),s.premultiply(m),o.extractRotation(s),x.halfWidth.set(E.width*.5,0,0),x.halfHeight.set(0,E.height*.5,0),x.halfWidth.applyMatrix4(o),x.halfHeight.applyMatrix4(o),A++}else if(E.isPointLight){const x=i.point[d];x.position.setFromMatrixPosition(E.matrixWorld),x.position.applyMatrix4(m),d++}else if(E.isHemisphereLight){const x=i.hemi[g];x.direction.setFromMatrixPosition(E.matrixWorld),x.direction.transformDirection(m),g++}}}return{setup:a,setupView:l,state:i}}function tb(n){const e=new mH(n),t=[],i=[];function r(h){c.camera=h,t.length=0,i.length=0}function s(h){t.push(h)}function o(h){i.push(h)}function a(){e.setup(t)}function l(h){e.setupView(t,h)}const c={lightsArray:t,shadowsArray:i,camera:null,lights:e,transmissionRenderTarget:{}};return{init:r,state:c,setupLights:a,setupLightsView:l,pushLight:s,pushShadow:o}}function AH(n){let e=new WeakMap;function t(r,s=0){const o=e.get(r);let a;return o===void 0?(a=new tb(n),e.set(r,[a])):s>=o.length?(a=new tb(n),o.push(a)):a=o[s],a}function i(){e=new WeakMap}return{get:t,dispose:i}}const gH=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,vH=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function EH(n,e,t){let i=new sw;const r=new zt,s=new zt,o=new jt,a=new QN({depthPacking:G3}),l=new WN,c={},h=t.maxTextureSize,u={[ws]:jn,[jn]:ws,[_r]:_r},d=new Ts({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new zt},radius:{value:4}},vertexShader:gH,fragmentShader:vH}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const A=new No;A.setAttribute("position",new Zi(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new Br(A,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=US;let p=this.type;this.render=function(w,S,B){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||w.length===0)return;const y=n.getRenderTarget(),_=n.getActiveCubeFace(),L=n.getActiveMipmapLevel(),Q=n.state;Q.setBlending(ys),Q.buffers.color.setClear(1,1,1,1),Q.buffers.depth.setTest(!0),Q.setScissorTest(!1);const O=p!==vr&&this.type===vr,X=p===vr&&this.type!==vr;for(let te=0,W=w.length;te<W;te++){const Z=w[te],q=Z.shadow;if(q===void 0){console.warn("THREE.WebGLShadowMap:",Z,"has no shadow.");continue}if(q.autoUpdate===!1&&q.needsUpdate===!1)continue;r.copy(q.mapSize);const re=q.getFrameExtents();if(r.multiply(re),s.copy(q.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(s.x=Math.floor(h/re.x),r.x=s.x*re.x,q.mapSize.x=s.x),r.y>h&&(s.y=Math.floor(h/re.y),r.y=s.y*re.y,q.mapSize.y=s.y)),q.map===null||O===!0||X===!0){const _e=this.type!==vr?{minFilter:Pi,magFilter:Pi}:{};q.map!==null&&q.map.dispose(),q.map=new Do(r.x,r.y,_e),q.map.texture.name=Z.name+".shadowMap",q.camera.updateProjectionMatrix()}n.setRenderTarget(q.map),n.clear();const ue=q.getViewportCount();for(let _e=0;_e<ue;_e++){const Be=q.getViewport(_e);o.set(s.x*Be.x,s.y*Be.y,s.x*Be.z,s.y*Be.w),Q.viewport(o),q.updateMatrices(Z,_e),i=q.getFrustum(),x(S,B,q.camera,Z,this.type)}q.isPointLightShadow!==!0&&this.type===vr&&v(q,B),q.needsUpdate=!1}p=this.type,m.needsUpdate=!1,n.setRenderTarget(y,_,L)};function v(w,S){const B=e.update(g);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,f.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),w.mapPass===null&&(w.mapPass=new Do(r.x,r.y)),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,n.setRenderTarget(w.mapPass),n.clear(),n.renderBufferDirect(S,null,B,d,g,null),f.uniforms.shadow_pass.value=w.mapPass.texture,f.uniforms.resolution.value=w.mapSize,f.uniforms.radius.value=w.radius,n.setRenderTarget(w.map),n.clear(),n.renderBufferDirect(S,null,B,f,g,null)}function E(w,S,B,y){let _=null;const L=B.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(L!==void 0)_=L;else if(_=B.isPointLight===!0?l:a,n.localClippingEnabled&&S.clipShadows===!0&&Array.isArray(S.clippingPlanes)&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0||S.map&&S.alphaTest>0){const Q=_.uuid,O=S.uuid;let X=c[Q];X===void 0&&(X={},c[Q]=X);let te=X[O];te===void 0&&(te=_.clone(),X[O]=te,S.addEventListener("dispose",M)),_=te}if(_.visible=S.visible,_.wireframe=S.wireframe,y===vr?_.side=S.shadowSide!==null?S.shadowSide:S.side:_.side=S.shadowSide!==null?S.shadowSide:u[S.side],_.alphaMap=S.alphaMap,_.alphaTest=S.alphaTest,_.map=S.map,_.clipShadows=S.clipShadows,_.clippingPlanes=S.clippingPlanes,_.clipIntersection=S.clipIntersection,_.displacementMap=S.displacementMap,_.displacementScale=S.displacementScale,_.displacementBias=S.displacementBias,_.wireframeLinewidth=S.wireframeLinewidth,_.linewidth=S.linewidth,B.isPointLight===!0&&_.isMeshDistanceMaterial===!0){const Q=n.properties.get(_);Q.light=B}return _}function x(w,S,B,y,_){if(w.visible===!1)return;if(w.layers.test(S.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&_===vr)&&(!w.frustumCulled||i.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,w.matrixWorld);const O=e.update(w),X=w.material;if(Array.isArray(X)){const te=O.groups;for(let W=0,Z=te.length;W<Z;W++){const q=te[W],re=X[q.materialIndex];if(re&&re.visible){const ue=E(w,re,y,_);w.onBeforeShadow(n,w,S,B,O,ue,q),n.renderBufferDirect(B,null,O,ue,w,q),w.onAfterShadow(n,w,S,B,O,ue,q)}}}else if(X.visible){const te=E(w,X,y,_);w.onBeforeShadow(n,w,S,B,O,te,null),n.renderBufferDirect(B,null,O,te,w,null),w.onAfterShadow(n,w,S,B,O,te,null)}}const Q=w.children;for(let O=0,X=Q.length;O<X;O++)x(Q[O],S,B,y,_)}function M(w){w.target.removeEventListener("dispose",M);for(const B in c){const y=c[B],_=w.target.uuid;_ in y&&(y[_].dispose(),delete y[_])}}}const xH={[og]:ag,[lg]:ug,[cg]:dg,[Ka]:hg,[ag]:og,[ug]:lg,[dg]:cg,[hg]:Ka};function yH(n,e){function t(){let F=!1;const ae=new jt;let ne=null;const ce=new jt(0,0,0,0);return{setMask:function(ge){ne!==ge&&!F&&(n.colorMask(ge,ge,ge,ge),ne=ge)},setLocked:function(ge){F=ge},setClear:function(ge,xe,We,ke,He){He===!0&&(ge*=ke,xe*=ke,We*=ke),ae.set(ge,xe,We,ke),ce.equals(ae)===!1&&(n.clearColor(ge,xe,We,ke),ce.copy(ae))},reset:function(){F=!1,ne=null,ce.set(-1,0,0,0)}}}function i(){let F=!1,ae=!1,ne=null,ce=null,ge=null;return{setReversed:function(xe){if(ae!==xe){const We=e.get("EXT_clip_control");xe?We.clipControlEXT(We.LOWER_LEFT_EXT,We.ZERO_TO_ONE_EXT):We.clipControlEXT(We.LOWER_LEFT_EXT,We.NEGATIVE_ONE_TO_ONE_EXT),ae=xe;const ke=ge;ge=null,this.setClear(ke)}},getReversed:function(){return ae},setTest:function(xe){xe?pe(n.DEPTH_TEST):oe(n.DEPTH_TEST)},setMask:function(xe){ne!==xe&&!F&&(n.depthMask(xe),ne=xe)},setFunc:function(xe){if(ae&&(xe=xH[xe]),ce!==xe){switch(xe){case og:n.depthFunc(n.NEVER);break;case ag:n.depthFunc(n.ALWAYS);break;case lg:n.depthFunc(n.LESS);break;case Ka:n.depthFunc(n.LEQUAL);break;case cg:n.depthFunc(n.EQUAL);break;case hg:n.depthFunc(n.GEQUAL);break;case ug:n.depthFunc(n.GREATER);break;case dg:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}ce=xe}},setLocked:function(xe){F=xe},setClear:function(xe){ge!==xe&&(ae&&(xe=1-xe),n.clearDepth(xe),ge=xe)},reset:function(){F=!1,ne=null,ce=null,ge=null,ae=!1}}}function r(){let F=!1,ae=null,ne=null,ce=null,ge=null,xe=null,We=null,ke=null,He=null;return{setTest:function(Qe){F||(Qe?pe(n.STENCIL_TEST):oe(n.STENCIL_TEST))},setMask:function(Qe){ae!==Qe&&!F&&(n.stencilMask(Qe),ae=Qe)},setFunc:function(Qe,ht,Pt){(ne!==Qe||ce!==ht||ge!==Pt)&&(n.stencilFunc(Qe,ht,Pt),ne=Qe,ce=ht,ge=Pt)},setOp:function(Qe,ht,Pt){(xe!==Qe||We!==ht||ke!==Pt)&&(n.stencilOp(Qe,ht,Pt),xe=Qe,We=ht,ke=Pt)},setLocked:function(Qe){F=Qe},setClear:function(Qe){He!==Qe&&(n.clearStencil(Qe),He=Qe)},reset:function(){F=!1,ae=null,ne=null,ce=null,ge=null,xe=null,We=null,ke=null,He=null}}}const s=new t,o=new i,a=new r,l=new WeakMap,c=new WeakMap;let h={},u={},d=new WeakMap,f=[],A=null,g=!1,m=null,p=null,v=null,E=null,x=null,M=null,w=null,S=new kt(0,0,0),B=0,y=!1,_=null,L=null,Q=null,O=null,X=null;const te=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let W=!1,Z=0;const q=n.getParameter(n.VERSION);q.indexOf("WebGL")!==-1?(Z=parseFloat(/^WebGL (\d)/.exec(q)[1]),W=Z>=1):q.indexOf("OpenGL ES")!==-1&&(Z=parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),W=Z>=2);let re=null,ue={};const _e=n.getParameter(n.SCISSOR_BOX),Be=n.getParameter(n.VIEWPORT),ze=new jt().fromArray(_e),le=new jt().fromArray(Be);function Ee(F,ae,ne,ce){const ge=new Uint8Array(4),xe=n.createTexture();n.bindTexture(F,xe),n.texParameteri(F,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(F,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let We=0;We<ne;We++)F===n.TEXTURE_3D||F===n.TEXTURE_2D_ARRAY?n.texImage3D(ae,0,n.RGBA,1,1,ce,0,n.RGBA,n.UNSIGNED_BYTE,ge):n.texImage2D(ae+We,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,ge);return xe}const Ue={};Ue[n.TEXTURE_2D]=Ee(n.TEXTURE_2D,n.TEXTURE_2D,1),Ue[n.TEXTURE_CUBE_MAP]=Ee(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),Ue[n.TEXTURE_2D_ARRAY]=Ee(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),Ue[n.TEXTURE_3D]=Ee(n.TEXTURE_3D,n.TEXTURE_3D,1,1),s.setClear(0,0,0,1),o.setClear(1),a.setClear(0),pe(n.DEPTH_TEST),o.setFunc(Ka),Te(!1),Re(r_),pe(n.CULL_FACE),V(ys);function pe(F){h[F]!==!0&&(n.enable(F),h[F]=!0)}function oe(F){h[F]!==!1&&(n.disable(F),h[F]=!1)}function we(F,ae){return u[F]!==ae?(n.bindFramebuffer(F,ae),u[F]=ae,F===n.DRAW_FRAMEBUFFER&&(u[n.FRAMEBUFFER]=ae),F===n.FRAMEBUFFER&&(u[n.DRAW_FRAMEBUFFER]=ae),!0):!1}function Me(F,ae){let ne=f,ce=!1;if(F){ne=d.get(ae),ne===void 0&&(ne=[],d.set(ae,ne));const ge=F.textures;if(ne.length!==ge.length||ne[0]!==n.COLOR_ATTACHMENT0){for(let xe=0,We=ge.length;xe<We;xe++)ne[xe]=n.COLOR_ATTACHMENT0+xe;ne.length=ge.length,ce=!0}}else ne[0]!==n.BACK&&(ne[0]=n.BACK,ce=!0);ce&&n.drawBuffers(ne)}function Ve(F){return A!==F?(n.useProgram(F),A=F,!0):!1}const me={[po]:n.FUNC_ADD,[d3]:n.FUNC_SUBTRACT,[f3]:n.FUNC_REVERSE_SUBTRACT};me[p3]=n.MIN,me[m3]=n.MAX;const Ae={[A3]:n.ZERO,[g3]:n.ONE,[v3]:n.SRC_COLOR,[rg]:n.SRC_ALPHA,[C3]:n.SRC_ALPHA_SATURATE,[_3]:n.DST_COLOR,[x3]:n.DST_ALPHA,[E3]:n.ONE_MINUS_SRC_COLOR,[sg]:n.ONE_MINUS_SRC_ALPHA,[b3]:n.ONE_MINUS_DST_COLOR,[y3]:n.ONE_MINUS_DST_ALPHA,[M3]:n.CONSTANT_COLOR,[S3]:n.ONE_MINUS_CONSTANT_COLOR,[w3]:n.CONSTANT_ALPHA,[T3]:n.ONE_MINUS_CONSTANT_ALPHA};function V(F,ae,ne,ce,ge,xe,We,ke,He,Qe){if(F===ys){g===!0&&(oe(n.BLEND),g=!1);return}if(g===!1&&(pe(n.BLEND),g=!0),F!==u3){if(F!==m||Qe!==y){if((p!==po||x!==po)&&(n.blendEquation(n.FUNC_ADD),p=po,x=po),Qe)switch(F){case Qa:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case s_:n.blendFunc(n.ONE,n.ONE);break;case o_:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case a_:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",F);break}else switch(F){case Qa:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case s_:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case o_:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case a_:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",F);break}v=null,E=null,M=null,w=null,S.set(0,0,0),B=0,m=F,y=Qe}return}ge=ge||ae,xe=xe||ne,We=We||ce,(ae!==p||ge!==x)&&(n.blendEquationSeparate(me[ae],me[ge]),p=ae,x=ge),(ne!==v||ce!==E||xe!==M||We!==w)&&(n.blendFuncSeparate(Ae[ne],Ae[ce],Ae[xe],Ae[We]),v=ne,E=ce,M=xe,w=We),(ke.equals(S)===!1||He!==B)&&(n.blendColor(ke.r,ke.g,ke.b,He),S.copy(ke),B=He),m=F,y=!1}function j(F,ae){F.side===_r?oe(n.CULL_FACE):pe(n.CULL_FACE);let ne=F.side===jn;ae&&(ne=!ne),Te(ne),F.blending===Qa&&F.transparent===!1?V(ys):V(F.blending,F.blendEquation,F.blendSrc,F.blendDst,F.blendEquationAlpha,F.blendSrcAlpha,F.blendDstAlpha,F.blendColor,F.blendAlpha,F.premultipliedAlpha),o.setFunc(F.depthFunc),o.setTest(F.depthTest),o.setMask(F.depthWrite),s.setMask(F.colorWrite);const ce=F.stencilWrite;a.setTest(ce),ce&&(a.setMask(F.stencilWriteMask),a.setFunc(F.stencilFunc,F.stencilRef,F.stencilFuncMask),a.setOp(F.stencilFail,F.stencilZFail,F.stencilZPass)),I(F.polygonOffset,F.polygonOffsetFactor,F.polygonOffsetUnits),F.alphaToCoverage===!0?pe(n.SAMPLE_ALPHA_TO_COVERAGE):oe(n.SAMPLE_ALPHA_TO_COVERAGE)}function Te(F){_!==F&&(F?n.frontFace(n.CW):n.frontFace(n.CCW),_=F)}function Re(F){F!==l3?(pe(n.CULL_FACE),F!==L&&(F===r_?n.cullFace(n.BACK):F===c3?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):oe(n.CULL_FACE),L=F}function b(F){F!==Q&&(W&&n.lineWidth(F),Q=F)}function I(F,ae,ne){F?(pe(n.POLYGON_OFFSET_FILL),(O!==ae||X!==ne)&&(n.polygonOffset(ae,ne),O=ae,X=ne)):oe(n.POLYGON_OFFSET_FILL)}function U(F){F?pe(n.SCISSOR_TEST):oe(n.SCISSOR_TEST)}function R(F){F===void 0&&(F=n.TEXTURE0+te-1),re!==F&&(n.activeTexture(F),re=F)}function T(F,ae,ne){ne===void 0&&(re===null?ne=n.TEXTURE0+te-1:ne=re);let ce=ue[ne];ce===void 0&&(ce={type:void 0,texture:void 0},ue[ne]=ce),(ce.type!==F||ce.texture!==ae)&&(re!==ne&&(n.activeTexture(ne),re=ne),n.bindTexture(F,ae||Ue[F]),ce.type=F,ce.texture=ae)}function G(){const F=ue[re];F!==void 0&&F.type!==void 0&&(n.bindTexture(F.type,null),F.type=void 0,F.texture=void 0)}function J(){try{n.compressedTexImage2D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function de(){try{n.compressedTexImage3D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function N(){try{n.texSubImage2D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function P(){try{n.texSubImage3D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function $(){try{n.compressedTexSubImage2D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function se(){try{n.compressedTexSubImage3D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function ve(){try{n.texStorage2D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function ie(){try{n.texStorage3D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function Se(){try{n.texImage2D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function be(){try{n.texImage3D(...arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function Ie(F){ze.equals(F)===!1&&(n.scissor(F.x,F.y,F.z,F.w),ze.copy(F))}function Fe(F){le.equals(F)===!1&&(n.viewport(F.x,F.y,F.z,F.w),le.copy(F))}function Le(F,ae){let ne=c.get(ae);ne===void 0&&(ne=new WeakMap,c.set(ae,ne));let ce=ne.get(F);ce===void 0&&(ce=n.getUniformBlockIndex(ae,F.name),ne.set(F,ce))}function Ge(F,ae){const ce=c.get(ae).get(F);l.get(ae)!==ce&&(n.uniformBlockBinding(ae,ce,F.__bindingPointIndex),l.set(ae,ce))}function Ze(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),o.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},re=null,ue={},u={},d=new WeakMap,f=[],A=null,g=!1,m=null,p=null,v=null,E=null,x=null,M=null,w=null,S=new kt(0,0,0),B=0,y=!1,_=null,L=null,Q=null,O=null,X=null,ze.set(0,0,n.canvas.width,n.canvas.height),le.set(0,0,n.canvas.width,n.canvas.height),s.reset(),o.reset(),a.reset()}return{buffers:{color:s,depth:o,stencil:a},enable:pe,disable:oe,bindFramebuffer:we,drawBuffers:Me,useProgram:Ve,setBlending:V,setMaterial:j,setFlipSided:Te,setCullFace:Re,setLineWidth:b,setPolygonOffset:I,setScissorTest:U,activeTexture:R,bindTexture:T,unbindTexture:G,compressedTexImage2D:J,compressedTexImage3D:de,texImage2D:Se,texImage3D:be,updateUBOMapping:Le,uniformBlockBinding:Ge,texStorage2D:ve,texStorage3D:ie,texSubImage2D:N,texSubImage3D:P,compressedTexSubImage2D:$,compressedTexSubImage3D:se,scissor:Ie,viewport:Fe,reset:Ze}}function _H(n,e,t,i,r,s,o){const a=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new zt,h=new WeakMap;let u;const d=new WeakMap;let f=!1;try{f=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function A(R,T){return f?new OffscreenCanvas(R,T):rf("canvas")}function g(R,T,G){let J=1;const de=U(R);if((de.width>G||de.height>G)&&(J=G/Math.max(de.width,de.height)),J<1)if(typeof HTMLImageElement<"u"&&R instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&R instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&R instanceof ImageBitmap||typeof VideoFrame<"u"&&R instanceof VideoFrame){const N=Math.floor(J*de.width),P=Math.floor(J*de.height);u===void 0&&(u=A(N,P));const $=T?A(N,P):u;return $.width=N,$.height=P,$.getContext("2d").drawImage(R,0,0,N,P),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+de.width+"x"+de.height+") to ("+N+"x"+P+")."),$}else return"data"in R&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+de.width+"x"+de.height+")."),R;return R}function m(R){return R.generateMipmaps}function p(R){n.generateMipmap(R)}function v(R){return R.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:R.isWebGL3DRenderTarget?n.TEXTURE_3D:R.isWebGLArrayRenderTarget||R.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function E(R,T,G,J,de=!1){if(R!==null){if(n[R]!==void 0)return n[R];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+R+"'")}let N=T;if(T===n.RED&&(G===n.FLOAT&&(N=n.R32F),G===n.HALF_FLOAT&&(N=n.R16F),G===n.UNSIGNED_BYTE&&(N=n.R8)),T===n.RED_INTEGER&&(G===n.UNSIGNED_BYTE&&(N=n.R8UI),G===n.UNSIGNED_SHORT&&(N=n.R16UI),G===n.UNSIGNED_INT&&(N=n.R32UI),G===n.BYTE&&(N=n.R8I),G===n.SHORT&&(N=n.R16I),G===n.INT&&(N=n.R32I)),T===n.RG&&(G===n.FLOAT&&(N=n.RG32F),G===n.HALF_FLOAT&&(N=n.RG16F),G===n.UNSIGNED_BYTE&&(N=n.RG8)),T===n.RG_INTEGER&&(G===n.UNSIGNED_BYTE&&(N=n.RG8UI),G===n.UNSIGNED_SHORT&&(N=n.RG16UI),G===n.UNSIGNED_INT&&(N=n.RG32UI),G===n.BYTE&&(N=n.RG8I),G===n.SHORT&&(N=n.RG16I),G===n.INT&&(N=n.RG32I)),T===n.RGB_INTEGER&&(G===n.UNSIGNED_BYTE&&(N=n.RGB8UI),G===n.UNSIGNED_SHORT&&(N=n.RGB16UI),G===n.UNSIGNED_INT&&(N=n.RGB32UI),G===n.BYTE&&(N=n.RGB8I),G===n.SHORT&&(N=n.RGB16I),G===n.INT&&(N=n.RGB32I)),T===n.RGBA_INTEGER&&(G===n.UNSIGNED_BYTE&&(N=n.RGBA8UI),G===n.UNSIGNED_SHORT&&(N=n.RGBA16UI),G===n.UNSIGNED_INT&&(N=n.RGBA32UI),G===n.BYTE&&(N=n.RGBA8I),G===n.SHORT&&(N=n.RGBA16I),G===n.INT&&(N=n.RGBA32I)),T===n.RGB&&G===n.UNSIGNED_INT_5_9_9_9_REV&&(N=n.RGB9_E5),T===n.RGBA){const P=de?tf:Rt.getTransfer(J);G===n.FLOAT&&(N=n.RGBA32F),G===n.HALF_FLOAT&&(N=n.RGBA16F),G===n.UNSIGNED_BYTE&&(N=P===Ot?n.SRGB8_ALPHA8:n.RGBA8),G===n.UNSIGNED_SHORT_4_4_4_4&&(N=n.RGBA4),G===n.UNSIGNED_SHORT_5_5_5_1&&(N=n.RGB5_A1)}return(N===n.R16F||N===n.R32F||N===n.RG16F||N===n.RG32F||N===n.RGBA16F||N===n.RGBA32F)&&e.get("EXT_color_buffer_float"),N}function x(R,T){let G;return R?T===null||T===Lo||T===wc?G=n.DEPTH24_STENCIL8:T===Ir?G=n.DEPTH32F_STENCIL8:T===Sc&&(G=n.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):T===null||T===Lo||T===wc?G=n.DEPTH_COMPONENT24:T===Ir?G=n.DEPTH_COMPONENT32F:T===Sc&&(G=n.DEPTH_COMPONENT16),G}function M(R,T){return m(R)===!0||R.isFramebufferTexture&&R.minFilter!==Pi&&R.minFilter!==Ai?Math.log2(Math.max(T.width,T.height))+1:R.mipmaps!==void 0&&R.mipmaps.length>0?R.mipmaps.length:R.isCompressedTexture&&Array.isArray(R.image)?T.mipmaps.length:1}function w(R){const T=R.target;T.removeEventListener("dispose",w),B(T),T.isVideoTexture&&h.delete(T)}function S(R){const T=R.target;T.removeEventListener("dispose",S),_(T)}function B(R){const T=i.get(R);if(T.__webglInit===void 0)return;const G=R.source,J=d.get(G);if(J){const de=J[T.__cacheKey];de.usedTimes--,de.usedTimes===0&&y(R),Object.keys(J).length===0&&d.delete(G)}i.remove(R)}function y(R){const T=i.get(R);n.deleteTexture(T.__webglTexture);const G=R.source,J=d.get(G);delete J[T.__cacheKey],o.memory.textures--}function _(R){const T=i.get(R);if(R.depthTexture&&(R.depthTexture.dispose(),i.remove(R.depthTexture)),R.isWebGLCubeRenderTarget)for(let J=0;J<6;J++){if(Array.isArray(T.__webglFramebuffer[J]))for(let de=0;de<T.__webglFramebuffer[J].length;de++)n.deleteFramebuffer(T.__webglFramebuffer[J][de]);else n.deleteFramebuffer(T.__webglFramebuffer[J]);T.__webglDepthbuffer&&n.deleteRenderbuffer(T.__webglDepthbuffer[J])}else{if(Array.isArray(T.__webglFramebuffer))for(let J=0;J<T.__webglFramebuffer.length;J++)n.deleteFramebuffer(T.__webglFramebuffer[J]);else n.deleteFramebuffer(T.__webglFramebuffer);if(T.__webglDepthbuffer&&n.deleteRenderbuffer(T.__webglDepthbuffer),T.__webglMultisampledFramebuffer&&n.deleteFramebuffer(T.__webglMultisampledFramebuffer),T.__webglColorRenderbuffer)for(let J=0;J<T.__webglColorRenderbuffer.length;J++)T.__webglColorRenderbuffer[J]&&n.deleteRenderbuffer(T.__webglColorRenderbuffer[J]);T.__webglDepthRenderbuffer&&n.deleteRenderbuffer(T.__webglDepthRenderbuffer)}const G=R.textures;for(let J=0,de=G.length;J<de;J++){const N=i.get(G[J]);N.__webglTexture&&(n.deleteTexture(N.__webglTexture),o.memory.textures--),i.remove(G[J])}i.remove(R)}let L=0;function Q(){L=0}function O(){const R=L;return R>=r.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+R+" texture units while this GPU supports only "+r.maxTextures),L+=1,R}function X(R){const T=[];return T.push(R.wrapS),T.push(R.wrapT),T.push(R.wrapR||0),T.push(R.magFilter),T.push(R.minFilter),T.push(R.anisotropy),T.push(R.internalFormat),T.push(R.format),T.push(R.type),T.push(R.generateMipmaps),T.push(R.premultiplyAlpha),T.push(R.flipY),T.push(R.unpackAlignment),T.push(R.colorSpace),T.join()}function te(R,T){const G=i.get(R);if(R.isVideoTexture&&b(R),R.isRenderTargetTexture===!1&&R.version>0&&G.__version!==R.version){const J=R.image;if(J===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(J.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{le(G,R,T);return}}t.bindTexture(n.TEXTURE_2D,G.__webglTexture,n.TEXTURE0+T)}function W(R,T){const G=i.get(R);if(R.version>0&&G.__version!==R.version){le(G,R,T);return}t.bindTexture(n.TEXTURE_2D_ARRAY,G.__webglTexture,n.TEXTURE0+T)}function Z(R,T){const G=i.get(R);if(R.version>0&&G.__version!==R.version){le(G,R,T);return}t.bindTexture(n.TEXTURE_3D,G.__webglTexture,n.TEXTURE0+T)}function q(R,T){const G=i.get(R);if(R.version>0&&G.__version!==R.version){Ee(G,R,T);return}t.bindTexture(n.TEXTURE_CUBE_MAP,G.__webglTexture,n.TEXTURE0+T)}const re={[mg]:n.REPEAT,[yo]:n.CLAMP_TO_EDGE,[Ag]:n.MIRRORED_REPEAT},ue={[Pi]:n.NEAREST,[O3]:n.NEAREST_MIPMAP_NEAREST,[fu]:n.NEAREST_MIPMAP_LINEAR,[Ai]:n.LINEAR,[Om]:n.LINEAR_MIPMAP_NEAREST,[_o]:n.LINEAR_MIPMAP_LINEAR},_e={[V3]:n.NEVER,[j3]:n.ALWAYS,[Q3]:n.LESS,[YS]:n.LEQUAL,[W3]:n.EQUAL,[Y3]:n.GEQUAL,[X3]:n.GREATER,[q3]:n.NOTEQUAL};function Be(R,T){if(T.type===Ir&&e.has("OES_texture_float_linear")===!1&&(T.magFilter===Ai||T.magFilter===Om||T.magFilter===fu||T.magFilter===_o||T.minFilter===Ai||T.minFilter===Om||T.minFilter===fu||T.minFilter===_o)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(R,n.TEXTURE_WRAP_S,re[T.wrapS]),n.texParameteri(R,n.TEXTURE_WRAP_T,re[T.wrapT]),(R===n.TEXTURE_3D||R===n.TEXTURE_2D_ARRAY)&&n.texParameteri(R,n.TEXTURE_WRAP_R,re[T.wrapR]),n.texParameteri(R,n.TEXTURE_MAG_FILTER,ue[T.magFilter]),n.texParameteri(R,n.TEXTURE_MIN_FILTER,ue[T.minFilter]),T.compareFunction&&(n.texParameteri(R,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(R,n.TEXTURE_COMPARE_FUNC,_e[T.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(T.magFilter===Pi||T.minFilter!==fu&&T.minFilter!==_o||T.type===Ir&&e.has("OES_texture_float_linear")===!1)return;if(T.anisotropy>1||i.get(T).__currentAnisotropy){const G=e.get("EXT_texture_filter_anisotropic");n.texParameterf(R,G.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(T.anisotropy,r.getMaxAnisotropy())),i.get(T).__currentAnisotropy=T.anisotropy}}}function ze(R,T){let G=!1;R.__webglInit===void 0&&(R.__webglInit=!0,T.addEventListener("dispose",w));const J=T.source;let de=d.get(J);de===void 0&&(de={},d.set(J,de));const N=X(T);if(N!==R.__cacheKey){de[N]===void 0&&(de[N]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,G=!0),de[N].usedTimes++;const P=de[R.__cacheKey];P!==void 0&&(de[R.__cacheKey].usedTimes--,P.usedTimes===0&&y(T)),R.__cacheKey=N,R.__webglTexture=de[N].texture}return G}function le(R,T,G){let J=n.TEXTURE_2D;(T.isDataArrayTexture||T.isCompressedArrayTexture)&&(J=n.TEXTURE_2D_ARRAY),T.isData3DTexture&&(J=n.TEXTURE_3D);const de=ze(R,T),N=T.source;t.bindTexture(J,R.__webglTexture,n.TEXTURE0+G);const P=i.get(N);if(N.version!==P.__version||de===!0){t.activeTexture(n.TEXTURE0+G);const $=Rt.getPrimaries(Rt.workingColorSpace),se=T.colorSpace===ps?null:Rt.getPrimaries(T.colorSpace),ve=T.colorSpace===ps||$===se?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,T.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,T.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,T.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,ve);let ie=g(T.image,!1,r.maxTextureSize);ie=I(T,ie);const Se=s.convert(T.format,T.colorSpace),be=s.convert(T.type);let Ie=E(T.internalFormat,Se,be,T.colorSpace,T.isVideoTexture);Be(J,T);let Fe;const Le=T.mipmaps,Ge=T.isVideoTexture!==!0,Ze=P.__version===void 0||de===!0,F=N.dataReady,ae=M(T,ie);if(T.isDepthTexture)Ie=x(T.format===Ic,T.type),Ze&&(Ge?t.texStorage2D(n.TEXTURE_2D,1,Ie,ie.width,ie.height):t.texImage2D(n.TEXTURE_2D,0,Ie,ie.width,ie.height,0,Se,be,null));else if(T.isDataTexture)if(Le.length>0){Ge&&Ze&&t.texStorage2D(n.TEXTURE_2D,ae,Ie,Le[0].width,Le[0].height);for(let ne=0,ce=Le.length;ne<ce;ne++)Fe=Le[ne],Ge?F&&t.texSubImage2D(n.TEXTURE_2D,ne,0,0,Fe.width,Fe.height,Se,be,Fe.data):t.texImage2D(n.TEXTURE_2D,ne,Ie,Fe.width,Fe.height,0,Se,be,Fe.data);T.generateMipmaps=!1}else Ge?(Ze&&t.texStorage2D(n.TEXTURE_2D,ae,Ie,ie.width,ie.height),F&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,ie.width,ie.height,Se,be,ie.data)):t.texImage2D(n.TEXTURE_2D,0,Ie,ie.width,ie.height,0,Se,be,ie.data);else if(T.isCompressedTexture)if(T.isCompressedArrayTexture){Ge&&Ze&&t.texStorage3D(n.TEXTURE_2D_ARRAY,ae,Ie,Le[0].width,Le[0].height,ie.depth);for(let ne=0,ce=Le.length;ne<ce;ne++)if(Fe=Le[ne],T.format!==Di)if(Se!==null)if(Ge){if(F)if(T.layerUpdates.size>0){const ge=B_(Fe.width,Fe.height,T.format,T.type);for(const xe of T.layerUpdates){const We=Fe.data.subarray(xe*ge/Fe.data.BYTES_PER_ELEMENT,(xe+1)*ge/Fe.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ne,0,0,xe,Fe.width,Fe.height,1,Se,We)}T.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ne,0,0,0,Fe.width,Fe.height,ie.depth,Se,Fe.data)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,ne,Ie,Fe.width,Fe.height,ie.depth,0,Fe.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Ge?F&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,ne,0,0,0,Fe.width,Fe.height,ie.depth,Se,be,Fe.data):t.texImage3D(n.TEXTURE_2D_ARRAY,ne,Ie,Fe.width,Fe.height,ie.depth,0,Se,be,Fe.data)}else{Ge&&Ze&&t.texStorage2D(n.TEXTURE_2D,ae,Ie,Le[0].width,Le[0].height);for(let ne=0,ce=Le.length;ne<ce;ne++)Fe=Le[ne],T.format!==Di?Se!==null?Ge?F&&t.compressedTexSubImage2D(n.TEXTURE_2D,ne,0,0,Fe.width,Fe.height,Se,Fe.data):t.compressedTexImage2D(n.TEXTURE_2D,ne,Ie,Fe.width,Fe.height,0,Fe.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ge?F&&t.texSubImage2D(n.TEXTURE_2D,ne,0,0,Fe.width,Fe.height,Se,be,Fe.data):t.texImage2D(n.TEXTURE_2D,ne,Ie,Fe.width,Fe.height,0,Se,be,Fe.data)}else if(T.isDataArrayTexture)if(Ge){if(Ze&&t.texStorage3D(n.TEXTURE_2D_ARRAY,ae,Ie,ie.width,ie.height,ie.depth),F)if(T.layerUpdates.size>0){const ne=B_(ie.width,ie.height,T.format,T.type);for(const ce of T.layerUpdates){const ge=ie.data.subarray(ce*ne/ie.data.BYTES_PER_ELEMENT,(ce+1)*ne/ie.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,ce,ie.width,ie.height,1,Se,be,ge)}T.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,ie.width,ie.height,ie.depth,Se,be,ie.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,Ie,ie.width,ie.height,ie.depth,0,Se,be,ie.data);else if(T.isData3DTexture)Ge?(Ze&&t.texStorage3D(n.TEXTURE_3D,ae,Ie,ie.width,ie.height,ie.depth),F&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,ie.width,ie.height,ie.depth,Se,be,ie.data)):t.texImage3D(n.TEXTURE_3D,0,Ie,ie.width,ie.height,ie.depth,0,Se,be,ie.data);else if(T.isFramebufferTexture){if(Ze)if(Ge)t.texStorage2D(n.TEXTURE_2D,ae,Ie,ie.width,ie.height);else{let ne=ie.width,ce=ie.height;for(let ge=0;ge<ae;ge++)t.texImage2D(n.TEXTURE_2D,ge,Ie,ne,ce,0,Se,be,null),ne>>=1,ce>>=1}}else if(Le.length>0){if(Ge&&Ze){const ne=U(Le[0]);t.texStorage2D(n.TEXTURE_2D,ae,Ie,ne.width,ne.height)}for(let ne=0,ce=Le.length;ne<ce;ne++)Fe=Le[ne],Ge?F&&t.texSubImage2D(n.TEXTURE_2D,ne,0,0,Se,be,Fe):t.texImage2D(n.TEXTURE_2D,ne,Ie,Se,be,Fe);T.generateMipmaps=!1}else if(Ge){if(Ze){const ne=U(ie);t.texStorage2D(n.TEXTURE_2D,ae,Ie,ne.width,ne.height)}F&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,Se,be,ie)}else t.texImage2D(n.TEXTURE_2D,0,Ie,Se,be,ie);m(T)&&p(J),P.__version=N.version,T.onUpdate&&T.onUpdate(T)}R.__version=T.version}function Ee(R,T,G){if(T.image.length!==6)return;const J=ze(R,T),de=T.source;t.bindTexture(n.TEXTURE_CUBE_MAP,R.__webglTexture,n.TEXTURE0+G);const N=i.get(de);if(de.version!==N.__version||J===!0){t.activeTexture(n.TEXTURE0+G);const P=Rt.getPrimaries(Rt.workingColorSpace),$=T.colorSpace===ps?null:Rt.getPrimaries(T.colorSpace),se=T.colorSpace===ps||P===$?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,T.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,T.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,T.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,se);const ve=T.isCompressedTexture||T.image[0].isCompressedTexture,ie=T.image[0]&&T.image[0].isDataTexture,Se=[];for(let ce=0;ce<6;ce++)!ve&&!ie?Se[ce]=g(T.image[ce],!0,r.maxCubemapSize):Se[ce]=ie?T.image[ce].image:T.image[ce],Se[ce]=I(T,Se[ce]);const be=Se[0],Ie=s.convert(T.format,T.colorSpace),Fe=s.convert(T.type),Le=E(T.internalFormat,Ie,Fe,T.colorSpace),Ge=T.isVideoTexture!==!0,Ze=N.__version===void 0||J===!0,F=de.dataReady;let ae=M(T,be);Be(n.TEXTURE_CUBE_MAP,T);let ne;if(ve){Ge&&Ze&&t.texStorage2D(n.TEXTURE_CUBE_MAP,ae,Le,be.width,be.height);for(let ce=0;ce<6;ce++){ne=Se[ce].mipmaps;for(let ge=0;ge<ne.length;ge++){const xe=ne[ge];T.format!==Di?Ie!==null?Ge?F&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge,0,0,xe.width,xe.height,Ie,xe.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge,Le,xe.width,xe.height,0,xe.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ge?F&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge,0,0,xe.width,xe.height,Ie,Fe,xe.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge,Le,xe.width,xe.height,0,Ie,Fe,xe.data)}}}else{if(ne=T.mipmaps,Ge&&Ze){ne.length>0&&ae++;const ce=U(Se[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,ae,Le,ce.width,ce.height)}for(let ce=0;ce<6;ce++)if(ie){Ge?F&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,0,0,0,Se[ce].width,Se[ce].height,Ie,Fe,Se[ce].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,0,Le,Se[ce].width,Se[ce].height,0,Ie,Fe,Se[ce].data);for(let ge=0;ge<ne.length;ge++){const We=ne[ge].image[ce].image;Ge?F&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge+1,0,0,We.width,We.height,Ie,Fe,We.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge+1,Le,We.width,We.height,0,Ie,Fe,We.data)}}else{Ge?F&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,0,0,0,Ie,Fe,Se[ce]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,0,Le,Ie,Fe,Se[ce]);for(let ge=0;ge<ne.length;ge++){const xe=ne[ge];Ge?F&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge+1,0,0,Ie,Fe,xe.image[ce]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ce,ge+1,Le,Ie,Fe,xe.image[ce])}}}m(T)&&p(n.TEXTURE_CUBE_MAP),N.__version=de.version,T.onUpdate&&T.onUpdate(T)}R.__version=T.version}function Ue(R,T,G,J,de,N){const P=s.convert(G.format,G.colorSpace),$=s.convert(G.type),se=E(G.internalFormat,P,$,G.colorSpace),ve=i.get(T),ie=i.get(G);if(ie.__renderTarget=T,!ve.__hasExternalTextures){const Se=Math.max(1,T.width>>N),be=Math.max(1,T.height>>N);de===n.TEXTURE_3D||de===n.TEXTURE_2D_ARRAY?t.texImage3D(de,N,se,Se,be,T.depth,0,P,$,null):t.texImage2D(de,N,se,Se,be,0,P,$,null)}t.bindFramebuffer(n.FRAMEBUFFER,R),Re(T)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,J,de,ie.__webglTexture,0,Te(T)):(de===n.TEXTURE_2D||de>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&de<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,J,de,ie.__webglTexture,N),t.bindFramebuffer(n.FRAMEBUFFER,null)}function pe(R,T,G){if(n.bindRenderbuffer(n.RENDERBUFFER,R),T.depthBuffer){const J=T.depthTexture,de=J&&J.isDepthTexture?J.type:null,N=x(T.stencilBuffer,de),P=T.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,$=Te(T);Re(T)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,$,N,T.width,T.height):G?n.renderbufferStorageMultisample(n.RENDERBUFFER,$,N,T.width,T.height):n.renderbufferStorage(n.RENDERBUFFER,N,T.width,T.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,P,n.RENDERBUFFER,R)}else{const J=T.textures;for(let de=0;de<J.length;de++){const N=J[de],P=s.convert(N.format,N.colorSpace),$=s.convert(N.type),se=E(N.internalFormat,P,$,N.colorSpace),ve=Te(T);G&&Re(T)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,ve,se,T.width,T.height):Re(T)?a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ve,se,T.width,T.height):n.renderbufferStorage(n.RENDERBUFFER,se,T.width,T.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function oe(R,T){if(T&&T.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,R),!(T.depthTexture&&T.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const J=i.get(T.depthTexture);J.__renderTarget=T,(!J.__webglTexture||T.depthTexture.image.width!==T.width||T.depthTexture.image.height!==T.height)&&(T.depthTexture.image.width=T.width,T.depthTexture.image.height=T.height,T.depthTexture.needsUpdate=!0),te(T.depthTexture,0);const de=J.__webglTexture,N=Te(T);if(T.depthTexture.format===Tc)Re(T)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,de,0,N):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,de,0);else if(T.depthTexture.format===Ic)Re(T)?a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,de,0,N):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,de,0);else throw new Error("Unknown depthTexture format")}function we(R){const T=i.get(R),G=R.isWebGLCubeRenderTarget===!0;if(T.__boundDepthTexture!==R.depthTexture){const J=R.depthTexture;if(T.__depthDisposeCallback&&T.__depthDisposeCallback(),J){const de=()=>{delete T.__boundDepthTexture,delete T.__depthDisposeCallback,J.removeEventListener("dispose",de)};J.addEventListener("dispose",de),T.__depthDisposeCallback=de}T.__boundDepthTexture=J}if(R.depthTexture&&!T.__autoAllocateDepthBuffer){if(G)throw new Error("target.depthTexture not supported in Cube render targets");oe(T.__webglFramebuffer,R)}else if(G){T.__webglDepthbuffer=[];for(let J=0;J<6;J++)if(t.bindFramebuffer(n.FRAMEBUFFER,T.__webglFramebuffer[J]),T.__webglDepthbuffer[J]===void 0)T.__webglDepthbuffer[J]=n.createRenderbuffer(),pe(T.__webglDepthbuffer[J],R,!1);else{const de=R.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,N=T.__webglDepthbuffer[J];n.bindRenderbuffer(n.RENDERBUFFER,N),n.framebufferRenderbuffer(n.FRAMEBUFFER,de,n.RENDERBUFFER,N)}}else if(t.bindFramebuffer(n.FRAMEBUFFER,T.__webglFramebuffer),T.__webglDepthbuffer===void 0)T.__webglDepthbuffer=n.createRenderbuffer(),pe(T.__webglDepthbuffer,R,!1);else{const J=R.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,de=T.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,de),n.framebufferRenderbuffer(n.FRAMEBUFFER,J,n.RENDERBUFFER,de)}t.bindFramebuffer(n.FRAMEBUFFER,null)}function Me(R,T,G){const J=i.get(R);T!==void 0&&Ue(J.__webglFramebuffer,R,R.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),G!==void 0&&we(R)}function Ve(R){const T=R.texture,G=i.get(R),J=i.get(T);R.addEventListener("dispose",S);const de=R.textures,N=R.isWebGLCubeRenderTarget===!0,P=de.length>1;if(P||(J.__webglTexture===void 0&&(J.__webglTexture=n.createTexture()),J.__version=T.version,o.memory.textures++),N){G.__webglFramebuffer=[];for(let $=0;$<6;$++)if(T.mipmaps&&T.mipmaps.length>0){G.__webglFramebuffer[$]=[];for(let se=0;se<T.mipmaps.length;se++)G.__webglFramebuffer[$][se]=n.createFramebuffer()}else G.__webglFramebuffer[$]=n.createFramebuffer()}else{if(T.mipmaps&&T.mipmaps.length>0){G.__webglFramebuffer=[];for(let $=0;$<T.mipmaps.length;$++)G.__webglFramebuffer[$]=n.createFramebuffer()}else G.__webglFramebuffer=n.createFramebuffer();if(P)for(let $=0,se=de.length;$<se;$++){const ve=i.get(de[$]);ve.__webglTexture===void 0&&(ve.__webglTexture=n.createTexture(),o.memory.textures++)}if(R.samples>0&&Re(R)===!1){G.__webglMultisampledFramebuffer=n.createFramebuffer(),G.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,G.__webglMultisampledFramebuffer);for(let $=0;$<de.length;$++){const se=de[$];G.__webglColorRenderbuffer[$]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,G.__webglColorRenderbuffer[$]);const ve=s.convert(se.format,se.colorSpace),ie=s.convert(se.type),Se=E(se.internalFormat,ve,ie,se.colorSpace,R.isXRRenderTarget===!0),be=Te(R);n.renderbufferStorageMultisample(n.RENDERBUFFER,be,Se,R.width,R.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+$,n.RENDERBUFFER,G.__webglColorRenderbuffer[$])}n.bindRenderbuffer(n.RENDERBUFFER,null),R.depthBuffer&&(G.__webglDepthRenderbuffer=n.createRenderbuffer(),pe(G.__webglDepthRenderbuffer,R,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(N){t.bindTexture(n.TEXTURE_CUBE_MAP,J.__webglTexture),Be(n.TEXTURE_CUBE_MAP,T);for(let $=0;$<6;$++)if(T.mipmaps&&T.mipmaps.length>0)for(let se=0;se<T.mipmaps.length;se++)Ue(G.__webglFramebuffer[$][se],R,T,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+$,se);else Ue(G.__webglFramebuffer[$],R,T,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+$,0);m(T)&&p(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(P){for(let $=0,se=de.length;$<se;$++){const ve=de[$],ie=i.get(ve);t.bindTexture(n.TEXTURE_2D,ie.__webglTexture),Be(n.TEXTURE_2D,ve),Ue(G.__webglFramebuffer,R,ve,n.COLOR_ATTACHMENT0+$,n.TEXTURE_2D,0),m(ve)&&p(n.TEXTURE_2D)}t.unbindTexture()}else{let $=n.TEXTURE_2D;if((R.isWebGL3DRenderTarget||R.isWebGLArrayRenderTarget)&&($=R.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture($,J.__webglTexture),Be($,T),T.mipmaps&&T.mipmaps.length>0)for(let se=0;se<T.mipmaps.length;se++)Ue(G.__webglFramebuffer[se],R,T,n.COLOR_ATTACHMENT0,$,se);else Ue(G.__webglFramebuffer,R,T,n.COLOR_ATTACHMENT0,$,0);m(T)&&p($),t.unbindTexture()}R.depthBuffer&&we(R)}function me(R){const T=R.textures;for(let G=0,J=T.length;G<J;G++){const de=T[G];if(m(de)){const N=v(R),P=i.get(de).__webglTexture;t.bindTexture(N,P),p(N),t.unbindTexture()}}}const Ae=[],V=[];function j(R){if(R.samples>0){if(Re(R)===!1){const T=R.textures,G=R.width,J=R.height;let de=n.COLOR_BUFFER_BIT;const N=R.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,P=i.get(R),$=T.length>1;if($)for(let se=0;se<T.length;se++)t.bindFramebuffer(n.FRAMEBUFFER,P.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+se,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,P.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+se,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,P.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,P.__webglFramebuffer);for(let se=0;se<T.length;se++){if(R.resolveDepthBuffer&&(R.depthBuffer&&(de|=n.DEPTH_BUFFER_BIT),R.stencilBuffer&&R.resolveStencilBuffer&&(de|=n.STENCIL_BUFFER_BIT)),$){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,P.__webglColorRenderbuffer[se]);const ve=i.get(T[se]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,ve,0)}n.blitFramebuffer(0,0,G,J,0,0,G,J,de,n.NEAREST),l===!0&&(Ae.length=0,V.length=0,Ae.push(n.COLOR_ATTACHMENT0+se),R.depthBuffer&&R.resolveDepthBuffer===!1&&(Ae.push(N),V.push(N),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,V)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,Ae))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),$)for(let se=0;se<T.length;se++){t.bindFramebuffer(n.FRAMEBUFFER,P.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+se,n.RENDERBUFFER,P.__webglColorRenderbuffer[se]);const ve=i.get(T[se]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,P.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+se,n.TEXTURE_2D,ve,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,P.__webglMultisampledFramebuffer)}else if(R.depthBuffer&&R.resolveDepthBuffer===!1&&l){const T=R.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[T])}}}function Te(R){return Math.min(r.maxSamples,R.samples)}function Re(R){const T=i.get(R);return R.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&T.__useRenderToTexture!==!1}function b(R){const T=o.render.frame;h.get(R)!==T&&(h.set(R,T),R.update())}function I(R,T){const G=R.colorSpace,J=R.format,de=R.type;return R.isCompressedTexture===!0||R.isVideoTexture===!0||G!==el&&G!==ps&&(Rt.getTransfer(G)===Ot?(J!==Di||de!==Hr)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",G)),T}function U(R){return typeof HTMLImageElement<"u"&&R instanceof HTMLImageElement?(c.width=R.naturalWidth||R.width,c.height=R.naturalHeight||R.height):typeof VideoFrame<"u"&&R instanceof VideoFrame?(c.width=R.displayWidth,c.height=R.displayHeight):(c.width=R.width,c.height=R.height),c}this.allocateTextureUnit=O,this.resetTextureUnits=Q,this.setTexture2D=te,this.setTexture2DArray=W,this.setTexture3D=Z,this.setTextureCube=q,this.rebindTextures=Me,this.setupRenderTarget=Ve,this.updateRenderTargetMipmap=me,this.updateMultisampleRenderTarget=j,this.setupDepthRenderbuffer=we,this.setupFrameBufferTexture=Ue,this.useMultisampledRTT=Re}function bH(n,e){function t(i,r=ps){let s;const o=Rt.getTransfer(r);if(i===Hr)return n.UNSIGNED_BYTE;if(i===fv)return n.UNSIGNED_SHORT_4_4_4_4;if(i===pv)return n.UNSIGNED_SHORT_5_5_5_1;if(i===GS)return n.UNSIGNED_INT_5_9_9_9_REV;if(i===OS)return n.BYTE;if(i===kS)return n.SHORT;if(i===Sc)return n.UNSIGNED_SHORT;if(i===dv)return n.INT;if(i===Lo)return n.UNSIGNED_INT;if(i===Ir)return n.FLOAT;if(i===Qc)return n.HALF_FLOAT;if(i===zS)return n.ALPHA;if(i===HS)return n.RGB;if(i===Di)return n.RGBA;if(i===VS)return n.LUMINANCE;if(i===QS)return n.LUMINANCE_ALPHA;if(i===Tc)return n.DEPTH_COMPONENT;if(i===Ic)return n.DEPTH_STENCIL;if(i===WS)return n.RED;if(i===mv)return n.RED_INTEGER;if(i===XS)return n.RG;if(i===Av)return n.RG_INTEGER;if(i===gv)return n.RGBA_INTEGER;if(i===qu||i===Yu||i===ju||i===$u)if(o===Ot)if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(i===qu)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===Yu)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===ju)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===$u)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=e.get("WEBGL_compressed_texture_s3tc"),s!==null){if(i===qu)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===Yu)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===ju)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===$u)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===gg||i===vg||i===Eg||i===xg)if(s=e.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(i===gg)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===vg)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===Eg)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===xg)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===yg||i===_g||i===bg)if(s=e.get("WEBGL_compressed_texture_etc"),s!==null){if(i===yg||i===_g)return o===Ot?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(i===bg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===Cg||i===Mg||i===Sg||i===wg||i===Tg||i===Ig||i===Rg||i===Bg||i===Lg||i===Dg||i===Pg||i===Ug||i===Fg||i===Ng)if(s=e.get("WEBGL_compressed_texture_astc"),s!==null){if(i===Cg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===Mg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===Sg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===wg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===Tg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===Ig)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===Rg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===Bg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===Lg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===Dg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===Pg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===Ug)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===Fg)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===Ng)return o===Ot?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===Ku||i===Og||i===kg)if(s=e.get("EXT_texture_compression_bptc"),s!==null){if(i===Ku)return o===Ot?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===Og)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===kg)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(i===qS||i===Gg||i===zg||i===Hg)if(s=e.get("EXT_texture_compression_rgtc"),s!==null){if(i===Ku)return s.COMPRESSED_RED_RGTC1_EXT;if(i===Gg)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===zg)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===Hg)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return i===wc?n.UNSIGNED_INT_24_8:n[i]!==void 0?n[i]:null}return{convert:t}}const CH=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,MH=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class SH{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,i){if(this.texture===null){const r=new zn,s=e.properties.get(r);s.__webglTexture=t.texture,(t.depthNear!==i.depthNear||t.depthFar!==i.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=r}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,i=new Ts({vertexShader:CH,fragmentShader:MH,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new Br(new jf(20,20),i)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class wH extends Fo{constructor(e,t){super();const i=this;let r=null,s=1,o=null,a="local-floor",l=1,c=null,h=null,u=null,d=null,f=null,A=null;const g=new SH,m=t.getContextAttributes();let p=null,v=null;const E=[],x=[],M=new zt;let w=null;const S=new Ri;S.viewport=new jt;const B=new Ri;B.viewport=new jt;const y=[S,B],_=new qN;let L=null,Q=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(le){let Ee=E[le];return Ee===void 0&&(Ee=new rA,E[le]=Ee),Ee.getTargetRaySpace()},this.getControllerGrip=function(le){let Ee=E[le];return Ee===void 0&&(Ee=new rA,E[le]=Ee),Ee.getGripSpace()},this.getHand=function(le){let Ee=E[le];return Ee===void 0&&(Ee=new rA,E[le]=Ee),Ee.getHandSpace()};function O(le){const Ee=x.indexOf(le.inputSource);if(Ee===-1)return;const Ue=E[Ee];Ue!==void 0&&(Ue.update(le.inputSource,le.frame,c||o),Ue.dispatchEvent({type:le.type,data:le.inputSource}))}function X(){r.removeEventListener("select",O),r.removeEventListener("selectstart",O),r.removeEventListener("selectend",O),r.removeEventListener("squeeze",O),r.removeEventListener("squeezestart",O),r.removeEventListener("squeezeend",O),r.removeEventListener("end",X),r.removeEventListener("inputsourceschange",te);for(let le=0;le<E.length;le++){const Ee=x[le];Ee!==null&&(x[le]=null,E[le].disconnect(Ee))}L=null,Q=null,g.reset(),e.setRenderTarget(p),f=null,d=null,u=null,r=null,v=null,ze.stop(),i.isPresenting=!1,e.setPixelRatio(w),e.setSize(M.width,M.height,!1),i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(le){s=le,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(le){a=le,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(le){c=le},this.getBaseLayer=function(){return d!==null?d:f},this.getBinding=function(){return u},this.getFrame=function(){return A},this.getSession=function(){return r},this.setSession=async function(le){if(r=le,r!==null){if(p=e.getRenderTarget(),r.addEventListener("select",O),r.addEventListener("selectstart",O),r.addEventListener("selectend",O),r.addEventListener("squeeze",O),r.addEventListener("squeezestart",O),r.addEventListener("squeezeend",O),r.addEventListener("end",X),r.addEventListener("inputsourceschange",te),m.xrCompatible!==!0&&await t.makeXRCompatible(),w=e.getPixelRatio(),e.getSize(M),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let Ue=null,pe=null,oe=null;m.depth&&(oe=m.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Ue=m.stencil?Ic:Tc,pe=m.stencil?wc:Lo);const we={colorFormat:t.RGBA8,depthFormat:oe,scaleFactor:s};u=new XRWebGLBinding(r,t),d=u.createProjectionLayer(we),r.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),v=new Do(d.textureWidth,d.textureHeight,{format:Di,type:Hr,depthTexture:new ow(d.textureWidth,d.textureHeight,pe,void 0,void 0,void 0,void 0,void 0,void 0,Ue),stencilBuffer:m.stencil,colorSpace:e.outputColorSpace,samples:m.antialias?4:0,resolveDepthBuffer:d.ignoreDepthValues===!1,resolveStencilBuffer:d.ignoreDepthValues===!1})}else{const Ue={antialias:m.antialias,alpha:!0,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:s};f=new XRWebGLLayer(r,t,Ue),r.updateRenderState({baseLayer:f}),e.setPixelRatio(1),e.setSize(f.framebufferWidth,f.framebufferHeight,!1),v=new Do(f.framebufferWidth,f.framebufferHeight,{format:Di,type:Hr,colorSpace:e.outputColorSpace,stencilBuffer:m.stencil,resolveDepthBuffer:f.ignoreDepthValues===!1,resolveStencilBuffer:f.ignoreDepthValues===!1})}v.isXRRenderTarget=!0,this.setFoveation(l),c=null,o=await r.requestReferenceSpace(a),ze.setContext(r),ze.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(r!==null)return r.environmentBlendMode},this.getDepthTexture=function(){return g.getDepthTexture()};function te(le){for(let Ee=0;Ee<le.removed.length;Ee++){const Ue=le.removed[Ee],pe=x.indexOf(Ue);pe>=0&&(x[pe]=null,E[pe].disconnect(Ue))}for(let Ee=0;Ee<le.added.length;Ee++){const Ue=le.added[Ee];let pe=x.indexOf(Ue);if(pe===-1){for(let we=0;we<E.length;we++)if(we>=x.length){x.push(Ue),pe=we;break}else if(x[we]===null){x[we]=Ue,pe=we;break}if(pe===-1)break}const oe=E[pe];oe&&oe.connect(Ue)}}const W=new ye,Z=new ye;function q(le,Ee,Ue){W.setFromMatrixPosition(Ee.matrixWorld),Z.setFromMatrixPosition(Ue.matrixWorld);const pe=W.distanceTo(Z),oe=Ee.projectionMatrix.elements,we=Ue.projectionMatrix.elements,Me=oe[14]/(oe[10]-1),Ve=oe[14]/(oe[10]+1),me=(oe[9]+1)/oe[5],Ae=(oe[9]-1)/oe[5],V=(oe[8]-1)/oe[0],j=(we[8]+1)/we[0],Te=Me*V,Re=Me*j,b=pe/(-V+j),I=b*-V;if(Ee.matrixWorld.decompose(le.position,le.quaternion,le.scale),le.translateX(I),le.translateZ(b),le.matrixWorld.compose(le.position,le.quaternion,le.scale),le.matrixWorldInverse.copy(le.matrixWorld).invert(),oe[10]===-1)le.projectionMatrix.copy(Ee.projectionMatrix),le.projectionMatrixInverse.copy(Ee.projectionMatrixInverse);else{const U=Me+b,R=Ve+b,T=Te-I,G=Re+(pe-I),J=me*Ve/R*U,de=Ae*Ve/R*U;le.projectionMatrix.makePerspective(T,G,J,de,U,R),le.projectionMatrixInverse.copy(le.projectionMatrix).invert()}}function re(le,Ee){Ee===null?le.matrixWorld.copy(le.matrix):le.matrixWorld.multiplyMatrices(Ee.matrixWorld,le.matrix),le.matrixWorldInverse.copy(le.matrixWorld).invert()}this.updateCamera=function(le){if(r===null)return;let Ee=le.near,Ue=le.far;g.texture!==null&&(g.depthNear>0&&(Ee=g.depthNear),g.depthFar>0&&(Ue=g.depthFar)),_.near=B.near=S.near=Ee,_.far=B.far=S.far=Ue,(L!==_.near||Q!==_.far)&&(r.updateRenderState({depthNear:_.near,depthFar:_.far}),L=_.near,Q=_.far),S.layers.mask=le.layers.mask|2,B.layers.mask=le.layers.mask|4,_.layers.mask=S.layers.mask|B.layers.mask;const pe=le.parent,oe=_.cameras;re(_,pe);for(let we=0;we<oe.length;we++)re(oe[we],pe);oe.length===2?q(_,S,B):_.projectionMatrix.copy(S.projectionMatrix),ue(le,_,pe)};function ue(le,Ee,Ue){Ue===null?le.matrix.copy(Ee.matrixWorld):(le.matrix.copy(Ue.matrixWorld),le.matrix.invert(),le.matrix.multiply(Ee.matrixWorld)),le.matrix.decompose(le.position,le.quaternion,le.scale),le.updateMatrixWorld(!0),le.projectionMatrix.copy(Ee.projectionMatrix),le.projectionMatrixInverse.copy(Ee.projectionMatrixInverse),le.isPerspectiveCamera&&(le.fov=Rc*2*Math.atan(1/le.projectionMatrix.elements[5]),le.zoom=1)}this.getCamera=function(){return _},this.getFoveation=function(){if(!(d===null&&f===null))return l},this.setFoveation=function(le){l=le,d!==null&&(d.fixedFoveation=le),f!==null&&f.fixedFoveation!==void 0&&(f.fixedFoveation=le)},this.hasDepthSensing=function(){return g.texture!==null},this.getDepthSensingMesh=function(){return g.getMesh(_)};let _e=null;function Be(le,Ee){if(h=Ee.getViewerPose(c||o),A=Ee,h!==null){const Ue=h.views;f!==null&&(e.setRenderTargetFramebuffer(v,f.framebuffer),e.setRenderTarget(v));let pe=!1;Ue.length!==_.cameras.length&&(_.cameras.length=0,pe=!0);for(let Me=0;Me<Ue.length;Me++){const Ve=Ue[Me];let me=null;if(f!==null)me=f.getViewport(Ve);else{const V=u.getViewSubImage(d,Ve);me=V.viewport,Me===0&&(e.setRenderTargetTextures(v,V.colorTexture,V.depthStencilTexture),e.setRenderTarget(v))}let Ae=y[Me];Ae===void 0&&(Ae=new Ri,Ae.layers.enable(Me),Ae.viewport=new jt,y[Me]=Ae),Ae.matrix.fromArray(Ve.transform.matrix),Ae.matrix.decompose(Ae.position,Ae.quaternion,Ae.scale),Ae.projectionMatrix.fromArray(Ve.projectionMatrix),Ae.projectionMatrixInverse.copy(Ae.projectionMatrix).invert(),Ae.viewport.set(me.x,me.y,me.width,me.height),Me===0&&(_.matrix.copy(Ae.matrix),_.matrix.decompose(_.position,_.quaternion,_.scale)),pe===!0&&_.cameras.push(Ae)}const oe=r.enabledFeatures;if(oe&&oe.includes("depth-sensing")&&r.depthUsage=="gpu-optimized"&&u){const Me=u.getDepthInformation(Ue[0]);Me&&Me.isValid&&Me.texture&&g.init(e,Me,r.renderState)}}for(let Ue=0;Ue<E.length;Ue++){const pe=x[Ue],oe=E[Ue];pe!==null&&oe!==void 0&&oe.update(pe,Ee,c||o)}_e&&_e(le,Ee),Ee.detectedPlanes&&i.dispatchEvent({type:"planesdetected",data:Ee}),A=null}const ze=new aw;ze.setAnimationLoop(Be),this.setAnimationLoop=function(le){_e=le},this.dispose=function(){}}}const ao=new Oi,TH=new $t;function IH(n,e){function t(m,p){m.matrixAutoUpdate===!0&&m.updateMatrix(),p.value.copy(m.matrix)}function i(m,p){p.color.getRGB(m.fogColor.value,nw(n)),p.isFog?(m.fogNear.value=p.near,m.fogFar.value=p.far):p.isFogExp2&&(m.fogDensity.value=p.density)}function r(m,p,v,E,x){p.isMeshBasicMaterial||p.isMeshLambertMaterial?s(m,p):p.isMeshToonMaterial?(s(m,p),u(m,p)):p.isMeshPhongMaterial?(s(m,p),h(m,p)):p.isMeshStandardMaterial?(s(m,p),d(m,p),p.isMeshPhysicalMaterial&&f(m,p,x)):p.isMeshMatcapMaterial?(s(m,p),A(m,p)):p.isMeshDepthMaterial?s(m,p):p.isMeshDistanceMaterial?(s(m,p),g(m,p)):p.isMeshNormalMaterial?s(m,p):p.isLineBasicMaterial?(o(m,p),p.isLineDashedMaterial&&a(m,p)):p.isPointsMaterial?l(m,p,v,E):p.isSpriteMaterial?c(m,p):p.isShadowMaterial?(m.color.value.copy(p.color),m.opacity.value=p.opacity):p.isShaderMaterial&&(p.uniformsNeedUpdate=!1)}function s(m,p){m.opacity.value=p.opacity,p.color&&m.diffuse.value.copy(p.color),p.emissive&&m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),p.map&&(m.map.value=p.map,t(p.map,m.mapTransform)),p.alphaMap&&(m.alphaMap.value=p.alphaMap,t(p.alphaMap,m.alphaMapTransform)),p.bumpMap&&(m.bumpMap.value=p.bumpMap,t(p.bumpMap,m.bumpMapTransform),m.bumpScale.value=p.bumpScale,p.side===jn&&(m.bumpScale.value*=-1)),p.normalMap&&(m.normalMap.value=p.normalMap,t(p.normalMap,m.normalMapTransform),m.normalScale.value.copy(p.normalScale),p.side===jn&&m.normalScale.value.negate()),p.displacementMap&&(m.displacementMap.value=p.displacementMap,t(p.displacementMap,m.displacementMapTransform),m.displacementScale.value=p.displacementScale,m.displacementBias.value=p.displacementBias),p.emissiveMap&&(m.emissiveMap.value=p.emissiveMap,t(p.emissiveMap,m.emissiveMapTransform)),p.specularMap&&(m.specularMap.value=p.specularMap,t(p.specularMap,m.specularMapTransform)),p.alphaTest>0&&(m.alphaTest.value=p.alphaTest);const v=e.get(p),E=v.envMap,x=v.envMapRotation;E&&(m.envMap.value=E,ao.copy(x),ao.x*=-1,ao.y*=-1,ao.z*=-1,E.isCubeTexture&&E.isRenderTargetTexture===!1&&(ao.y*=-1,ao.z*=-1),m.envMapRotation.value.setFromMatrix4(TH.makeRotationFromEuler(ao)),m.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=p.reflectivity,m.ior.value=p.ior,m.refractionRatio.value=p.refractionRatio),p.lightMap&&(m.lightMap.value=p.lightMap,m.lightMapIntensity.value=p.lightMapIntensity,t(p.lightMap,m.lightMapTransform)),p.aoMap&&(m.aoMap.value=p.aoMap,m.aoMapIntensity.value=p.aoMapIntensity,t(p.aoMap,m.aoMapTransform))}function o(m,p){m.diffuse.value.copy(p.color),m.opacity.value=p.opacity,p.map&&(m.map.value=p.map,t(p.map,m.mapTransform))}function a(m,p){m.dashSize.value=p.dashSize,m.totalSize.value=p.dashSize+p.gapSize,m.scale.value=p.scale}function l(m,p,v,E){m.diffuse.value.copy(p.color),m.opacity.value=p.opacity,m.size.value=p.size*v,m.scale.value=E*.5,p.map&&(m.map.value=p.map,t(p.map,m.uvTransform)),p.alphaMap&&(m.alphaMap.value=p.alphaMap,t(p.alphaMap,m.alphaMapTransform)),p.alphaTest>0&&(m.alphaTest.value=p.alphaTest)}function c(m,p){m.diffuse.value.copy(p.color),m.opacity.value=p.opacity,m.rotation.value=p.rotation,p.map&&(m.map.value=p.map,t(p.map,m.mapTransform)),p.alphaMap&&(m.alphaMap.value=p.alphaMap,t(p.alphaMap,m.alphaMapTransform)),p.alphaTest>0&&(m.alphaTest.value=p.alphaTest)}function h(m,p){m.specular.value.copy(p.specular),m.shininess.value=Math.max(p.shininess,1e-4)}function u(m,p){p.gradientMap&&(m.gradientMap.value=p.gradientMap)}function d(m,p){m.metalness.value=p.metalness,p.metalnessMap&&(m.metalnessMap.value=p.metalnessMap,t(p.metalnessMap,m.metalnessMapTransform)),m.roughness.value=p.roughness,p.roughnessMap&&(m.roughnessMap.value=p.roughnessMap,t(p.roughnessMap,m.roughnessMapTransform)),p.envMap&&(m.envMapIntensity.value=p.envMapIntensity)}function f(m,p,v){m.ior.value=p.ior,p.sheen>0&&(m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),m.sheenRoughness.value=p.sheenRoughness,p.sheenColorMap&&(m.sheenColorMap.value=p.sheenColorMap,t(p.sheenColorMap,m.sheenColorMapTransform)),p.sheenRoughnessMap&&(m.sheenRoughnessMap.value=p.sheenRoughnessMap,t(p.sheenRoughnessMap,m.sheenRoughnessMapTransform))),p.clearcoat>0&&(m.clearcoat.value=p.clearcoat,m.clearcoatRoughness.value=p.clearcoatRoughness,p.clearcoatMap&&(m.clearcoatMap.value=p.clearcoatMap,t(p.clearcoatMap,m.clearcoatMapTransform)),p.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=p.clearcoatRoughnessMap,t(p.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),p.clearcoatNormalMap&&(m.clearcoatNormalMap.value=p.clearcoatNormalMap,t(p.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),p.side===jn&&m.clearcoatNormalScale.value.negate())),p.dispersion>0&&(m.dispersion.value=p.dispersion),p.iridescence>0&&(m.iridescence.value=p.iridescence,m.iridescenceIOR.value=p.iridescenceIOR,m.iridescenceThicknessMinimum.value=p.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=p.iridescenceThicknessRange[1],p.iridescenceMap&&(m.iridescenceMap.value=p.iridescenceMap,t(p.iridescenceMap,m.iridescenceMapTransform)),p.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=p.iridescenceThicknessMap,t(p.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),p.transmission>0&&(m.transmission.value=p.transmission,m.transmissionSamplerMap.value=v.texture,m.transmissionSamplerSize.value.set(v.width,v.height),p.transmissionMap&&(m.transmissionMap.value=p.transmissionMap,t(p.transmissionMap,m.transmissionMapTransform)),m.thickness.value=p.thickness,p.thicknessMap&&(m.thicknessMap.value=p.thicknessMap,t(p.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=p.attenuationDistance,m.attenuationColor.value.copy(p.attenuationColor)),p.anisotropy>0&&(m.anisotropyVector.value.set(p.anisotropy*Math.cos(p.anisotropyRotation),p.anisotropy*Math.sin(p.anisotropyRotation)),p.anisotropyMap&&(m.anisotropyMap.value=p.anisotropyMap,t(p.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=p.specularIntensity,m.specularColor.value.copy(p.specularColor),p.specularColorMap&&(m.specularColorMap.value=p.specularColorMap,t(p.specularColorMap,m.specularColorMapTransform)),p.specularIntensityMap&&(m.specularIntensityMap.value=p.specularIntensityMap,t(p.specularIntensityMap,m.specularIntensityMapTransform))}function A(m,p){p.matcap&&(m.matcap.value=p.matcap)}function g(m,p){const v=e.get(p).light;m.referencePosition.value.setFromMatrixPosition(v.matrixWorld),m.nearDistance.value=v.shadow.camera.near,m.farDistance.value=v.shadow.camera.far}return{refreshFogUniforms:i,refreshMaterialUniforms:r}}function RH(n,e,t,i){let r={},s={},o=[];const a=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function l(v,E){const x=E.program;i.uniformBlockBinding(v,x)}function c(v,E){let x=r[v.id];x===void 0&&(A(v),x=h(v),r[v.id]=x,v.addEventListener("dispose",m));const M=E.program;i.updateUBOMapping(v,M);const w=e.render.frame;s[v.id]!==w&&(d(v),s[v.id]=w)}function h(v){const E=u();v.__bindingPointIndex=E;const x=n.createBuffer(),M=v.__size,w=v.usage;return n.bindBuffer(n.UNIFORM_BUFFER,x),n.bufferData(n.UNIFORM_BUFFER,M,w),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,E,x),x}function u(){for(let v=0;v<a;v++)if(o.indexOf(v)===-1)return o.push(v),v;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(v){const E=r[v.id],x=v.uniforms,M=v.__cache;n.bindBuffer(n.UNIFORM_BUFFER,E);for(let w=0,S=x.length;w<S;w++){const B=Array.isArray(x[w])?x[w]:[x[w]];for(let y=0,_=B.length;y<_;y++){const L=B[y];if(f(L,w,y,M)===!0){const Q=L.__offset,O=Array.isArray(L.value)?L.value:[L.value];let X=0;for(let te=0;te<O.length;te++){const W=O[te],Z=g(W);typeof W=="number"||typeof W=="boolean"?(L.__data[0]=W,n.bufferSubData(n.UNIFORM_BUFFER,Q+X,L.__data)):W.isMatrix3?(L.__data[0]=W.elements[0],L.__data[1]=W.elements[1],L.__data[2]=W.elements[2],L.__data[3]=0,L.__data[4]=W.elements[3],L.__data[5]=W.elements[4],L.__data[6]=W.elements[5],L.__data[7]=0,L.__data[8]=W.elements[6],L.__data[9]=W.elements[7],L.__data[10]=W.elements[8],L.__data[11]=0):(W.toArray(L.__data,X),X+=Z.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,Q,L.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function f(v,E,x,M){const w=v.value,S=E+"_"+x;if(M[S]===void 0)return typeof w=="number"||typeof w=="boolean"?M[S]=w:M[S]=w.clone(),!0;{const B=M[S];if(typeof w=="number"||typeof w=="boolean"){if(B!==w)return M[S]=w,!0}else if(B.equals(w)===!1)return B.copy(w),!0}return!1}function A(v){const E=v.uniforms;let x=0;const M=16;for(let S=0,B=E.length;S<B;S++){const y=Array.isArray(E[S])?E[S]:[E[S]];for(let _=0,L=y.length;_<L;_++){const Q=y[_],O=Array.isArray(Q.value)?Q.value:[Q.value];for(let X=0,te=O.length;X<te;X++){const W=O[X],Z=g(W),q=x%M,re=q%Z.boundary,ue=q+re;x+=re,ue!==0&&M-ue<Z.storage&&(x+=M-ue),Q.__data=new Float32Array(Z.storage/Float32Array.BYTES_PER_ELEMENT),Q.__offset=x,x+=Z.storage}}}const w=x%M;return w>0&&(x+=M-w),v.__size=x,v.__cache={},this}function g(v){const E={boundary:0,storage:0};return typeof v=="number"||typeof v=="boolean"?(E.boundary=4,E.storage=4):v.isVector2?(E.boundary=8,E.storage=8):v.isVector3||v.isColor?(E.boundary=16,E.storage=12):v.isVector4?(E.boundary=16,E.storage=16):v.isMatrix3?(E.boundary=48,E.storage=48):v.isMatrix4?(E.boundary=64,E.storage=64):v.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",v),E}function m(v){const E=v.target;E.removeEventListener("dispose",m);const x=o.indexOf(E.__bindingPointIndex);o.splice(x,1),n.deleteBuffer(r[E.id]),delete r[E.id],delete s[E.id]}function p(){for(const v in r)n.deleteBuffer(r[v]);o=[],r={},s={}}return{bind:l,update:c,dispose:p}}class GV{constructor(e={}){const{canvas:t=dN(),context:i=null,depth:r=!0,stencil:s=!1,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:u=!1,reverseDepthBuffer:d=!1}=e;this.isWebGLRenderer=!0;let f;if(i!==null){if(typeof WebGLRenderingContext<"u"&&i instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");f=i.getContextAttributes().alpha}else f=o;const A=new Uint32Array(4),g=new Int32Array(4);let m=null,p=null;const v=[],E=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=_s,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const x=this;let M=!1;this._outputColorSpace=pi;let w=0,S=0,B=null,y=-1,_=null;const L=new jt,Q=new jt;let O=null;const X=new kt(0);let te=0,W=t.width,Z=t.height,q=1,re=null,ue=null;const _e=new jt(0,0,W,Z),Be=new jt(0,0,W,Z);let ze=!1;const le=new sw;let Ee=!1,Ue=!1;const pe=new $t,oe=new $t,we=new ye,Me=new jt,Ve={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let me=!1;function Ae(){return B===null?q:1}let V=i;function j(H,he){return t.getContext(H,he)}try{const H={alpha:!0,depth:r,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:u};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${uv}`),t.addEventListener("webglcontextlost",ce,!1),t.addEventListener("webglcontextrestored",ge,!1),t.addEventListener("webglcontextcreationerror",xe,!1),V===null){const he="webgl2";if(V=j(he,H),V===null)throw j(he)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(H){throw console.error("THREE.WebGLRenderer: "+H.message),H}let Te,Re,b,I,U,R,T,G,J,de,N,P,$,se,ve,ie,Se,be,Ie,Fe,Le,Ge,Ze,F;function ae(){Te=new zG(V),Te.init(),Ge=new bH(V,Te),Re=new PG(V,Te,e,Ge),b=new yH(V,Te),Re.reverseDepthBuffer&&d&&b.buffers.depth.setReversed(!0),I=new QG(V),U=new lH,R=new _H(V,Te,b,U,Re,Ge,I),T=new FG(x),G=new GG(x),J=new $N(V),Ze=new LG(V,J),de=new HG(V,J,I,Ze),N=new XG(V,de,J,I),Ie=new WG(V,Re,R),ie=new UG(U),P=new aH(x,T,G,Te,Re,Ze,ie),$=new IH(x,U),se=new hH,ve=new AH(Te),be=new BG(x,T,G,b,N,f,l),Se=new EH(x,N,Re),F=new RH(V,I,Re,b),Fe=new DG(V,Te,I),Le=new VG(V,Te,I),I.programs=P.programs,x.capabilities=Re,x.extensions=Te,x.properties=U,x.renderLists=se,x.shadowMap=Se,x.state=b,x.info=I}ae();const ne=new wH(x,V);this.xr=ne,this.getContext=function(){return V},this.getContextAttributes=function(){return V.getContextAttributes()},this.forceContextLoss=function(){const H=Te.get("WEBGL_lose_context");H&&H.loseContext()},this.forceContextRestore=function(){const H=Te.get("WEBGL_lose_context");H&&H.restoreContext()},this.getPixelRatio=function(){return q},this.setPixelRatio=function(H){H!==void 0&&(q=H,this.setSize(W,Z,!1))},this.getSize=function(H){return H.set(W,Z)},this.setSize=function(H,he,D=!0){if(ne.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}W=H,Z=he,t.width=Math.floor(H*q),t.height=Math.floor(he*q),D===!0&&(t.style.width=H+"px",t.style.height=he+"px"),this.setViewport(0,0,H,he)},this.getDrawingBufferSize=function(H){return H.set(W*q,Z*q).floor()},this.setDrawingBufferSize=function(H,he,D){W=H,Z=he,q=D,t.width=Math.floor(H*D),t.height=Math.floor(he*D),this.setViewport(0,0,H,he)},this.getCurrentViewport=function(H){return H.copy(L)},this.getViewport=function(H){return H.copy(_e)},this.setViewport=function(H,he,D,z){H.isVector4?_e.set(H.x,H.y,H.z,H.w):_e.set(H,he,D,z),b.viewport(L.copy(_e).multiplyScalar(q).round())},this.getScissor=function(H){return H.copy(Be)},this.setScissor=function(H,he,D,z){H.isVector4?Be.set(H.x,H.y,H.z,H.w):Be.set(H,he,D,z),b.scissor(Q.copy(Be).multiplyScalar(q).round())},this.getScissorTest=function(){return ze},this.setScissorTest=function(H){b.setScissorTest(ze=H)},this.setOpaqueSort=function(H){re=H},this.setTransparentSort=function(H){ue=H},this.getClearColor=function(H){return H.copy(be.getClearColor())},this.setClearColor=function(){be.setClearColor(...arguments)},this.getClearAlpha=function(){return be.getClearAlpha()},this.setClearAlpha=function(){be.setClearAlpha(...arguments)},this.clear=function(H=!0,he=!0,D=!0){let z=0;if(H){let k=!1;if(B!==null){const ee=B.texture.format;k=ee===gv||ee===Av||ee===mv}if(k){const ee=B.texture.type,K=ee===Hr||ee===Lo||ee===Sc||ee===wc||ee===fv||ee===pv,fe=be.getClearColor(),Ce=be.getClearAlpha(),De=fe.r,Pe=fe.g,Oe=fe.b;K?(A[0]=De,A[1]=Pe,A[2]=Oe,A[3]=Ce,V.clearBufferuiv(V.COLOR,0,A)):(g[0]=De,g[1]=Pe,g[2]=Oe,g[3]=Ce,V.clearBufferiv(V.COLOR,0,g))}else z|=V.COLOR_BUFFER_BIT}he&&(z|=V.DEPTH_BUFFER_BIT),D&&(z|=V.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),V.clear(z)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",ce,!1),t.removeEventListener("webglcontextrestored",ge,!1),t.removeEventListener("webglcontextcreationerror",xe,!1),be.dispose(),se.dispose(),ve.dispose(),U.dispose(),T.dispose(),G.dispose(),N.dispose(),Ze.dispose(),F.dispose(),P.dispose(),ne.dispose(),ne.removeEventListener("sessionstart",Oo),ne.removeEventListener("sessionend",qc),zi.stop()};function ce(H){H.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function ge(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const H=I.autoReset,he=Se.enabled,D=Se.autoUpdate,z=Se.needsUpdate,k=Se.type;ae(),I.autoReset=H,Se.enabled=he,Se.autoUpdate=D,Se.needsUpdate=z,Se.type=k}function xe(H){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",H.statusMessage)}function We(H){const he=H.target;he.removeEventListener("dispose",We),ke(he)}function ke(H){He(H),U.remove(H)}function He(H){const he=U.get(H).programs;he!==void 0&&(he.forEach(function(D){P.releaseProgram(D)}),H.isShaderMaterial&&P.releaseShaderCache(H))}this.renderBufferDirect=function(H,he,D,z,k,ee){he===null&&(he=Ve);const K=k.isMesh&&k.matrixWorld.determinant()<0,fe=Yc(H,he,D,z,k);b.setMaterial(z,K);let Ce=D.index,De=1;if(z.wireframe===!0){if(Ce=de.getWireframeAttribute(D),Ce===void 0)return;De=2}const Pe=D.drawRange,Oe=D.attributes.position;let qe=Pe.start*De,Xe=(Pe.start+Pe.count)*De;ee!==null&&(qe=Math.max(qe,ee.start*De),Xe=Math.min(Xe,(ee.start+ee.count)*De)),Ce!==null?(qe=Math.max(qe,0),Xe=Math.min(Xe,Ce.count)):Oe!=null&&(qe=Math.max(qe,0),Xe=Math.min(Xe,Oe.count));const it=Xe-qe;if(it<0||it===1/0)return;Ze.setup(k,z,fe,D,Ce);let rt,st=Fe;if(Ce!==null&&(rt=J.get(Ce),st=Le,st.setIndex(rt)),k.isMesh)z.wireframe===!0?(b.setLineWidth(z.wireframeLinewidth*Ae()),st.setMode(V.LINES)):st.setMode(V.TRIANGLES);else if(k.isLine){let $e=z.linewidth;$e===void 0&&($e=1),b.setLineWidth($e*Ae()),k.isLineSegments?st.setMode(V.LINES):k.isLineLoop?st.setMode(V.LINE_LOOP):st.setMode(V.LINE_STRIP)}else k.isPoints?st.setMode(V.POINTS):k.isSprite&&st.setMode(V.TRIANGLES);if(k.isBatchedMesh)if(k._multiDrawInstances!==null)Ju("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),st.renderMultiDrawInstances(k._multiDrawStarts,k._multiDrawCounts,k._multiDrawCount,k._multiDrawInstances);else if(Te.get("WEBGL_multi_draw"))st.renderMultiDraw(k._multiDrawStarts,k._multiDrawCounts,k._multiDrawCount);else{const $e=k._multiDrawStarts,at=k._multiDrawCounts,lt=k._multiDrawCount,Je=Ce?J.get(Ce).bytesPerElement:1,oi=U.get(z).currentProgram.getUniforms();for(let ut=0;ut<lt;ut++)oi.setValue(V,"_gl_DrawID",ut),st.render($e[ut]/Je,at[ut])}else if(k.isInstancedMesh)st.renderInstances(qe,it,k.count);else if(D.isInstancedBufferGeometry){const $e=D._maxInstanceCount!==void 0?D._maxInstanceCount:1/0,at=Math.min(D.instanceCount,$e);st.renderInstances(qe,it,at)}else st.render(qe,it)};function Qe(H,he,D){H.transparent===!0&&H.side===_r&&H.forceSinglePass===!1?(H.side=jn,H.needsUpdate=!0,ir(H,he,D),H.side=ws,H.needsUpdate=!0,ir(H,he,D),H.side=_r):ir(H,he,D)}this.compile=function(H,he,D=null){D===null&&(D=H),p=ve.get(D),p.init(he),E.push(p),D.traverseVisible(function(k){k.isLight&&k.layers.test(he.layers)&&(p.pushLight(k),k.castShadow&&p.pushShadow(k))}),H!==D&&H.traverseVisible(function(k){k.isLight&&k.layers.test(he.layers)&&(p.pushLight(k),k.castShadow&&p.pushShadow(k))}),p.setupLights();const z=new Set;return H.traverse(function(k){if(!(k.isMesh||k.isPoints||k.isLine||k.isSprite))return;const ee=k.material;if(ee)if(Array.isArray(ee))for(let K=0;K<ee.length;K++){const fe=ee[K];Qe(fe,D,k),z.add(fe)}else Qe(ee,D,k),z.add(ee)}),p=E.pop(),z},this.compileAsync=function(H,he,D=null){const z=this.compile(H,he,D);return new Promise(k=>{function ee(){if(z.forEach(function(K){U.get(K).currentProgram.isReady()&&z.delete(K)}),z.size===0){k(H);return}setTimeout(ee,10)}Te.get("KHR_parallel_shader_compile")!==null?ee():setTimeout(ee,10)})};let ht=null;function Pt(H){ht&&ht(H)}function Oo(){zi.stop()}function qc(){zi.start()}const zi=new aw;zi.setAnimationLoop(Pt),typeof self<"u"&&zi.setContext(self),this.setAnimationLoop=function(H){ht=H,ne.setAnimationLoop(H),H===null?zi.stop():zi.start()},ne.addEventListener("sessionstart",Oo),ne.addEventListener("sessionend",qc),this.render=function(H,he){if(he!==void 0&&he.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(M===!0)return;if(H.matrixWorldAutoUpdate===!0&&H.updateMatrixWorld(),he.parent===null&&he.matrixWorldAutoUpdate===!0&&he.updateMatrixWorld(),ne.enabled===!0&&ne.isPresenting===!0&&(ne.cameraAutoUpdate===!0&&ne.updateCamera(he),he=ne.getCamera()),H.isScene===!0&&H.onBeforeRender(x,H,he,B),p=ve.get(H,E.length),p.init(he),E.push(p),oe.multiplyMatrices(he.projectionMatrix,he.matrixWorldInverse),le.setFromProjectionMatrix(oe),Ue=this.localClippingEnabled,Ee=ie.init(this.clippingPlanes,Ue),m=se.get(H,v.length),m.init(),v.push(m),ne.enabled===!0&&ne.isPresenting===!0){const ee=x.xr.getDepthSensingMesh();ee!==null&&ko(ee,he,-1/0,x.sortObjects)}ko(H,he,0,x.sortObjects),m.finish(),x.sortObjects===!0&&m.sort(re,ue),me=ne.enabled===!1||ne.isPresenting===!1||ne.hasDepthSensing()===!1,me&&be.addToRenderList(m,H),this.info.render.frame++,Ee===!0&&ie.beginShadows();const D=p.state.shadowsArray;Se.render(D,H,he),Ee===!0&&ie.endShadows(),this.info.autoReset===!0&&this.info.reset();const z=m.opaque,k=m.transmissive;if(p.setupLights(),he.isArrayCamera){const ee=he.cameras;if(k.length>0)for(let K=0,fe=ee.length;K<fe;K++){const Ce=ee[K];Go(z,k,H,Ce)}me&&be.render(H);for(let K=0,fe=ee.length;K<fe;K++){const Ce=ee[K];Hi(m,H,Ce,Ce.viewport)}}else k.length>0&&Go(z,k,H,he),me&&be.render(H),Hi(m,H,he);B!==null&&S===0&&(R.updateMultisampleRenderTarget(B),R.updateRenderTargetMipmap(B)),H.isScene===!0&&H.onAfterRender(x,H,he),Ze.resetDefaultState(),y=-1,_=null,E.pop(),E.length>0?(p=E[E.length-1],Ee===!0&&ie.setGlobalState(x.clippingPlanes,p.state.camera)):p=null,v.pop(),v.length>0?m=v[v.length-1]:m=null};function ko(H,he,D,z){if(H.visible===!1)return;if(H.layers.test(he.layers)){if(H.isGroup)D=H.renderOrder;else if(H.isLOD)H.autoUpdate===!0&&H.update(he);else if(H.isLight)p.pushLight(H),H.castShadow&&p.pushShadow(H);else if(H.isSprite){if(!H.frustumCulled||le.intersectsSprite(H)){z&&Me.setFromMatrixPosition(H.matrixWorld).applyMatrix4(oe);const K=N.update(H),fe=H.material;fe.visible&&m.push(H,K,fe,D,Me.z,null)}}else if((H.isMesh||H.isLine||H.isPoints)&&(!H.frustumCulled||le.intersectsObject(H))){const K=N.update(H),fe=H.material;if(z&&(H.boundingSphere!==void 0?(H.boundingSphere===null&&H.computeBoundingSphere(),Me.copy(H.boundingSphere.center)):(K.boundingSphere===null&&K.computeBoundingSphere(),Me.copy(K.boundingSphere.center)),Me.applyMatrix4(H.matrixWorld).applyMatrix4(oe)),Array.isArray(fe)){const Ce=K.groups;for(let De=0,Pe=Ce.length;De<Pe;De++){const Oe=Ce[De],qe=fe[Oe.materialIndex];qe&&qe.visible&&m.push(H,K,qe,D,Me.z,Oe)}}else fe.visible&&m.push(H,K,fe,D,Me.z,null)}}const ee=H.children;for(let K=0,fe=ee.length;K<fe;K++)ko(ee[K],he,D,z)}function Hi(H,he,D,z){const k=H.opaque,ee=H.transmissive,K=H.transparent;p.setupLightsView(D),Ee===!0&&ie.setGlobalState(x.clippingPlanes,D),z&&b.viewport(L.copy(z)),k.length>0&&Qr(k,he,D),ee.length>0&&Qr(ee,he,D),K.length>0&&Qr(K,he,D),b.buffers.depth.setTest(!0),b.buffers.depth.setMask(!0),b.buffers.color.setMask(!0),b.setPolygonOffset(!1)}function Go(H,he,D,z){if((D.isScene===!0?D.overrideMaterial:null)!==null)return;p.state.transmissionRenderTarget[z.id]===void 0&&(p.state.transmissionRenderTarget[z.id]=new Do(1,1,{generateMipmaps:!0,type:Te.has("EXT_color_buffer_half_float")||Te.has("EXT_color_buffer_float")?Qc:Hr,minFilter:_o,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Rt.workingColorSpace}));const ee=p.state.transmissionRenderTarget[z.id],K=z.viewport||L;ee.setSize(K.z*x.transmissionResolutionScale,K.w*x.transmissionResolutionScale);const fe=x.getRenderTarget();x.setRenderTarget(ee),x.getClearColor(X),te=x.getClearAlpha(),te<1&&x.setClearColor(16777215,.5),x.clear(),me&&be.render(D);const Ce=x.toneMapping;x.toneMapping=_s;const De=z.viewport;if(z.viewport!==void 0&&(z.viewport=void 0),p.setupLightsView(z),Ee===!0&&ie.setGlobalState(x.clippingPlanes,z),Qr(H,D,z),R.updateMultisampleRenderTarget(ee),R.updateRenderTargetMipmap(ee),Te.has("WEBGL_multisampled_render_to_texture")===!1){let Pe=!1;for(let Oe=0,qe=he.length;Oe<qe;Oe++){const Xe=he[Oe],it=Xe.object,rt=Xe.geometry,st=Xe.material,$e=Xe.group;if(st.side===_r&&it.layers.test(z.layers)){const at=st.side;st.side=jn,st.needsUpdate=!0,cl(it,D,z,rt,st,$e),st.side=at,st.needsUpdate=!0,Pe=!0}}Pe===!0&&(R.updateMultisampleRenderTarget(ee),R.updateRenderTargetMipmap(ee))}x.setRenderTarget(fe),x.setClearColor(X,te),De!==void 0&&(z.viewport=De),x.toneMapping=Ce}function Qr(H,he,D){const z=he.isScene===!0?he.overrideMaterial:null;for(let k=0,ee=H.length;k<ee;k++){const K=H[k],fe=K.object,Ce=K.geometry,De=K.group;let Pe=K.material;Pe.allowOverride===!0&&z!==null&&(Pe=z),fe.layers.test(D.layers)&&cl(fe,he,D,Ce,Pe,De)}}function cl(H,he,D,z,k,ee){H.onBeforeRender(x,he,D,z,k,ee),H.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse,H.matrixWorld),H.normalMatrix.getNormalMatrix(H.modelViewMatrix),k.onBeforeRender(x,he,D,z,H,ee),k.transparent===!0&&k.side===_r&&k.forceSinglePass===!1?(k.side=jn,k.needsUpdate=!0,x.renderBufferDirect(D,he,z,k,H,ee),k.side=ws,k.needsUpdate=!0,x.renderBufferDirect(D,he,z,k,H,ee),k.side=_r):x.renderBufferDirect(D,he,z,k,H,ee),H.onAfterRender(x,he,D,z,k,ee)}function ir(H,he,D){he.isScene!==!0&&(he=Ve);const z=U.get(H),k=p.state.lights,ee=p.state.shadowsArray,K=k.state.version,fe=P.getParameters(H,k.state,ee,he,D),Ce=P.getProgramCacheKey(fe);let De=z.programs;z.environment=H.isMeshStandardMaterial?he.environment:null,z.fog=he.fog,z.envMap=(H.isMeshStandardMaterial?G:T).get(H.envMap||z.environment),z.envMapRotation=z.environment!==null&&H.envMap===null?he.environmentRotation:H.envMapRotation,De===void 0&&(H.addEventListener("dispose",We),De=new Map,z.programs=De);let Pe=De.get(Ce);if(Pe!==void 0){if(z.currentProgram===Pe&&z.lightsStateVersion===K)return Ds(H,fe),Pe}else fe.uniforms=P.getUniforms(H),H.onBeforeCompile(fe,x),Pe=P.acquireProgram(fe,Ce),De.set(Ce,Pe),z.uniforms=fe.uniforms;const Oe=z.uniforms;return(!H.isShaderMaterial&&!H.isRawShaderMaterial||H.clipping===!0)&&(Oe.clippingPlanes=ie.uniform),Ds(H,fe),z.needsLights=Kf(H),z.lightsStateVersion=K,z.needsLights&&(Oe.ambientLightColor.value=k.state.ambient,Oe.lightProbe.value=k.state.probe,Oe.directionalLights.value=k.state.directional,Oe.directionalLightShadows.value=k.state.directionalShadow,Oe.spotLights.value=k.state.spot,Oe.spotLightShadows.value=k.state.spotShadow,Oe.rectAreaLights.value=k.state.rectArea,Oe.ltc_1.value=k.state.rectAreaLTC1,Oe.ltc_2.value=k.state.rectAreaLTC2,Oe.pointLights.value=k.state.point,Oe.pointLightShadows.value=k.state.pointShadow,Oe.hemisphereLights.value=k.state.hemi,Oe.directionalShadowMap.value=k.state.directionalShadowMap,Oe.directionalShadowMatrix.value=k.state.directionalShadowMatrix,Oe.spotShadowMap.value=k.state.spotShadowMap,Oe.spotLightMatrix.value=k.state.spotLightMatrix,Oe.spotLightMap.value=k.state.spotLightMap,Oe.pointShadowMap.value=k.state.pointShadowMap,Oe.pointShadowMatrix.value=k.state.pointShadowMatrix),z.currentProgram=Pe,z.uniformsList=null,Pe}function hl(H){if(H.uniformsList===null){const he=H.currentProgram.getUniforms();H.uniformsList=Zu.seqWithValue(he.seq,H.uniforms)}return H.uniformsList}function Ds(H,he){const D=U.get(H);D.outputColorSpace=he.outputColorSpace,D.batching=he.batching,D.batchingColor=he.batchingColor,D.instancing=he.instancing,D.instancingColor=he.instancingColor,D.instancingMorph=he.instancingMorph,D.skinning=he.skinning,D.morphTargets=he.morphTargets,D.morphNormals=he.morphNormals,D.morphColors=he.morphColors,D.morphTargetsCount=he.morphTargetsCount,D.numClippingPlanes=he.numClippingPlanes,D.numIntersection=he.numClipIntersection,D.vertexAlphas=he.vertexAlphas,D.vertexTangents=he.vertexTangents,D.toneMapping=he.toneMapping}function Yc(H,he,D,z,k){he.isScene!==!0&&(he=Ve),R.resetTextureUnits();const ee=he.fog,K=z.isMeshStandardMaterial?he.environment:null,fe=B===null?x.outputColorSpace:B.isXRRenderTarget===!0?B.texture.colorSpace:el,Ce=(z.isMeshStandardMaterial?G:T).get(z.envMap||K),De=z.vertexColors===!0&&!!D.attributes.color&&D.attributes.color.itemSize===4,Pe=!!D.attributes.tangent&&(!!z.normalMap||z.anisotropy>0),Oe=!!D.morphAttributes.position,qe=!!D.morphAttributes.normal,Xe=!!D.morphAttributes.color;let it=_s;z.toneMapped&&(B===null||B.isXRRenderTarget===!0)&&(it=x.toneMapping);const rt=D.morphAttributes.position||D.morphAttributes.normal||D.morphAttributes.color,st=rt!==void 0?rt.length:0,$e=U.get(z),at=p.state.lights;if(Ee===!0&&(Ue===!0||H!==_)){const ft=H===_&&z.id===y;ie.setState(z,H,ft)}let lt=!1;z.version===$e.__version?($e.needsLights&&$e.lightsStateVersion!==at.state.version||$e.outputColorSpace!==fe||k.isBatchedMesh&&$e.batching===!1||!k.isBatchedMesh&&$e.batching===!0||k.isBatchedMesh&&$e.batchingColor===!0&&k.colorTexture===null||k.isBatchedMesh&&$e.batchingColor===!1&&k.colorTexture!==null||k.isInstancedMesh&&$e.instancing===!1||!k.isInstancedMesh&&$e.instancing===!0||k.isSkinnedMesh&&$e.skinning===!1||!k.isSkinnedMesh&&$e.skinning===!0||k.isInstancedMesh&&$e.instancingColor===!0&&k.instanceColor===null||k.isInstancedMesh&&$e.instancingColor===!1&&k.instanceColor!==null||k.isInstancedMesh&&$e.instancingMorph===!0&&k.morphTexture===null||k.isInstancedMesh&&$e.instancingMorph===!1&&k.morphTexture!==null||$e.envMap!==Ce||z.fog===!0&&$e.fog!==ee||$e.numClippingPlanes!==void 0&&($e.numClippingPlanes!==ie.numPlanes||$e.numIntersection!==ie.numIntersection)||$e.vertexAlphas!==De||$e.vertexTangents!==Pe||$e.morphTargets!==Oe||$e.morphNormals!==qe||$e.morphColors!==Xe||$e.toneMapping!==it||$e.morphTargetsCount!==st)&&(lt=!0):(lt=!0,$e.__version=z.version);let Je=$e.currentProgram;lt===!0&&(Je=ir(z,he,k));let oi=!1,ut=!1,tn=!1;const Mt=Je.getUniforms(),Kt=$e.uniforms;if(b.useProgram(Je.program)&&(oi=!0,ut=!0,tn=!0),z.id!==y&&(y=z.id,ut=!0),oi||_!==H){b.buffers.depth.getReversed()?(pe.copy(H.projectionMatrix),pN(pe),mN(pe),Mt.setValue(V,"projectionMatrix",pe)):Mt.setValue(V,"projectionMatrix",H.projectionMatrix),Mt.setValue(V,"viewMatrix",H.matrixWorldInverse);const It=Mt.map.cameraPosition;It!==void 0&&It.setValue(V,we.setFromMatrixPosition(H.matrixWorld)),Re.logarithmicDepthBuffer&&Mt.setValue(V,"logDepthBufFC",2/(Math.log(H.far+1)/Math.LN2)),(z.isMeshPhongMaterial||z.isMeshToonMaterial||z.isMeshLambertMaterial||z.isMeshBasicMaterial||z.isMeshStandardMaterial||z.isShaderMaterial)&&Mt.setValue(V,"isOrthographic",H.isOrthographicCamera===!0),_!==H&&(_=H,ut=!0,tn=!0)}if(k.isSkinnedMesh){Mt.setOptional(V,k,"bindMatrix"),Mt.setOptional(V,k,"bindMatrixInverse");const ft=k.skeleton;ft&&(ft.boneTexture===null&&ft.computeBoneTexture(),Mt.setValue(V,"boneTexture",ft.boneTexture,R))}k.isBatchedMesh&&(Mt.setOptional(V,k,"batchingTexture"),Mt.setValue(V,"batchingTexture",k._matricesTexture,R),Mt.setOptional(V,k,"batchingIdTexture"),Mt.setValue(V,"batchingIdTexture",k._indirectTexture,R),Mt.setOptional(V,k,"batchingColorTexture"),k._colorsTexture!==null&&Mt.setValue(V,"batchingColorTexture",k._colorsTexture,R));const nn=D.morphAttributes;if((nn.position!==void 0||nn.normal!==void 0||nn.color!==void 0)&&Ie.update(k,D,Je),(ut||$e.receiveShadow!==k.receiveShadow)&&($e.receiveShadow=k.receiveShadow,Mt.setValue(V,"receiveShadow",k.receiveShadow)),z.isMeshGouraudMaterial&&z.envMap!==null&&(Kt.envMap.value=Ce,Kt.flipEnvMap.value=Ce.isCubeTexture&&Ce.isRenderTargetTexture===!1?-1:1),z.isMeshStandardMaterial&&z.envMap===null&&he.environment!==null&&(Kt.envMapIntensity.value=he.environmentIntensity),ut&&(Mt.setValue(V,"toneMappingExposure",x.toneMappingExposure),$e.needsLights&&jc(Kt,tn),ee&&z.fog===!0&&$.refreshFogUniforms(Kt,ee),$.refreshMaterialUniforms(Kt,z,q,Z,p.state.transmissionRenderTarget[H.id]),Zu.upload(V,hl($e),Kt,R)),z.isShaderMaterial&&z.uniformsNeedUpdate===!0&&(Zu.upload(V,hl($e),Kt,R),z.uniformsNeedUpdate=!1),z.isSpriteMaterial&&Mt.setValue(V,"center",k.center),Mt.setValue(V,"modelViewMatrix",k.modelViewMatrix),Mt.setValue(V,"normalMatrix",k.normalMatrix),Mt.setValue(V,"modelMatrix",k.matrixWorld),z.isShaderMaterial||z.isRawShaderMaterial){const ft=z.uniformsGroups;for(let It=0,ai=ft.length;It<ai;It++){const Nt=ft[It];F.update(Nt,Je),F.bind(Nt,Je)}}return Je}function jc(H,he){H.ambientLightColor.needsUpdate=he,H.lightProbe.needsUpdate=he,H.directionalLights.needsUpdate=he,H.directionalLightShadows.needsUpdate=he,H.pointLights.needsUpdate=he,H.pointLightShadows.needsUpdate=he,H.spotLights.needsUpdate=he,H.spotLightShadows.needsUpdate=he,H.rectAreaLights.needsUpdate=he,H.hemisphereLights.needsUpdate=he}function Kf(H){return H.isMeshLambertMaterial||H.isMeshToonMaterial||H.isMeshPhongMaterial||H.isMeshStandardMaterial||H.isShadowMaterial||H.isShaderMaterial&&H.lights===!0}this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return B},this.setRenderTargetTextures=function(H,he,D){const z=U.get(H);z.__autoAllocateDepthBuffer=H.resolveDepthBuffer===!1,z.__autoAllocateDepthBuffer===!1&&(z.__useRenderToTexture=!1),U.get(H.texture).__webglTexture=he,U.get(H.depthTexture).__webglTexture=z.__autoAllocateDepthBuffer?void 0:D,z.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(H,he){const D=U.get(H);D.__webglFramebuffer=he,D.__useDefaultFramebuffer=he===void 0};const Jf=V.createFramebuffer();this.setRenderTarget=function(H,he=0,D=0){B=H,w=he,S=D;let z=!0,k=null,ee=!1,K=!1;if(H){const Ce=U.get(H);if(Ce.__useDefaultFramebuffer!==void 0)b.bindFramebuffer(V.FRAMEBUFFER,null),z=!1;else if(Ce.__webglFramebuffer===void 0)R.setupRenderTarget(H);else if(Ce.__hasExternalTextures)R.rebindTextures(H,U.get(H.texture).__webglTexture,U.get(H.depthTexture).__webglTexture);else if(H.depthBuffer){const Oe=H.depthTexture;if(Ce.__boundDepthTexture!==Oe){if(Oe!==null&&U.has(Oe)&&(H.width!==Oe.image.width||H.height!==Oe.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");R.setupDepthRenderbuffer(H)}}const De=H.texture;(De.isData3DTexture||De.isDataArrayTexture||De.isCompressedArrayTexture)&&(K=!0);const Pe=U.get(H).__webglFramebuffer;H.isWebGLCubeRenderTarget?(Array.isArray(Pe[he])?k=Pe[he][D]:k=Pe[he],ee=!0):H.samples>0&&R.useMultisampledRTT(H)===!1?k=U.get(H).__webglMultisampledFramebuffer:Array.isArray(Pe)?k=Pe[D]:k=Pe,L.copy(H.viewport),Q.copy(H.scissor),O=H.scissorTest}else L.copy(_e).multiplyScalar(q).floor(),Q.copy(Be).multiplyScalar(q).floor(),O=ze;if(D!==0&&(k=Jf),b.bindFramebuffer(V.FRAMEBUFFER,k)&&z&&b.drawBuffers(H,k),b.viewport(L),b.scissor(Q),b.setScissorTest(O),ee){const Ce=U.get(H.texture);V.framebufferTexture2D(V.FRAMEBUFFER,V.COLOR_ATTACHMENT0,V.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ce.__webglTexture,D)}else if(K){const Ce=U.get(H.texture),De=he;V.framebufferTextureLayer(V.FRAMEBUFFER,V.COLOR_ATTACHMENT0,Ce.__webglTexture,D,De)}else if(H!==null&&D!==0){const Ce=U.get(H.texture);V.framebufferTexture2D(V.FRAMEBUFFER,V.COLOR_ATTACHMENT0,V.TEXTURE_2D,Ce.__webglTexture,D)}y=-1},this.readRenderTargetPixels=function(H,he,D,z,k,ee,K){if(!(H&&H.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let fe=U.get(H).__webglFramebuffer;if(H.isWebGLCubeRenderTarget&&K!==void 0&&(fe=fe[K]),fe){b.bindFramebuffer(V.FRAMEBUFFER,fe);try{const Ce=H.texture,De=Ce.format,Pe=Ce.type;if(!Re.textureFormatReadable(De)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Re.textureTypeReadable(Pe)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}he>=0&&he<=H.width-z&&D>=0&&D<=H.height-k&&V.readPixels(he,D,z,k,Ge.convert(De),Ge.convert(Pe),ee)}finally{const Ce=B!==null?U.get(B).__webglFramebuffer:null;b.bindFramebuffer(V.FRAMEBUFFER,Ce)}}},this.readRenderTargetPixelsAsync=async function(H,he,D,z,k,ee,K){if(!(H&&H.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let fe=U.get(H).__webglFramebuffer;if(H.isWebGLCubeRenderTarget&&K!==void 0&&(fe=fe[K]),fe)if(he>=0&&he<=H.width-z&&D>=0&&D<=H.height-k){b.bindFramebuffer(V.FRAMEBUFFER,fe);const Ce=H.texture,De=Ce.format,Pe=Ce.type;if(!Re.textureFormatReadable(De))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Re.textureTypeReadable(Pe))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const Oe=V.createBuffer();V.bindBuffer(V.PIXEL_PACK_BUFFER,Oe),V.bufferData(V.PIXEL_PACK_BUFFER,ee.byteLength,V.STREAM_READ),V.readPixels(he,D,z,k,Ge.convert(De),Ge.convert(Pe),0);const qe=B!==null?U.get(B).__webglFramebuffer:null;b.bindFramebuffer(V.FRAMEBUFFER,qe);const Xe=V.fenceSync(V.SYNC_GPU_COMMANDS_COMPLETE,0);return V.flush(),await fN(V,Xe,4),V.bindBuffer(V.PIXEL_PACK_BUFFER,Oe),V.getBufferSubData(V.PIXEL_PACK_BUFFER,0,ee),V.deleteBuffer(Oe),V.deleteSync(Xe),ee}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(H,he=null,D=0){const z=Math.pow(2,-D),k=Math.floor(H.image.width*z),ee=Math.floor(H.image.height*z),K=he!==null?he.x:0,fe=he!==null?he.y:0;R.setTexture2D(H,0),V.copyTexSubImage2D(V.TEXTURE_2D,D,0,0,K,fe,k,ee),b.unbindTexture()};const Zf=V.createFramebuffer(),ep=V.createFramebuffer();this.copyTextureToTexture=function(H,he,D=null,z=null,k=0,ee=null){ee===null&&(k!==0?(Ju("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),ee=k,k=0):ee=0);let K,fe,Ce,De,Pe,Oe,qe,Xe,it;const rt=H.isCompressedTexture?H.mipmaps[ee]:H.image;if(D!==null)K=D.max.x-D.min.x,fe=D.max.y-D.min.y,Ce=D.isBox3?D.max.z-D.min.z:1,De=D.min.x,Pe=D.min.y,Oe=D.isBox3?D.min.z:0;else{const nn=Math.pow(2,-k);K=Math.floor(rt.width*nn),fe=Math.floor(rt.height*nn),H.isDataArrayTexture?Ce=rt.depth:H.isData3DTexture?Ce=Math.floor(rt.depth*nn):Ce=1,De=0,Pe=0,Oe=0}z!==null?(qe=z.x,Xe=z.y,it=z.z):(qe=0,Xe=0,it=0);const st=Ge.convert(he.format),$e=Ge.convert(he.type);let at;he.isData3DTexture?(R.setTexture3D(he,0),at=V.TEXTURE_3D):he.isDataArrayTexture||he.isCompressedArrayTexture?(R.setTexture2DArray(he,0),at=V.TEXTURE_2D_ARRAY):(R.setTexture2D(he,0),at=V.TEXTURE_2D),V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL,he.flipY),V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL,he.premultiplyAlpha),V.pixelStorei(V.UNPACK_ALIGNMENT,he.unpackAlignment);const lt=V.getParameter(V.UNPACK_ROW_LENGTH),Je=V.getParameter(V.UNPACK_IMAGE_HEIGHT),oi=V.getParameter(V.UNPACK_SKIP_PIXELS),ut=V.getParameter(V.UNPACK_SKIP_ROWS),tn=V.getParameter(V.UNPACK_SKIP_IMAGES);V.pixelStorei(V.UNPACK_ROW_LENGTH,rt.width),V.pixelStorei(V.UNPACK_IMAGE_HEIGHT,rt.height),V.pixelStorei(V.UNPACK_SKIP_PIXELS,De),V.pixelStorei(V.UNPACK_SKIP_ROWS,Pe),V.pixelStorei(V.UNPACK_SKIP_IMAGES,Oe);const Mt=H.isDataArrayTexture||H.isData3DTexture,Kt=he.isDataArrayTexture||he.isData3DTexture;if(H.isDepthTexture){const nn=U.get(H),ft=U.get(he),It=U.get(nn.__renderTarget),ai=U.get(ft.__renderTarget);b.bindFramebuffer(V.READ_FRAMEBUFFER,It.__webglFramebuffer),b.bindFramebuffer(V.DRAW_FRAMEBUFFER,ai.__webglFramebuffer);for(let Nt=0;Nt<Ce;Nt++)Mt&&(V.framebufferTextureLayer(V.READ_FRAMEBUFFER,V.COLOR_ATTACHMENT0,U.get(H).__webglTexture,k,Oe+Nt),V.framebufferTextureLayer(V.DRAW_FRAMEBUFFER,V.COLOR_ATTACHMENT0,U.get(he).__webglTexture,ee,it+Nt)),V.blitFramebuffer(De,Pe,K,fe,qe,Xe,K,fe,V.DEPTH_BUFFER_BIT,V.NEAREST);b.bindFramebuffer(V.READ_FRAMEBUFFER,null),b.bindFramebuffer(V.DRAW_FRAMEBUFFER,null)}else if(k!==0||H.isRenderTargetTexture||U.has(H)){const nn=U.get(H),ft=U.get(he);b.bindFramebuffer(V.READ_FRAMEBUFFER,Zf),b.bindFramebuffer(V.DRAW_FRAMEBUFFER,ep);for(let It=0;It<Ce;It++)Mt?V.framebufferTextureLayer(V.READ_FRAMEBUFFER,V.COLOR_ATTACHMENT0,nn.__webglTexture,k,Oe+It):V.framebufferTexture2D(V.READ_FRAMEBUFFER,V.COLOR_ATTACHMENT0,V.TEXTURE_2D,nn.__webglTexture,k),Kt?V.framebufferTextureLayer(V.DRAW_FRAMEBUFFER,V.COLOR_ATTACHMENT0,ft.__webglTexture,ee,it+It):V.framebufferTexture2D(V.DRAW_FRAMEBUFFER,V.COLOR_ATTACHMENT0,V.TEXTURE_2D,ft.__webglTexture,ee),k!==0?V.blitFramebuffer(De,Pe,K,fe,qe,Xe,K,fe,V.COLOR_BUFFER_BIT,V.NEAREST):Kt?V.copyTexSubImage3D(at,ee,qe,Xe,it+It,De,Pe,K,fe):V.copyTexSubImage2D(at,ee,qe,Xe,De,Pe,K,fe);b.bindFramebuffer(V.READ_FRAMEBUFFER,null),b.bindFramebuffer(V.DRAW_FRAMEBUFFER,null)}else Kt?H.isDataTexture||H.isData3DTexture?V.texSubImage3D(at,ee,qe,Xe,it,K,fe,Ce,st,$e,rt.data):he.isCompressedArrayTexture?V.compressedTexSubImage3D(at,ee,qe,Xe,it,K,fe,Ce,st,rt.data):V.texSubImage3D(at,ee,qe,Xe,it,K,fe,Ce,st,$e,rt):H.isDataTexture?V.texSubImage2D(V.TEXTURE_2D,ee,qe,Xe,K,fe,st,$e,rt.data):H.isCompressedTexture?V.compressedTexSubImage2D(V.TEXTURE_2D,ee,qe,Xe,rt.width,rt.height,st,rt.data):V.texSubImage2D(V.TEXTURE_2D,ee,qe,Xe,K,fe,st,$e,rt);V.pixelStorei(V.UNPACK_ROW_LENGTH,lt),V.pixelStorei(V.UNPACK_IMAGE_HEIGHT,Je),V.pixelStorei(V.UNPACK_SKIP_PIXELS,oi),V.pixelStorei(V.UNPACK_SKIP_ROWS,ut),V.pixelStorei(V.UNPACK_SKIP_IMAGES,tn),ee===0&&he.generateMipmaps&&V.generateMipmap(at),b.unbindTexture()},this.copyTextureToTexture3D=function(H,he,D=null,z=null,k=0){return Ju('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(H,he,D,z,k)},this.initRenderTarget=function(H){U.get(H).__webglFramebuffer===void 0&&R.setupRenderTarget(H)},this.initTexture=function(H){H.isCubeTexture?R.setTextureCube(H,0):H.isData3DTexture?R.setTexture3D(H,0):H.isDataArrayTexture||H.isCompressedArrayTexture?R.setTexture2DArray(H,0):R.setTexture2D(H,0),b.unbindTexture()},this.resetState=function(){w=0,S=0,B=null,b.reset(),Ze.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Rr}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=Rt._getDrawingBufferColorSpace(e),t.unpackColorSpace=Rt._getUnpackColorSpace()}}var dw=n=>{throw TypeError(n)},bv=(n,e,t)=>e.has(n)||dw("Cannot "+t),_t=(n,e,t)=>(bv(n,e,"read from private field"),t?t.call(n):e.get(n)),ui=(n,e,t)=>e.has(n)?dw("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),on=(n,e,t,i)=>(bv(n,e,"write to private field"),e.set(n,t),t),$i=(n,e,t)=>(bv(n,e,"access private method"),t),BH=(n,e,t,i)=>({set _(r){on(n,e,r)},get _(){return _t(n,e,i)}}),Ba,fw,pw,mw,Aw;class LH{constructor(){ui(this,Ba),this.EARTH=4007501668e-2,this.HALF_EARTH=2003750834e-2}project(e,t){return[$i(this,Ba,fw).call(this,e),$i(this,Ba,pw).call(this,t)]}unproject(e){return[$i(this,Ba,mw).call(this,e[0]),$i(this,Ba,Aw).call(this,e[1])]}getID(){return"epsg:3857"}}Ba=new WeakSet,fw=function(n){return n/180*this.HALF_EARTH},pw=function(n){var e=Math.log(Math.tan((90+n)*Math.PI/360))/(Math.PI/180);return e*this.HALF_EARTH/180},mw=function(n){return n/this.HALF_EARTH*180},Aw=function(n){var e=n/this.HALF_EARTH*180;return e=180/Math.PI*(2*Math.atan(Math.exp(e*Math.PI/180))-Math.PI/2),e};var ka,ms,us,Ga,za,ls,br,Ao,As,Cr,gs,Wg,nb,Xg,ib;class DH{constructor(e,t,i={},r=null){ui(this,gs),ui(this,ka),ui(this,ms),ui(this,us),ui(this,Ga),ui(this,za),ui(this,ls),ui(this,br),ui(this,Ao),ui(this,As),ui(this,Cr),this.scene=e,this.camera=t,on(this,ka,new LH),on(this,ms,{}),on(this,us,null),on(this,Ga,0),on(this,za,100),on(this,ls,null),this.setGpsOptions(i),on(this,br,null),on(this,Ao,0),on(this,As,0),on(this,Cr,r)}setProjection(e){on(this,ka,e)}setGpsOptions(e={}){e.gpsMinDistance!==void 0&&on(this,Ga,e.gpsMinDistance),e.gpsMinAccuracy!==void 0&&on(this,za,e.gpsMinAccuracy)}async startGps(){if(_t(this,Cr)){const e=await(await _t(this,Cr).sendData("/gps/start",{gpsMinDistance:_t(this,Ga),gpsMinAccuracy:_t(this,za)})).json();on(this,As,e.session)}return _t(this,ls)===null?(on(this,ls,navigator.geolocation.watchPosition(e=>{$i(this,gs,Xg).call(this,e)},e=>{_t(this,ms).gpserror?_t(this,ms).gpserror(e.code):alert(`GPS error: code ${e.code}`)},{enableHighAccuracy:!0})),!0):!1}stopGps(){return _t(this,ls)!==null?(navigator.geolocation.clearWatch(_t(this,ls)),on(this,ls,null),!0):!1}fakeGps(e,t,i=null,r=0){i!==null&&this.setElevation(i),$i(this,gs,Xg).call(this,{coords:{longitude:e,latitude:t,accuracy:r}})}lonLatToWorldCoords(e,t){const i=_t(this,ka).project(e,t);if(_t(this,br))i[0]-=_t(this,br)[0],i[1]-=_t(this,br)[1];else throw"No initial position determined";return[i[0],-i[1]]}add(e,t,i,r,s={}){var o;e.properties=s,$i(this,gs,Wg).call(this,e,t,i,r),this.scene.add(e),(o=_t(this,Cr))==null||o.sendData("/object/new",{position:e.position,x:e.position.x,z:e.position.z,session:_t(this,As),properties:s})}setElevation(e){this.camera.position.y=e}on(e,t){_t(this,ms)[e]=t}}ka=new WeakMap,ms=new WeakMap,us=new WeakMap,Ga=new WeakMap,za=new WeakMap,ls=new WeakMap,br=new WeakMap,Ao=new WeakMap,As=new WeakMap,Cr=new WeakMap,gs=new WeakSet,Wg=function(n,e,t,i){const r=this.lonLatToWorldCoords(e,t);i!==void 0&&(n.position.y=i),[n.position.x,n.position.z]=r},nb=function(n,e){on(this,br,_t(this,ka).project(n,e))},Xg=function(n){var e,t,i;let r=Number.MAX_VALUE;BH(this,Ao)._++,(e=_t(this,Cr))==null||e.sendData("/gps/new",{gpsCount:_t(this,Ao),lat:n.coords.latitude,lon:n.coords.longitude,acc:n.coords.accuracy,session:_t(this,As)}),n.coords.accuracy<=_t(this,za)&&(_t(this,us)===null?on(this,us,{latitude:n.coords.latitude,longitude:n.coords.longitude}):r=$i(this,gs,ib).call(this,_t(this,us),n.coords),r>=_t(this,Ga)&&(_t(this,us).longitude=n.coords.longitude,_t(this,us).latitude=n.coords.latitude,_t(this,br)||($i(this,gs,nb).call(this,n.coords.longitude,n.coords.latitude),(t=_t(this,Cr))==null||t.sendData("/worldorigin/new",{gpsCount:_t(this,Ao),lat:n.coords.latitude,lon:n.coords.longitude,session:_t(this,As),initialPosition:_t(this,br)})),$i(this,gs,Wg).call(this,this.camera,n.coords.longitude,n.coords.latitude),(i=_t(this,Cr))==null||i.sendData("/gps/accepted",{gpsCount:_t(this,Ao),cameraX:this.camera.position.x,cameraZ:this.camera.position.z,session:_t(this,As),distMoved:r}),_t(this,ms).gpsupdate&&_t(this,ms).gpsupdate(n,r)))},ib=function(n,e){const t=fi.degToRad(e.longitude-n.longitude),i=fi.degToRad(e.latitude-n.latitude),r=Math.sin(i/2)*Math.sin(i/2)+Math.cos(fi.degToRad(n.latitude))*Math.cos(fi.degToRad(e.latitude))*(Math.sin(t/2)*Math.sin(t/2));return 2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r))*6371e3};class PH{constructor(e={},t){this.sceneWebcam=new GN;let i;if(t?i=document.querySelector(t):(i=document.createElement("video"),i.setAttribute("autoplay",!0),i.setAttribute("playsinline",!0),i.style.display="none",document.body.appendChild(i)),this.texture=new VN(i),navigator.mediaDevices&&navigator.mediaDevices.getUserMedia){const r={video:{width:{ideal:e.idealWidth||1280},height:{ideal:e.idealHeight||720},facingMode:"environment"}};navigator.mediaDevices.getUserMedia(r).then(s=>{i.addEventListener("loadedmetadata",()=>{var o;i.setAttribute("width",i.videoWidth),i.setAttribute("height",i.videoHeight),i.play(),(o=e.onVideoStarted)==null||o.call(this,this.texture)}),i.srcObject=s}).catch(s=>{setTimeout(()=>{alert(`Webcam Error
Name: `+s.name+`
Message: `+s.message)},1e3)})}else setTimeout(()=>{alert("sorry - media devices API not supported")},1e3)}dispose(){this.texture.dispose()}}const rb=navigator.userAgent.match(/iPhone|iPad|iPod/i)||/Macintosh/i.test(navigator.userAgent)&&navigator.maxTouchPoints!=null&&navigator.maxTouchPoints>1,UH=new ye(0,0,1),sb=new Oi,FH=new Vr,NH=new Vr(-Math.sqrt(.5),0,0,Math.sqrt(.5)),OH={type:"change"};class kH extends Fo{constructor(e){super(),window.isSecureContext===!1&&console.error("THREE.DeviceOrientationControls: DeviceOrientationEvent is only available in secure contexts (https)");const t=this,i=1e-6,r=new Vr;this.object=e,this.object.rotation.reorder("YXZ"),this.enabled=!0,this.deviceOrientation=null,this.screenOrientation=0,this.alphaOffset=0,this.initialOffset=null,this.TWO_PI=2*Math.PI,this.HALF_PI=.5*Math.PI,this.orientationChangeEventName="ondeviceorientationabsolute"in window?"deviceorientationabsolute":"deviceorientation",this.smoothingFactor=1;const s=function({alpha:l,beta:c,gamma:h,webkitCompassHeading:u}){if(rb){const d=360-u;t.alphaOffset=fi.degToRad(d-l),t.deviceOrientation={alpha:l,beta:c,gamma:h,webkitCompassHeading:u}}else l<0&&(l+=360),t.deviceOrientation={alpha:l,beta:c,gamma:h};window.dispatchEvent(new CustomEvent("camera-rotation-change",{detail:{cameraRotation:e.rotation}}))},o=function(){t.screenOrientation=window.orientation||0},a=function(l,c,h,u,d){sb.set(h,c,-u,"YXZ"),l.setFromEuler(sb),l.multiply(NH),l.multiply(FH.setFromAxisAngle(UH,-d))};this.connect=function(){o(),window.DeviceOrientationEvent!==void 0&&typeof window.DeviceOrientationEvent.requestPermission=="function"?window.DeviceOrientationEvent.requestPermission().then(l=>{l==="granted"&&(window.addEventListener("orientationchange",o),window.addEventListener(t.orientationChangeEventName,s))}).catch(function(l){console.error("THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:",l)}):(window.addEventListener("orientationchange",o),window.addEventListener(t.orientationChangeEventName,s)),t.enabled=!0},this.disconnect=function(){window.removeEventListener("orientationchange",o),window.removeEventListener(t.orientationChangeEventName,s),t.enabled=!1,t.initialOffset=!1,t.deviceOrientation=null},this.update=function({theta:l=0}={theta:0}){if(t.enabled===!1)return;const c=t.deviceOrientation;if(c){let h=c.alpha?fi.degToRad(c.alpha)+t.alphaOffset:0,u=c.beta?fi.degToRad(c.beta):0,d=c.gamma?fi.degToRad(c.gamma):0;const f=t.screenOrientation?fi.degToRad(t.screenOrientation):0;if(rb){const A=new Vr;a(A,h,u,d,f);const g=new Oi().setFromQuaternion(A,"YXZ");console.log(g.x,g.y,g.z),g.y=fi.degToRad(360-c.webkitCompassHeading),A.setFromEuler(g),t.object.quaternion.copy(A)}else{if(this.smoothingFactor<1){if(this.lastOrientation){const A=this.smoothingFactor;h=this._getSmoothedAngle(h,this.lastOrientation.alpha,A),u=this._getSmoothedAngle(u+Math.PI,this.lastOrientation.beta,A),d=this._getSmoothedAngle(d+this.HALF_PI,this.lastOrientation.gamma,A,Math.PI)}else u+=Math.PI,d+=this.HALF_PI;this.lastOrientation={alpha:h,beta:u,gamma:d}}a(t.object.quaternion,h+l,this.smoothingFactor<1?u-Math.PI:u,this.smoothingFactor<1?d-this.HALF_PI:d,f)}8*(1-r.dot(t.object.quaternion))>i&&(r.copy(t.object.quaternion),t.dispatchEvent(OH))}},this._orderAngle=function(l,c,h=this.TWO_PI){return c>l&&Math.abs(c-l)<h/2||l>c&&Math.abs(c-l)>h/2?{left:l,right:c}:{left:c,right:l}},this._getSmoothedAngle=function(l,c,h,u=this.TWO_PI){const d=this._orderAngle(l,c,u),f=d.left,A=d.right;d.left=0,d.right-=f,d.right<0&&(d.right+=u);let g=A==c?(1-h)*d.right+h*d.left:h*d.right+(1-h)*d.left;return g+=f,g>=u&&(g-=u),g},this.updateAlphaOffset=function(){t.initialOffset=!1},this.dispose=function(){t.disconnect()},this.getAlpha=function(){const{deviceOrientation:l}=t;return l&&l.alpha?fi.degToRad(l.alpha)+t.alphaOffset:0},this.getBeta=function(){const{deviceOrientation:l}=t;return l&&l.beta?fi.degToRad(l.beta):0},window.DeviceOrientationEvent!==void 0&&typeof window.DeviceOrientationEvent.requestPermission=="function"?this.initPermissionDialog():this.connect()}initPermissionDialog(){const e=document.createElement("div"),t=document.createElement("div"),i=document.createElement("div"),r=document.createElement("div");document.body.appendChild(e);const s={display:"flex",position:"fixed",top:0,left:0,width:"100%",height:"100%",zIndex:1,backgroundColor:"rgba(0,0,0,0.6)",justifyContent:"center",alignItems:"center"},o={backgroundColor:"white",padding:"6px",borderRadius:"3px",width:"36rem",height:"24rem"},a={width:"100%",height:"70%",display:"flex",justifyContent:"center",alignItems:"center"},l={display:"inline-flex",width:"100%",height:"30%",justifyContent:"center",alignItems:"center"};for(let u in s)e.style[u]=s[u];for(let u in o)t.style[u]=o[u];for(let u in a)i.style[u]=a[u];for(let u in l)r.style[u]=l[u];e.appendChild(t),t.appendChild(i),t.appendChild(r),i.innerHTML='<div style="font-size: 24pt; margin: 1rem;">This immersive website requires access to your device motion sensors.</div>';const c=()=>{this.connect(),e.style.display="none"},h=document.createElement("button");h.addEventListener("click",c),h.style.width="50%",h.style.height="80%",h.style.fontSize="20pt",h.appendChild(document.createTextNode("OK")),r.appendChild(h),document.body.appendChild(e)}}class zV{constructor(e){this.raycaster=new YN,this.normalisedMousePosition=new zt(null,null),e.domElement.addEventListener("click",t=>{this.normalisedMousePosition.set(t.clientX/e.domElement.clientWidth*2-1,-(t.clientY/e.domElement.clientHeight*2)+1)})}raycast(e,t){if(this.normalisedMousePosition.x!==null&&this.normalisedMousePosition.y!==null){this.raycaster.setFromCamera(this.normalisedMousePosition,e);const i=this.raycaster.intersectObjects(t.children,!1);return this.normalisedMousePosition.set(null,null),i}return[]}}AFRAME.registerComponent("locar-webcam",{schema:{idealWidth:{type:"number",default:1024},idealHeight:{type:"number",default:768},videoElement:{type:"string",default:""}},init:function(){new PH({idealWidth:this.data.idealWidth,idealHeight:this.data.idealHeight,onVideoStarted:n=>{this.el.object3D.background=n}},this.data.videoElement||null)}});AFRAME.registerComponent("locar-camera",{schema:{simulateLatitude:{type:"number",default:0},simulateLongitude:{type:"number",default:0},simulateAltitude:{type:"number",default:-Number.MAX_VALUE},positionMinAccuracy:{type:"number",default:100}},init:function(){this.locar=new DH(this.el.sceneEl.object3D,this.el.object3D),this.locar.on("gpsupdate",(n,e)=>{this.el.emit("gpsupdate",{position:n,distMoved:e})}),this.locar.on("gpserror",n=>{const e=["User denied access to GPS.","GPS satellites not available.","Timeout communicating with GPS satellites - try moving to a more open area."];n>=1&&n<=3?alert(e[n-1]):alert(`Unknown geolocation error code ${n}.`)}),this._isMobile()&&(this.deviceOrientationControls=new kH(this.el.object3D))},update:function(n){this.locar.setGpsOptions({gpsMinAccuracy:this.data.positionMinAccuracy,gpsMinDistance:this.data.gpsMinDistance}),(this.data.simulateLatitude!==0||this.data.simulateLongitude!==0)&&(this.data.simulateLatitude!=(n==null?void 0:n.simulateLatitude)||this.data.simulateLongitude!=(n==null?void 0:n.simulateLongitude))&&(this.locar.stopGps(),this.locar.fakeGps(this.data.simulateLongitude,this.data.simulateLatitude),this.data.simulateLongitude=0,this.data.simulateLatitude=0),this.data.simulateAltitude>-Number.MAX_VALUE&&this.locar.setElevation(this.data.simulateAltitude+1.6)},play:function(){this.locar.startGps()},pause:function(){this.locar.stopGps()},lonLatToWorldCoords:function(n,e){return this.locar.lonLatToWorldCoords(n,e)},tick:function(){var n;(n=this.deviceOrientationControls)==null||n.update()},_isMobile:function(){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||/Macintosh/i.test(navigator.userAgent)&&navigator.maxTouchPoints!=null&&navigator.maxTouchPoints>1}});AFRAME.registerComponent("locar-entity-place",{schema:{latitude:{type:"number",default:0},longitude:{type:"number",default:0}},init:function(){const n=this.el.sceneEl.querySelector("[locar-camera]");this.locarCamera=n.components["locar-camera"]},update:function(n){this.locarCamera||console.error("Cannot update locar-entity-place without a locar-camera component on the scene camera.");const e=this.locarCamera.lonLatToWorldCoords(this.data.longitude,this.data.latitude);this.el.object3D.position.set(e[0],this.el.object3D.position.y,e[1])}});export{Xc as B,PH as J,DH as K,Br as M,Ri as P,GN as S,GV as W,ZS as a,zV as r,kH as s};
